(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("jquery"));
	else if(typeof define === 'function' && define.amd)
		define(["jquery"], factory);
	else if(typeof exports === 'object')
		exports["autonumeric"] = factory(require("jquery"));
	else
		root["autonumeric"] = factory(root["jQuery"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*** IMPORTS FROM imports-loader ***/\nvar jQuery = __webpack_require__(1);\nvar $ = __webpack_require__(1);\n(function() {\n\n'use strict';\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\r\n* autoNumeric.js\r\n* @author: Bob Knothe\r\n* @contributors: Sokolov Yura and other Github users\r\n* @version: 2.0 - 2016-11-25 GMT 23:00\r\n*\r\n* Created by Robert J. Knothe on 2009-08-09. Please report any bugs to https://github.com/BobKnothe/autoNumeric\r\n*\r\n* Copyright (c) 2009 Robert J. Knothe http://www.decorplanit.com/plugin/\r\n*\r\n* The MIT License (http://www.opensource.org/licenses/mit-license.php)\r\n*\r\n* Permission is hereby granted, free of charge, to any person\r\n* obtaining a copy of this software and associated documentation\r\n* files (the \"Software\"), to deal in the Software without\r\n* restriction, including without limitation the rights to use,\r\n* copy, modify, merge, publish, distribute, sub license, and/or sell\r\n* copies of the Software, and to permit persons to whom the\r\n* Software is furnished to do so, subject to the following\r\n* conditions:\r\n*\r\n* The above copyright notice and this permission notice shall be\r\n* included in all copies or substantial portions of the Software.\r\n*\r\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\r\n* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\r\n* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\r\n* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\r\n* OTHER DEALINGS IN THE SOFTWARE.\r\n*/\n\nvar autoFormat = void 0;\nvar autoUnFormat = void 0;\nvar getDefaultConfig = void 0;\n\n/* global module, require, define */\n\n(function (factory) {\n    //TODO This surely can be improved by letting webpack take care of generating this UMD part\n    if (true) {\n        // AMD. Register as an anonymous module.\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {\n        // Node/CommonJS\n        module.exports = factory(require('jquery'));\n    } else {\n        // Browser globals\n        factory(window.jQuery);\n    }\n})(function ($) {\n    /**\r\n     * Wrapper variable that hold named keyboard keys with their respective keyCode as seen in DOM events.\r\n     */\n    var keyCode = {\n        Backspace: 8,\n        Tab: 9,\n        Enter: 13,\n        Shift: 16,\n        Ctrl: 17,\n        Alt: 18,\n        PauseBreak: 19,\n        CapsLock: 20,\n        Esc: 27,\n        Space: 32,\n        PageUp: 33,\n        PageDown: 34,\n        End: 35,\n        Home: 36,\n        LeftArrow: 37,\n        UpArrow: 38,\n        RightArrow: 39,\n        DownArrow: 40,\n        Insert: 45,\n        Delete: 46,\n        num0: 48,\n        num1: 49,\n        num2: 50,\n        num3: 51,\n        num4: 52,\n        num5: 53,\n        num6: 54,\n        num7: 55,\n        num8: 56,\n        num9: 57,\n        a: 65,\n        b: 66,\n        c: 67,\n        d: 68,\n        e: 69,\n        f: 70,\n        g: 71,\n        h: 72,\n        i: 73,\n        j: 74,\n        k: 75,\n        l: 76,\n        m: 77,\n        n: 78,\n        o: 79,\n        p: 80,\n        q: 81,\n        r: 82,\n        s: 83,\n        t: 84,\n        u: 85,\n        v: 86,\n        w: 87,\n        x: 88,\n        y: 89,\n        z: 90,\n        Windows: 91,\n        RightClick: 93,\n        numpad0: 96,\n        numpad1: 97,\n        numpad2: 98,\n        numpad3: 99,\n        numpad4: 100,\n        numpad5: 101,\n        numpad6: 102,\n        numpad7: 103,\n        numpad8: 104,\n        numpad9: 105,\n        MultiplyNumpad: 106,\n        PlusNumpad: 107,\n        MinusNumpad: 109,\n        DotNumpad: 110,\n        SlashNumpad: 111,\n        F1: 112,\n        F2: 113,\n        F3: 114,\n        F4: 115,\n        F5: 116,\n        F6: 117,\n        F7: 118,\n        F8: 119,\n        F9: 120,\n        F10: 121,\n        F11: 122,\n        F12: 123,\n        NumLock: 144,\n        ScrollLock: 145,\n        MyComputer: 182,\n        MyCalculator: 183,\n        Semicolon: 186,\n        Equal: 187,\n        Comma: 188,\n        Hyphen: 189,\n        Dot: 190,\n        Slash: 191,\n        Backquote: 192,\n        LeftBracket: 219,\n        Backslash: 220,\n        RightBracket: 221,\n        Quote: 222,\n        Command: 224\n    };\n\n    /**\r\n     * Return TRUE if the `value` is undefined\r\n     *\r\n     * @static\r\n     * @param {*} value\r\n     * @returns {boolean}\r\n     */\n    function isUndefined(value) {\n        return value === void 0;\n    }\n\n    /**\r\n     * Return TRUE if the `value` is undefined, null or empty\r\n     *\r\n     * @param value\r\n     * @returns {boolean}\r\n     */\n    function isUndefinedOrNullOrEmpty(value) {\n        return value === null || value === void 0 || '' === value;\n    }\n\n    /**\r\n     * Return TRUE if the given parameter is as String\r\n     *\r\n     * @param {*} str\r\n     * @returns {boolean}\r\n     */\n    function isString(str) {\n        return typeof str === 'string' || str instanceof String;\n    }\n\n    /**\r\n     * Return TRUE is the string `str` contains the string `needle`\r\n     * Note: this function does not coerce the parameters types\r\n     *\r\n     * @param {string} str\r\n     * @param {string} needle\r\n     * @returns {boolean}\r\n     */\n    function contains(str, needle) {\n        if (!isString(str) || !isString(needle) || str === '' || needle === '') {\n            return false;\n        }\n\n        return str.indexOf(needle) !== -1;\n    }\n\n    /**\r\n     * Return TRUE if the `needle` is in the array\r\n     *\r\n     * @param {Array} array\r\n     * @param {*} needle\r\n     * @returns {boolean}\r\n     */\n    function isInArray(needle, array) {\n        if (!isArray(array) || array === [] || isUndefined(needle) || needle === '' || needle === null) {\n            return false;\n        }\n\n        return array.indexOf(needle) !== -1;\n    }\n\n    /**\r\n     * Return TRUE if the parameter is an Array\r\n     *\r\n     * @param {*} arr\r\n     * @throws Error\r\n     * @returns {*|boolean}\r\n     */\n    function isArray(arr) {\n        if (Object.prototype.toString.call([]) === '[object Array]') {\n            // Make sure an array has a class attribute of [object Array]\n            // Test passed, now check if is an Array\n            return Array.isArray(arr) || (typeof arr === 'undefined' ? 'undefined' : _typeof(arr)) === 'object' && Object.prototype.toString.call(arr) === '[object Array]';\n        } else {\n            throw new Error('toString message changed for Object Array'); // Verify that the string returned by `toString` does not change in the future (cf. http://stackoverflow.com/a/8365215)\n        }\n    }\n\n    /**\r\n     * Cross browser routine for getting selected range/cursor position\r\n     */\n    function getElementSelection(that) {\n        var position = {};\n        if (isUndefined(that.selectionStart)) {\n            that.focus();\n            var select = document.selection.createRange();\n            position.length = select.text.length;\n            select.moveStart('character', -that.value.length);\n            position.end = select.text.length;\n            position.start = position.end - position.length;\n        } else {\n            position.start = that.selectionStart;\n            position.end = that.selectionEnd;\n            position.length = position.end - position.start;\n        }\n\n        return position;\n    }\n\n    /**\r\n     * Cross browser routine for setting selected range/cursor position\r\n     */\n    function setElementSelection(that, start, end) {\n        if (isUndefined(that.selectionStart)) {\n            that.focus();\n            var range = that.createTextRange();\n            range.collapse(true);\n            range.moveEnd('character', end);\n            range.moveStart('character', start);\n            range.select();\n        } else {\n            that.selectionStart = start;\n            that.selectionEnd = end;\n        }\n    }\n\n    /**\r\n     * Function to handle errors messages\r\n     */\n    function throwError(message, debug) {\n        if (debug) {\n            throw new Error(message);\n        }\n    }\n\n    /**\r\n     * run callbacks in parameters if any\r\n     * any parameter could be a callback:\r\n     * - a function, which invoked with jQuery element, parameters and this parameter name and returns parameter value\r\n     * - a name of function, attached to $(selector).autoNumeric.functionName(){} - which was called previously\r\n     */\n    function runCallbacks($this, settings) {\n        // loops through the settings object (option array) to find the following\n        $.each(settings, function (k, val) {\n            if (typeof val === 'function') {\n                settings[k] = val($this, settings, k);\n            } else if (typeof $this.autoNumeric[val] === 'function') {\n                // calls the attached function from the html5 data example: data-a-sign=\"functionName\"\n                settings[k] = $this.autoNumeric[val]($this, settings, k);\n            }\n        });\n    }\n\n    /**\r\n     * Determine the decimal length from the vMin vMax settings\r\n     */\n    function decLength(vMin, vMax) {\n        var vMaxLength = 0;\n        var vMinLength = 0;\n        if (vMax[1]) {\n            vMaxLength = vMax[1].length;\n        }\n        if (vMin[1]) {\n            vMinLength = vMin[1].length;\n        }\n\n        return Math.max(vMaxLength, vMinLength);\n    }\n\n    /**\r\n     * Preparing user defined options for further usage\r\n     * merge them with defaults appropriately\r\n     */\n    function autoCode($this, settings) {\n        runCallbacks($this, settings);\n        var vMax = settings.vMax.toString().split('.');\n        var vMin = !settings.vMin && settings.vMin !== 0 ? [] : settings.vMin.toString().split('.');\n        settings.aNeg = settings.vMin < 0 ? '-' : '';\n        vMax[0] = vMax[0].replace('-', '');\n        vMin[0] = vMin[0].replace('-', '');\n        settings.mIntPos = Math.max(vMax[0].length, 1);\n        settings.mIntNeg = Math.max(vMin[0].length, 1);\n        if (settings.mDec === null) {\n            settings.mDec = decLength(vMin, vMax);\n            settings.oDec = settings.mDec;\n        } else {\n            settings.mDec = Number(settings.mDec);\n        }\n        settings.mDec = settings.scaleDivisor && settings.scaleDecimal ? settings.scaleDecimal : settings.mDec;\n\n        // set alternative decimal separator key\n        if (settings.altDec === null && settings.mDec > 0) {\n            if (settings.aDec === '.' && settings.aSep !== ',') {\n                settings.altDec = ',';\n            } else if (settings.aDec === ',' && settings.aSep !== '.') {\n                settings.altDec = '.';\n            }\n        }\n\n        // cache regexps for autoStrip\n        var aNegReg = settings.aNeg ? '([-\\\\' + settings.aNeg + ']?)' : '(-?)';\n        settings.aNegRegAutoStrip = aNegReg;\n        settings.skipFirstAutoStrip = new RegExp(aNegReg + '[^-' + (settings.aNeg ? '\\\\' + settings.aNeg : '') + '\\\\' + settings.aDec + '\\\\d].*?(\\\\d|\\\\' + settings.aDec + '\\\\d)');\n        settings.skipLastAutoStrip = new RegExp('(\\\\d\\\\' + settings.aDec + '?)[^\\\\' + settings.aDec + '\\\\d]\\\\D*$');\n        var allowed = '-0123456789\\\\' + settings.aDec;\n        settings.allowedAutoStrip = new RegExp('[^' + allowed + ']', 'gi');\n        settings.numRegAutoStrip = new RegExp(aNegReg + '(?:\\\\' + settings.aDec + '?(\\\\d+\\\\' + settings.aDec + '\\\\d+)|(\\\\d*(?:\\\\' + settings.aDec + '\\\\d*)?))');\n\n        return settings;\n    }\n\n    /**\r\n     * strip all unwanted characters and leave only a number alert\r\n     */\n    function autoStrip(s, settings) {\n        if (settings.aSign !== '') {\n            // remove currency sign\n            s = s.replace(settings.aSign, '');\n        }\n        if (settings.aSuffix) {\n            // remove suffix\n            while (contains(s, settings.aSuffix)) {\n                s = s.replace(settings.aSuffix, '');\n            }\n        }\n\n        // first replace anything before digits\n        s = s.replace(settings.skipFirstAutoStrip, '$1$2');\n\n        if ((settings.pNeg === 's' || settings.pSign === 's' && settings.pNeg !== 'p') && contains(s, '-') && s !== '') {\n            settings.trailingNegative = true;\n        }\n\n        // then replace anything after digits\n        s = s.replace(settings.skipLastAutoStrip, '$1');\n\n        // then remove any uninterested characters\n        s = s.replace(settings.allowedAutoStrip, '');\n        if (settings.altDec) {\n            s = s.replace(settings.altDec, settings.aDec);\n        }\n\n        // get only number string\n        var m = s.match(settings.numRegAutoStrip);\n        s = m ? [m[1], m[2], m[3]].join('') : '';\n        if (settings.lZero === 'allow' || settings.lZero === 'keep') {\n            var nSign = '';\n\n            var _s$split = s.split(settings.aDec),\n                _s$split2 = _slicedToArray(_s$split, 2),\n                integerPart = _s$split2[0],\n                decimalPart = _s$split2[1];\n\n            var modifiedIntegerPart = integerPart;\n            if (contains(modifiedIntegerPart, settings.aNeg)) {\n                nSign = settings.aNeg;\n                modifiedIntegerPart = modifiedIntegerPart.replace(settings.aNeg, '');\n            }\n\n            // strip leading zero on positive value if need\n            if (nSign === '' && modifiedIntegerPart.length > settings.mIntPos && modifiedIntegerPart.charAt(0) === '0') {\n                modifiedIntegerPart = modifiedIntegerPart.slice(1);\n            }\n\n            // strip leading zero on negative value if need\n            if (nSign !== '' && modifiedIntegerPart.length > settings.mIntNeg && modifiedIntegerPart.charAt(0) === '0') {\n                modifiedIntegerPart = modifiedIntegerPart.slice(1);\n            }\n            s = '' + nSign + modifiedIntegerPart + (isUndefined(decimalPart) ? '' : settings.aDec + decimalPart);\n        }\n        if (settings.onOff && settings.lZero === 'deny' || settings.lZero === 'allow' && settings.onOff === false) {\n            // Using this regex version `^${settings.aNegRegAutoStrip}0*(\\\\d|$)` entirely clear the input on blur\n            var stripReg = '^' + settings.aNegRegAutoStrip + '0*(\\\\d)';\n            stripReg = new RegExp(stripReg);\n            s = s.replace(stripReg, '$1$2');\n        }\n\n        return s;\n    }\n\n    /**\r\n     * places or removes brackets on negative values\r\n     */\n    function negativeBracket(s, settings) {\n        if (settings.pSign === 'p' && settings.pNeg === 'l' || settings.pSign === 's' && settings.pNeg === 'p') {\n            var _settings$nBracket$sp = settings.nBracket.split(','),\n                _settings$nBracket$sp2 = _slicedToArray(_settings$nBracket$sp, 2),\n                firstBracket = _settings$nBracket$sp2[0],\n                lastBracket = _settings$nBracket$sp2[1];\n\n            if (!settings.onOff) {\n                s = s.replace(settings.aNeg, '');\n                s = firstBracket + s + lastBracket;\n            } else if (settings.onOff && s.charAt(0) === firstBracket) {\n                s = s.replace(firstBracket, settings.aNeg);\n                s = s.replace(lastBracket, '');\n            }\n        }\n\n        return s;\n    }\n\n    /**\r\n     * convert locale format to Javascript numeric string\r\n     * allows locale decimal separator to be a period or comma - no thousand separator allowed of currency signs allowed\r\n     * '1234.56'    OK\r\n     * '-1234.56'   OK\r\n     * '1234.56-'   OK\r\n     * '1234,56'    OK\r\n     * '-1234,56'   OK\r\n     * '1234,56-'   OK\r\n     */\n    function fromLocale(s) {\n        s = s.replace(',', '.');\n        if (contains(s, '-') && s.lastIndexOf('-') === s.length - 1) {\n            s = s.replace('-', '');\n            s = '-' + s;\n        }\n\n        return s;\n    }\n\n    /**\r\n     * converts the ISO numeric string to the locale decimal and minus sign placement\r\n     * see \"localeOutput\" option for determine\r\n     * null => nnnn.nn or -nnnn.nn default\r\n     * \",\"  => nnnn,nn or -nnnn,nn can als be \"-,\"\r\n     * \".-\" => nnnn.nn or nnnn.nn-\r\n     * \",-\" => nnnn,nn or nnnn,nn-\r\n     */\n    function toLocale(value, locale) {\n        if (locale === '.-') {\n            value = contains(value, '-') ? value.replace('-', '') + '-' : value;\n        }\n        if (locale === ',' || locale === '-,') {\n            value = value.replace('.', ',');\n        }\n        if (locale === ',-') {\n            value = value.replace('.', ',');\n            value = contains(value, '-') ? value.replace('-', '') + '-' : value;\n        }\n\n        return value;\n    }\n\n    /**\r\n     * prepare number string to be converted to real number\r\n     */\n    function fixNumber(s, aDec, aNeg) {\n        if (aDec && aDec !== '.') {\n            s = s.replace(aDec, '.');\n        }\n        if (aNeg && aNeg !== '-') {\n            s = s.replace(aNeg, '-');\n        }\n        if (!s.match(/\\d/)) {\n            s += '0';\n        }\n\n        return s;\n    }\n\n    /**\r\n     * prepare real number to be converted to our format\r\n     */\n    function presentNumber(s, settings) {\n        if (settings.aNeg && settings.aNeg !== '-') {\n            s = s.replace('-', settings.aNeg);\n        }\n        if (settings.aDec && settings.aDec !== '.') {\n            s = s.replace('.', settings.aDec);\n        }\n\n        return s;\n    }\n\n    /**\r\n     * private function to check for empty value\r\n     */\n    function checkEmpty(iv, settings, signOnEmpty) {\n        if (iv === '' || iv === settings.aNeg) {\n            if (settings.wEmpty === 'always' || signOnEmpty) {\n                return settings.pNeg === 'l' ? iv + settings.aSign + settings.aSuffix : settings.aSign + iv + settings.aSuffix;\n            }\n            return iv;\n        }\n\n        return null;\n    }\n\n    /**\r\n     * private function that formats our number\r\n     */\n    function autoGroup(iv, settings) {\n        if (settings.strip) {\n            iv = autoStrip(iv, settings);\n        }\n        if (settings.trailingNegative && !contains(iv, '-')) {\n            iv = '-' + iv;\n        }\n        var empty = checkEmpty(iv, settings, true);\n        var isNeg = contains(iv, '-');\n        if (isNeg) {\n            iv = iv.replace('-', '');\n        }\n        if (empty !== null) {\n            return empty;\n        }\n        var digitalGroup = '';\n        settings.dGroup = settings.dGroup.toString();\n        if (settings.dGroup === '2') {\n            digitalGroup = /(\\d)((\\d)(\\d{2}?)+)$/;\n        } else if (settings.dGroup === '2s') {\n            digitalGroup = /(\\d)((?:\\d{2}){0,2}\\d{3}(?:(?:\\d{2}){2}\\d{3})*?)$/;\n        } else if (settings.dGroup === '4') {\n            digitalGroup = /(\\d)((\\d{4}?)+)$/;\n        } else {\n            digitalGroup = /(\\d)((\\d{3}?)+)$/;\n        }\n\n        // splits the string at the decimal string\n\n        var _iv$split = iv.split(settings.aDec),\n            _iv$split2 = _slicedToArray(_iv$split, 2),\n            integerPart = _iv$split2[0],\n            decimalPart = _iv$split2[1];\n\n        if (settings.altDec && isUndefined(decimalPart)) {\n            var _iv$split3 = iv.split(settings.altDec);\n\n            var _iv$split4 = _slicedToArray(_iv$split3, 2);\n\n            integerPart = _iv$split4[0];\n            decimalPart = _iv$split4[1];\n        }\n        if (settings.aSep !== '') {\n            // re-inserts the thousand separator via a regular expression\n            while (digitalGroup.test(integerPart)) {\n                integerPart = integerPart.replace(digitalGroup, '$1' + settings.aSep + '$2');\n            }\n        }\n        if (settings.mDec !== 0 && !isUndefined(decimalPart)) {\n            if (decimalPart.length > settings.mDec) {\n                decimalPart = decimalPart.substring(0, settings.mDec);\n            }\n\n            // joins the whole number with the decimal value\n            iv = integerPart + settings.aDec + decimalPart;\n        } else {\n            // if whole numbers only\n            iv = integerPart;\n        }\n        if (settings.pSign === 'p') {\n            if (isNeg && settings.pNeg === 'l') {\n                iv = settings.aNeg + settings.aSign + iv;\n            }\n            if (isNeg && settings.pNeg === 'r') {\n                iv = settings.aSign + settings.aNeg + iv;\n            }\n            if (isNeg && settings.pNeg === 's') {\n                iv = settings.aSign + iv + settings.aNeg;\n            }\n            if (!isNeg) {\n                iv = settings.aSign + iv;\n            }\n        }\n        if (settings.pSign === 's') {\n            if (isNeg && settings.pNeg === 'r') {\n                iv = iv + settings.aSign + settings.aNeg;\n            }\n            if (isNeg && settings.pNeg === 'l') {\n                iv = iv + settings.aNeg + settings.aSign;\n            }\n            if (isNeg && settings.pNeg === 'p') {\n                iv = settings.aNeg + iv + settings.aSign;\n            }\n            if (!isNeg) {\n                iv = iv + settings.aSign;\n            }\n        }\n\n        // removes the negative sign and places brackets\n        if (settings.nBracket !== null && (settings.rawValue < 0 || iv.charAt(0) === '-')) {\n            iv = negativeBracket(iv, settings);\n        }\n        settings.trailingNegative = false;\n\n        return iv + settings.aSuffix;\n    }\n\n    /**\r\n     * Truncate not needed zeros\r\n     */\n    function truncateZeros(ivRounded, rDec) {\n        var regex = void 0;\n        switch (rDec) {\n            case 0:\n                // prevents padding - removes trailing zeros to the first significant digit\n                regex = /(\\.(?:\\d*[1-9])?)0*$/;\n                break;\n            case 1:\n                // allows padding when mDec equals one - leaves one zero trailing the decimal character\n                regex = /(\\.\\d(?:\\d*[1-9])?)0*$/;\n                break;\n            default:\n                // removes access zeros to the mDec length when aPad is set true\n                regex = new RegExp('(\\\\.\\\\d{' + rDec + '}(?:\\\\d*[1-9])?)0*');\n        }\n\n        // If there are no decimal places, we don't need a decimal point at the end\n        ivRounded = ivRounded.replace(regex, '$1');\n        if (rDec === 0) {\n            ivRounded = ivRounded.replace(/\\.$/, '');\n        }\n\n        return ivRounded;\n    }\n\n    /**\r\n     * round number after setting by pasting or $().autoNumericSet()\r\n     * private function for round the number\r\n     * please note this handled as text - JavaScript math function can return inaccurate values\r\n     * also this offers multiple rounding methods that are not easily accomplished in JavaScript\r\n     */\n    function autoRound(iv, settings) {\n        // value to string\n        iv = iv === '' ? '0' : iv.toString();\n        if (settings.mRound === 'N05' || settings.mRound === 'CHF' || settings.mRound === 'U05' || settings.mRound === 'D05') {\n            switch (settings.mRound) {\n                case 'N05':\n                    iv = (Math.round(iv * 20) / 20).toString();\n                    break;\n                case 'U05':\n                    iv = (Math.ceil(iv * 20) / 20).toString();\n                    break;\n                default:\n                    iv = (Math.floor(iv * 20) / 20).toString();\n            }\n\n            var result = void 0;\n            if (!contains(iv, '.')) {\n                result = iv + '.00';\n            } else if (iv.length - iv.indexOf('.') < 3) {\n                result = iv + '0';\n            } else {\n                result = iv;\n            }\n            return result;\n        }\n\n        var ivRounded = '';\n        var i = 0;\n        var nSign = '';\n        var rDec = void 0;\n        // sets the truncate zero method\n        if (settings.aPad) {\n            rDec = settings.mDec;\n        } else {\n            rDec = 0;\n        }\n        // Checks if the iv (input Value)is a negative value\n        if (iv.charAt(0) === '-') {\n            nSign = '-';\n\n            // removes the negative sign will be added back later if required\n            iv = iv.replace('-', '');\n        }\n\n        // append a zero if first character is not a digit (then it is likely to be a dot\n        if (!iv.match(/^\\d/)) {\n            iv = '0' + iv;\n        }\n\n        // determines if the value is zero - if zero no negative sign\n        if (nSign === '-' && Number(iv) === 0) {\n            nSign = '';\n        }\n\n        // trims leading zero's needed\n        if (Number(iv) > 0 && settings.lZero !== 'keep' || iv.length > 0 && settings.lZero === 'allow') {\n            iv = iv.replace(/^0*(\\d)/, '$1');\n        }\n\n        var dPos = iv.lastIndexOf('.');\n\n        // virtual decimal position\n        var vdPos = dPos === -1 ? iv.length - 1 : dPos;\n\n        // checks decimal places to determine if rounding is required :\n        // check if no rounding is required\n        var cDec = iv.length - 1 - vdPos;\n        if (cDec <= settings.mDec) {\n            // check if we need to pad with zeros\n            ivRounded = iv;\n            if (cDec < rDec) {\n                if (dPos === -1) {\n                    ivRounded += settings.aDec;\n                }\n                var zeros = '000000';\n                while (cDec < rDec) {\n                    zeros = zeros.substring(0, rDec - cDec);\n                    ivRounded += zeros;\n                    cDec += zeros.length;\n                }\n            } else if (cDec > rDec) {\n                ivRounded = truncateZeros(ivRounded, rDec);\n            } else if (cDec === 0 && rDec === 0) {\n                ivRounded = ivRounded.replace(/\\.$/, '');\n            }\n\n            return Number(ivRounded) === 0 ? ivRounded : nSign + ivRounded;\n        }\n\n        // rounded length of the string after rounding\n        var rLength = dPos + settings.mDec; //TODO Modify `dPos` here if it's not intended that it can be equal to '-1'\n        var tRound = Number(iv.charAt(rLength + 1));\n        var odd = iv.charAt(rLength) === '.' ? iv.charAt(rLength - 1) % 2 : iv.charAt(rLength) % 2;\n        var ivArray = iv.substring(0, rLength + 1).split('');\n        if (tRound > 4 && settings.mRound === 'S' || // Round half up symmetric\n        tRound > 4 && settings.mRound === 'A' && nSign === '' || // Round half up asymmetric positive values\n        tRound > 5 && settings.mRound === 'A' && nSign === '-' || // Round half up asymmetric negative values\n        tRound > 5 && settings.mRound === 's' || // Round half down symmetric\n        tRound > 5 && settings.mRound === 'A' && nSign === '' || // Round half down asymmetric positive values\n        tRound > 4 && settings.mRound === 'A' && nSign === '-' || // Round half down asymmetric negative values\n        tRound > 5 && settings.mRound === 'B' || // Round half even \"Banker's Rounding\"\n        tRound === 5 && settings.mRound === 'B' && odd === 1 || // Round half even \"Banker's Rounding\"\n        tRound > 0 && settings.mRound === 'C' && nSign === '' || // Round to ceiling toward positive infinite\n        tRound > 0 && settings.mRound === 'F' && nSign === '-' || // Round to floor toward negative infinite\n        tRound > 0 && settings.mRound === 'U') {\n            // Round up away from zero\n            // Round up the last digit if required, and continue until no more 9's are found\n            for (i = ivArray.length - 1; i >= 0; i -= 1) {\n                if (ivArray[i] !== '.') {\n                    ivArray[i] = +ivArray[i] + 1;\n                    if (ivArray[i] < 10) {\n                        break;\n                    }\n                    if (i > 0) {\n                        ivArray[i] = '0';\n                    }\n                }\n            }\n        }\n\n        // Reconstruct the string, converting any 10's to 0's\n        ivArray = ivArray.slice(0, rLength + 1);\n\n        // return rounded value\n        ivRounded = truncateZeros(ivArray.join(''), rDec);\n\n        return Number(ivRounded) === 0 ? ivRounded : nSign + ivRounded;\n    }\n\n    /**\r\n     * truncates the decimal part of a number\r\n     */\n    function truncateDecimal(s, settings, paste) {\n        var aDec = settings.aDec;\n        var mDec = settings.mDec;\n        s = paste === 'paste' ? autoRound(s, settings) : s;\n        if (aDec && mDec) {\n            var _s$split3 = s.split(aDec),\n                _s$split4 = _slicedToArray(_s$split3, 2),\n                integerPart = _s$split4[0],\n                decimalPart = _s$split4[1];\n\n            // truncate decimal part to satisfying length since we would round it anyway\n\n\n            if (decimalPart && decimalPart.length > mDec) {\n                if (mDec > 0) {\n                    var modifiedDecimalPart = decimalPart.substring(0, mDec);\n                    s = '' + integerPart + aDec + modifiedDecimalPart;\n                } else {\n                    s = integerPart;\n                }\n            }\n        }\n\n        return s;\n    }\n\n    /**\r\n     * Function to parse vMin, vMax & the input value to prepare for testing to determine if the value falls within the min / max range\r\n     * Return an object example: vMin: \"999999999999999.99\" returns the following \"{s: -1, e: 12, c: Array[15]}\"\r\n     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/\r\n     * Many thanks to Mike\r\n     */\n    function parseStr(n) {\n        var x = {};\n        var e = void 0;\n        var i = void 0;\n        var nL = void 0;\n        var j = void 0;\n\n        // Minus zero?\n        if (n === 0 && 1 / n < 0) {\n            n = '-0';\n        }\n\n        // Determine sign. 1 positive, -1 negative\n        n = n.toString();\n        if (n.charAt(0) === '-') {\n            n = n.slice(1);\n            x.s = -1;\n        } else {\n            x.s = 1;\n        }\n\n        // Decimal point?\n        e = n.indexOf('.');\n        if (e > -1) {\n            n = n.replace('.', '');\n        }\n\n        // length of string if no decimal character\n        if (e < 0) {\n            // Integer\n            e = n.length;\n        }\n\n        // Determine leading zeros\n        i = n.search(/[1-9]/i) === -1 ? n.length : n.search(/[1-9]/i);\n        nL = n.length;\n        if (i === nL) {\n            // Zero\n            x.e = 0;\n            x.c = [0];\n        } else {\n            // Determine trailing zeros\n            for (j = nL - 1; n.charAt(j) === '0'; j -= 1) {\n                nL -= 1;\n            }\n            nL -= 1;\n\n            // Decimal location\n            x.e = e - i - 1;\n            x.c = [];\n\n            // Convert string to array of digits without leading/trailing zeros\n            for (e = 0; i <= nL; i += 1) {\n                x.c[e] = +n.charAt(i);\n                e += 1;\n            }\n        }\n\n        return x;\n    }\n\n    /**\r\n     * Function to test if the input value falls with the Min / Max settings\r\n     * This uses the parsed strings for the above parseStr function\r\n     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/\r\n     * Many thanks to Mike\r\n     */\n    function testMinMax(y, x) {\n        var xc = x.c;\n        var yc = y.c;\n        var i = x.s;\n        var j = y.s;\n        var k = x.e;\n        var l = y.e;\n\n        // Either zero?\n        if (!xc[0] || !yc[0]) {\n            var _result = void 0;\n            if (!xc[0]) {\n                _result = !yc[0] ? 0 : -j;\n            } else {\n                _result = i;\n            }\n            return _result;\n        }\n\n        // Signs differ?\n        if (i !== j) {\n            return i;\n        }\n        var xNeg = i < 0;\n\n        // Compare exponents\n        if (k !== l) {\n            return k > l ^ xNeg ? 1 : -1;\n        }\n        i = -1;\n        k = xc.length;\n        l = yc.length;\n        j = k < l ? k : l;\n\n        // Compare digit by digit\n        for (i += 1; i < j; i += 1) {\n            if (xc[i] !== yc[i]) {\n                return xc[i] > yc[i] ^ xNeg ? 1 : -1;\n            }\n        }\n\n        // Compare lengths\n        var result = void 0;\n        if (k === l) {\n            result = 0;\n        } else {\n            result = k > l ^ xNeg ? 1 : -1;\n        }\n\n        return result;\n    }\n\n    /**\r\n     * checking that number satisfy format conditions\r\n     * and lays between settings.vMin and settings.vMax\r\n     * and the string length does not exceed the digits in settings.vMin and settings.vMax\r\n     */\n    function autoCheck(s, settings) {\n        s = s.toString();\n        s = s.replace(',', '.');\n        var minParse = parseStr(settings.vMin);\n        var maxParse = parseStr(settings.vMax);\n        var valParse = parseStr(s);\n\n        var result = void 0;\n        switch (settings.oLimits) {\n            case 'floor':\n                result = [testMinMax(minParse, valParse) > -1, true];\n                break;\n            case 'ceiling':\n                result = [true, testMinMax(maxParse, valParse) < 1];\n                break;\n            case 'ignore':\n                result = [true, true];\n                break;\n            default:\n                result = [testMinMax(minParse, valParse) > -1, testMinMax(maxParse, valParse) < 1];\n        }\n\n        return result;\n    }\n\n    /**\r\n     * thanks to Anthony & Evan C\r\n     */\n    function autoGet(obj) {\n        if (typeof obj === 'string' || obj instanceof String) {\n            obj = obj.replace(/\\[/g, '\\\\[').replace(/]/g, '\\\\]');\n            obj = '#' + obj.replace(/(:|\\.)/g, '\\\\$1');\n            // possible modification to replace the above 2 lines\n            // obj = '#' + obj.replace(/([;&,\\.\\+\\*\\~':\"\\!\\^#$%@\\[\\]\\(\\)=>\\|])/g, '\\\\$1');\n        }\n\n        return $(obj);\n    }\n\n    /**\r\n     * function to attach data to the element\r\n     * and imitate the holder\r\n     */\n    function getHolder($that, settings, update) {\n        var data = $that.data('autoNumeric');\n        if (!data) {\n            data = {};\n            $that.data('autoNumeric', data);\n        }\n        var holder = data.holder;\n        if (isUndefined(holder) && settings || update) {\n            holder = new AutoNumericHolder($that.get(0), settings);\n            data.holder = holder;\n        }\n\n        return holder;\n    }\n\n    /**\r\n     * original settings saved for use when eDec & nSep options are being used\r\n     */\n    function originalSettings(settings) {\n        settings.oDec = settings.mDec;\n        settings.oPad = settings.aPad;\n        settings.oBracket = settings.nBracket;\n        settings.oSep = settings.aSep;\n        settings.oSign = settings.aSign;\n        settings.oSuffix = settings.aSuffix;\n\n        return settings;\n    }\n\n    /**\r\n     * original settings saved for use when eDec options are being used\r\n     * taken from Quirksmode\r\n     */\n    function readCookie(name) {\n        var nameEQ = name + '=';\n        var ca = document.cookie.split(';');\n        var c = '';\n        for (var i = 0; i < ca.length; i += 1) {\n            c = ca[i];\n            while (c.charAt(0) === ' ') {\n                c = c.substring(1, c.length);\n            }\n            if (c.indexOf(nameEQ) === 0) {\n                return c.substring(nameEQ.length, c.length);\n            }\n        }\n\n        return null;\n    }\n\n    /**\r\n     * Test if sessionStorage is supported - taken from modernizr\r\n     */\n    function storageTest() {\n        var mod = 'modernizr';\n        try {\n            sessionStorage.setItem(mod, mod);\n            sessionStorage.removeItem(mod);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\r\n     * creates or removes sessionStorage or cookie depending on browser support\r\n     */\n    function autoSave($this, settings, toDo) {\n        if (settings.aStor) {\n            var storedName = $this[0].name !== '' && !isUndefined($this[0].name) ? 'AUTO_' + decodeURIComponent($this[0].name) : 'AUTO_' + $this[0].id;\n            var date = void 0;\n            var expires = void 0;\n\n            // sets cookie for browser that do not support sessionStorage IE 6 & IE 7\n            if (storageTest() === false) {\n                switch (toDo) {\n                    case 'set':\n                        document.cookie = storedName + '=' + settings.rawValue + '; expires= ; path=/';\n                        break;\n                    case 'wipe':\n                        date = new Date();\n                        date.setTime(date.getTime() + -1 * 24 * 60 * 60 * 1000);\n                        expires = '; expires=' + date.toUTCString(); // Note : `toGMTString()` has been deprecated (cf. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toGMTString)\n                        document.cookie = storedName + '=\\'\\' ;' + expires + '; path=/';\n                        break;\n                    case 'get':\n                        return readCookie(storedName);\n                }\n            } else {\n                switch (toDo) {\n                    case 'set':\n                        sessionStorage.setItem(storedName, settings.rawValue);\n                        break;\n                    case 'wipe':\n                        sessionStorage.removeItem(storedName);\n                        break;\n                    case 'get':\n                        return sessionStorage.getItem(storedName);\n                }\n            }\n        }\n    }\n\n    /**\r\n     * Holder object for field properties\r\n     */\n    function AutoNumericHolder(that, settings) {\n        this.settings = settings;\n        this.that = that;\n        this.$that = $(that);\n        this.formatted = false;\n        this.settingsClone = autoCode(this.$that, this.settings);\n        this.value = that.value;\n    }\n\n    AutoNumericHolder.prototype = {\n        init: function init(e) {\n            this.value = this.that.value;\n            this.settingsClone = autoCode(this.$that, this.settings);\n            this.ctrlKey = e.ctrlKey;\n            this.cmdKey = e.metaKey;\n            this.shiftKey = e.shiftKey;\n\n            // keypress event overwrites meaningful value of e.keyCode\n            this.selection = getElementSelection(this.that);\n            if (e.type === 'keydown' || e.type === 'keyup') {\n                this.kdCode = e.keyCode;\n            }\n            this.which = e.which;\n            this.processed = false;\n            this.formatted = false;\n        },\n        setSelection: function setSelection(start, end, setReal) {\n            start = Math.max(start, 0);\n            end = Math.min(end, this.that.value.length);\n            this.selection = {\n                start: start,\n                end: end,\n                length: end - start\n            };\n            if (isUndefined(setReal) || setReal) {\n                setElementSelection(this.that, start, end);\n            }\n        },\n        setPosition: function setPosition(pos, setReal) {\n            this.setSelection(pos, pos, setReal);\n        },\n        getBeforeAfter: function getBeforeAfter() {\n            var value = this.value;\n            var left = value.substring(0, this.selection.start);\n            var right = value.substring(this.selection.end, value.length);\n\n            return [left, right];\n        },\n        getBeforeAfterStriped: function getBeforeAfterStriped() {\n            var settingsClone = this.settingsClone;\n\n            var _getBeforeAfter = this.getBeforeAfter(),\n                _getBeforeAfter2 = _slicedToArray(_getBeforeAfter, 2),\n                left = _getBeforeAfter2[0],\n                right = _getBeforeAfter2[1];\n\n            left = autoStrip(left, this.settingsClone);\n            right = autoStrip(right, this.settingsClone);\n            if (settingsClone.trailingNegative && !contains(left, '-')) {\n                left = '-' + left;\n                right = right === '-' ? '' : right;\n            }\n            settingsClone.trailingNegative = false;\n\n            return [left, right];\n        },\n\n\n        /**\r\n         * strip parts from excess characters and leading zeroes\r\n         */\n        normalizeParts: function normalizeParts(left, right) {\n            var settingsClone = this.settingsClone;\n\n            // prevents multiple leading zeros from being entered\n            left = autoStrip(left, settingsClone);\n\n            // if right is not empty and first character is not aDec,\n            right = autoStrip(right, settingsClone);\n            if (settingsClone.trailingNegative && !contains(left, '-')) {\n                left = '-' + left;\n                settingsClone.trailingNegative = false;\n            }\n            if ((left === '' || left === settingsClone.aNeg) && settingsClone.lZero === 'deny') {\n                if (right > '') {\n                    right = right.replace(/^0*(\\d)/, '$1');\n                }\n            }\n\n            // insert zero if has leading dot\n            this.newValue = left + right;\n            if (settingsClone.aDec) {\n                var m = this.newValue.match(new RegExp('^' + settingsClone.aNegRegAutoStrip + '\\\\' + settingsClone.aDec));\n                if (m) {\n                    left = left.replace(m[1], m[1] + '0');\n                    this.newValue = left + right;\n                }\n            }\n\n            return [left, right];\n        },\n\n\n        /**\r\n         * set part of number to value keeping position of cursor\r\n         */\n        setValueParts: function setValueParts(left, right, advent) {\n            var settingsClone = this.settingsClone;\n            var parts = this.normalizeParts(left, right);\n\n            var _autoCheck = autoCheck(this.newValue, settingsClone),\n                _autoCheck2 = _slicedToArray(_autoCheck, 2),\n                minTest = _autoCheck2[0],\n                maxTest = _autoCheck2[1];\n\n            var position = parts[0].length;\n            this.newValue = parts.join('');\n            if (minTest && maxTest) {\n                this.newValue = truncateDecimal(this.newValue, settingsClone, advent);\n                var testValue = contains(this.newValue, ',') ? this.newValue.replace(',', '.') : this.newValue;\n                if (testValue === '' || testValue === settingsClone.aNeg) {\n                    settingsClone.rawValue = '';\n                } else {\n                    settingsClone.rawValue = testValue;\n                }\n                if (position > this.newValue.length) {\n                    position = this.newValue.length;\n                }\n                this.value = this.newValue;\n                this.setPosition(position, false);\n                return true;\n            }\n            if (!minTest) {\n                this.$that.trigger('autoNumeric:minExceeded');\n            } else if (!maxTest) {\n                this.$that.trigger('autoNumeric:maxExceeded');\n            }\n\n            return false;\n        },\n\n\n        /**\r\n         * helper function for expandSelectionOnSign\r\n         * returns sign position of a formatted value\r\n         */\n        signPosition: function signPosition() {\n            var settingsClone = this.settingsClone;\n            var aSign = settingsClone.aSign;\n            var that = this.that;\n            if (aSign) {\n                var aSignLen = aSign.length;\n                if (settingsClone.pSign === 'p') {\n                    var hasNeg = settingsClone.aNeg && that.value && that.value.charAt(0) === settingsClone.aNeg;\n                    return hasNeg ? [1, aSignLen + 1] : [0, aSignLen];\n                }\n                var valueLen = that.value.length;\n                return [valueLen - aSignLen, valueLen];\n            }\n\n            return [1000, -1];\n        },\n\n\n        /**\r\n         * expands selection to cover whole sign\r\n         * prevents partial deletion/copying/overwriting of a sign\r\n         */\n        expandSelectionOnSign: function expandSelectionOnSign(setReal) {\n            var signPosition = this.signPosition();\n            var selection = this.selection;\n\n            // if selection catches something except sign and catches only space from sign\n            if (selection.start < signPosition[1] && selection.end > signPosition[0]) {\n                // then select without empty space\n                if ((selection.start < signPosition[0] || selection.end > signPosition[1]) && this.value.substring(Math.max(selection.start, signPosition[0]), Math.min(selection.end, signPosition[1])).match(/^\\s*$/)) {\n                    if (selection.start < signPosition[0]) {\n                        this.setSelection(selection.start, signPosition[0], setReal);\n                    } else {\n                        this.setSelection(signPosition[1], selection.end, setReal);\n                    }\n                } else {\n                    // else select with whole sign\n                    this.setSelection(Math.min(selection.start, signPosition[0]), Math.max(selection.end, signPosition[1]), setReal);\n                }\n            }\n        },\n\n\n        /**\r\n         * try to strip pasted value to digits\r\n         */\n        checkPaste: function checkPaste() {\n            if (!isUndefined(this.valuePartsBeforePaste)) {\n                var oldParts = this.valuePartsBeforePaste;\n\n                var _getBeforeAfter3 = this.getBeforeAfter(),\n                    _getBeforeAfter4 = _slicedToArray(_getBeforeAfter3, 2),\n                    left = _getBeforeAfter4[0],\n                    right = _getBeforeAfter4[1];\n\n                // try to strip pasted value first\n\n\n                delete this.valuePartsBeforePaste;\n                var modifiedLeftPart = left.substr(0, oldParts[0].length) + autoStrip(left.substr(oldParts[0].length), this.settingsClone);\n                if (!this.setValueParts(modifiedLeftPart, right, 'paste')) {\n                    this.value = oldParts.join('');\n                    this.setPosition(oldParts[0].length, false);\n                }\n            }\n        },\n\n\n        /**\r\n         * process pasting, cursor moving and skipping of not interesting keys\r\n         * if returns true, further processing is not performed\r\n         */\n        skipAlways: function skipAlways(e) {\n            var kdCode = this.kdCode;\n            var which = this.which;\n            var ctrlKey = this.ctrlKey;\n            var cmdKey = this.cmdKey;\n\n            // catch the ctrl up on ctrl-v\n            var shiftKey = this.shiftKey;\n            if ((ctrlKey || cmdKey) && e.type === 'keyup' && !isUndefined(this.valuePartsBeforePaste) || shiftKey && kdCode === keyCode.Insert) {\n                this.checkPaste();\n                return false;\n            }\n\n            // skip Fx keys, windows keys, other special keys\n            if (kdCode >= keyCode.F1 && kdCode <= keyCode.F12 || kdCode >= keyCode.Windows && kdCode <= keyCode.RightClick || kdCode >= keyCode.Tab && kdCode < keyCode.Space || kdCode < keyCode.Backspace && (which === 0 || which === kdCode) || kdCode === keyCode.NumLock || kdCode === keyCode.ScrollLock || kdCode === keyCode.Insert || kdCode === keyCode.Command) {\n                return true;\n            }\n\n            // if select all (a)\n            if ((ctrlKey || cmdKey) && kdCode === keyCode.a) {\n                if (this.settings.sNumber) {\n                    e.preventDefault();\n                    var valueLen = this.that.value.length;\n                    var aSignLen = this.settings.aSign.length;\n                    var negLen = !contains(this.that.value, '-') ? 0 : 1;\n                    var aSuffixLen = this.settings.aSuffix.length;\n                    var pSign = this.settings.pSign;\n                    var pNeg = this.settings.pNeg;\n\n                    var start = void 0;\n                    if (pSign === 's') {\n                        start = 0;\n                    } else {\n                        start = pNeg === 'l' && negLen === 1 && aSignLen > 0 ? aSignLen + 1 : aSignLen;\n                    }\n\n                    var end = void 0;\n                    if (pSign === 'p') {\n                        end = valueLen - aSuffixLen;\n                    } else {\n                        switch (pNeg) {\n                            case 'l':\n                                end = valueLen - (aSuffixLen + aSignLen);\n                                break;\n                            case 'r':\n                                end = aSignLen > 0 ? valueLen - (aSignLen + negLen + aSuffixLen) : valueLen - (aSignLen + aSuffixLen);\n                                break;\n                            default:\n                                end = valueLen - (aSignLen + aSuffixLen);\n                        }\n                    }\n\n                    setElementSelection(this.that, start, end);\n                }\n                return true;\n            }\n\n            // if copy (c)\n            if ((ctrlKey || cmdKey) && (kdCode === keyCode.c || kdCode === keyCode.v || kdCode === keyCode.x)) {\n                if (e.type === 'keydown') {\n                    this.expandSelectionOnSign();\n                }\n\n                // try to prevent wrong paste\n                if (kdCode === keyCode.v || kdCode === keyCode.Insert) {\n                    if (e.type === 'keydown' || e.type === 'keypress') {\n                        if (isUndefined(this.valuePartsBeforePaste)) {\n                            this.valuePartsBeforePaste = this.getBeforeAfter();\n                        }\n                    } else {\n                        this.checkPaste();\n                    }\n                }\n                return e.type === 'keydown' || e.type === 'keypress' || kdCode === keyCode.c;\n            }\n\n            if (ctrlKey || cmdKey) {\n                return true;\n            }\n\n            // jump over thousand separator\n            if (kdCode === keyCode.LeftArrow || kdCode === keyCode.RightArrow) {\n                var aSep = this.settingsClone.aSep;\n                var aDec = this.settingsClone.aDec;\n                var startJump = this.selection.start;\n                var value = this.that.value;\n                if (e.type === 'keydown' && !this.shiftKey) {\n                    if (kdCode === keyCode.LeftArrow && (value.charAt(startJump - 2) === aSep || value.charAt(startJump - 2) === aDec)) {\n                        this.setPosition(startJump - 1);\n                    } else if (kdCode === keyCode.RightArrow && (value.charAt(startJump + 1) === aSep || value.charAt(startJump + 1) === aDec)) {\n                        this.setPosition(startJump + 1);\n                    }\n                }\n                return true;\n            }\n\n            return kdCode >= keyCode.PageDown && kdCode <= keyCode.DownArrow;\n        },\n\n\n        /**\r\n         * process deletion of characters when the minus sign is to the right of the numeric characters\r\n         */\n        processTrailing: function processTrailing(_ref) {\n            var _ref2 = _slicedToArray(_ref, 2),\n                left = _ref2[0],\n                right = _ref2[1];\n\n            var settingsClone = this.settingsClone;\n            if (settingsClone.pSign === 'p' && settingsClone.pNeg === 's') {\n                if (this.kdCode === 8) {\n                    settingsClone.caretFix = Boolean(this.selection.start >= this.value.indexOf(settingsClone.aSuffix) && settingsClone.aSuffix !== '');\n                    if (this.value.charAt(this.selection.start - 1) === '-') {\n                        left = left.substring(1);\n                    } else if (this.selection.start <= this.value.length - settingsClone.aSuffix.length) {\n                        left = left.substring(0, left.length - 1);\n                    }\n                } else {\n                    settingsClone.caretFix = Boolean(this.selection.start >= this.value.indexOf(settingsClone.aSuffix) && settingsClone.aSuffix !== '');\n                    if (this.selection.start >= this.value.indexOf(settingsClone.aSign) + settingsClone.aSign.length) {\n                        right = right.substring(1, right.length);\n                    }\n                    if (contains(left, '-') && this.value.charAt(this.selection.start) === '-') {\n                        left = left.substring(1);\n                    }\n                }\n            }\n\n            if (settingsClone.pSign === 's' && settingsClone.pNeg === 'l') {\n                settingsClone.caretFix = Boolean(this.selection.start >= this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length);\n                if (this.kdCode === 8) {\n                    if (this.selection.start === this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length && contains(this.value, settingsClone.aNeg)) {\n                        left = left.substring(1);\n                    } else if (left !== '-' && (this.selection.start <= this.value.indexOf(settingsClone.aNeg) || !contains(this.value, settingsClone.aNeg))) {\n                        left = left.substring(0, left.length - 1);\n                    }\n                } else {\n                    if (left[0] === '-') {\n                        right = right.substring(1);\n                    }\n                    if (this.selection.start === this.value.indexOf(settingsClone.aNeg) && contains(this.value, settingsClone.aNeg)) {\n                        left = left.substring(1);\n                    }\n                }\n            }\n\n            if (settingsClone.pSign === 's' && settingsClone.pNeg === 'r') {\n                settingsClone.caretFix = Boolean(this.selection.start >= this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length);\n                if (this.kdCode === 8) {\n                    if (this.selection.start === this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length) {\n                        left = left.substring(1);\n                    } else if (left !== '-' && this.selection.start <= this.value.indexOf(settingsClone.aNeg) - settingsClone.aSign.length) {\n                        left = left.substring(0, left.length - 1);\n                    } else if (left !== '' && !contains(this.value, settingsClone.aNeg)) {\n                        left = left.substring(0, left.length - 1);\n                    }\n                } else {\n                    settingsClone.caretFix = Boolean(this.selection.start >= this.value.indexOf(settingsClone.aSign) && settingsClone.aSign !== '');\n                    if (this.selection.start === this.value.indexOf(settingsClone.aNeg)) {\n                        left = left.substring(1);\n                    }\n                    right = right.substring(1);\n                }\n            }\n\n            return [left, right];\n        },\n\n\n        /**\r\n         * process deletion of characters\r\n         * returns true if processing performed\r\n         */\n        processAlways: function processAlways() {\n            var settingsClone = this.settingsClone;\n            if (this.kdCode === keyCode.Backspace || this.kdCode === keyCode.Delete) {\n                var left = void 0;\n                var right = void 0;\n                if (!this.selection.length) {\n                    var _getBeforeAfterStripe = this.getBeforeAfterStriped();\n\n                    var _getBeforeAfterStripe2 = _slicedToArray(_getBeforeAfterStripe, 2);\n\n                    left = _getBeforeAfterStripe2[0];\n                    right = _getBeforeAfterStripe2[1];\n\n                    if (left === '' && right === '') {\n                        settingsClone.throwInput = false;\n                    }\n                    if ((settingsClone.pSign === 'p' && settingsClone.pNeg === 's' || settingsClone.pSign === 's' && (settingsClone.pNeg === 'l' || settingsClone.pNeg === 'r')) && contains(this.value, '-')) {\n                        var _processTrailing = this.processTrailing([left, right]);\n\n                        var _processTrailing2 = _slicedToArray(_processTrailing, 2);\n\n                        left = _processTrailing2[0];\n                        right = _processTrailing2[1];\n                    } else {\n                        if (this.kdCode === 8) {\n                            left = left.substring(0, left.length - 1);\n                        } else {\n                            right = right.substring(1, right.length);\n                        }\n                    }\n                    this.setValueParts(left, right);\n                } else {\n                    this.expandSelectionOnSign(false);\n\n                    var _getBeforeAfterStripe3 = this.getBeforeAfterStriped();\n\n                    var _getBeforeAfterStripe4 = _slicedToArray(_getBeforeAfterStripe3, 2);\n\n                    left = _getBeforeAfterStripe4[0];\n                    right = _getBeforeAfterStripe4[1];\n\n                    this.setValueParts(left, right);\n                }\n                return true;\n            }\n\n            return false;\n        },\n\n\n        /**\r\n         * process insertion of characters\r\n         * returns true if processing performed\r\n         */\n        processKeypress: function processKeypress() {\n            var settingsClone = this.settingsClone;\n            var cCode = String.fromCharCode(this.which);\n\n            var _getBeforeAfterStripe5 = this.getBeforeAfterStriped(),\n                _getBeforeAfterStripe6 = _slicedToArray(_getBeforeAfterStripe5, 2),\n                left = _getBeforeAfterStripe6[0],\n                right = _getBeforeAfterStripe6[1];\n\n            settingsClone.throwInput = true;\n\n            // start rules when the decimal character key is pressed always use numeric pad dot to insert decimal separator\n            // do not allow decimal character if no decimal part allowed\n            if (cCode === settingsClone.aDec || settingsClone.altDec && cCode === settingsClone.altDec || (cCode === '.' || cCode === ',') && this.kdCode === keyCode.DotNumpad) {\n                if (!settingsClone.mDec || !settingsClone.aDec) {\n                    return true;\n                }\n\n                // do not allow decimal character before aNeg character\n                if (settingsClone.aNeg && contains(right, settingsClone.aNeg)) {\n                    return true;\n                }\n\n                // do not allow decimal character if other decimal character present\n                if (contains(left, settingsClone.aDec)) {\n                    return true;\n                }\n                if (right.indexOf(settingsClone.aDec) > 0) {\n                    return true;\n                }\n                if (right.indexOf(settingsClone.aDec) === 0) {\n                    right = right.substr(1);\n                }\n                this.setValueParts(left + settingsClone.aDec, right, null);\n                return true;\n            }\n\n            // prevent minus if not allowed\n            if ((cCode === '-' || cCode === '+') && settingsClone.aNeg === '-') {\n                if (!settingsClone) {\n                    return true;\n                }\n\n                // caret is always after minus\n                if (settingsClone.pSign === 'p' && settingsClone.pNeg === 's' || settingsClone.pSign === 's' && settingsClone.pNeg !== 'p') {\n                    if (left === '' && contains(right, settingsClone.aNeg)) {\n                        left = settingsClone.aNeg;\n                        right = right.substring(1, right.length);\n                    }\n\n                    // change sign of number, remove part if should\n                    if (left.charAt(0) === '-' || contains(left, settingsClone.aNeg)) {\n                        left = left.substring(1, left.length);\n                    } else {\n                        left = cCode === '-' ? settingsClone.aNeg + left : left;\n                    }\n                } else {\n                    if (left === '' && contains(right, settingsClone.aNeg)) {\n                        left = settingsClone.aNeg;\n                        right = right.substring(1, right.length);\n                    }\n\n                    // change sign of number, remove part if should\n                    if (left.charAt(0) === settingsClone.aNeg) {\n                        left = left.substring(1, left.length);\n                    } else {\n                        left = cCode === '-' ? settingsClone.aNeg + left : left;\n                    }\n                }\n                this.setValueParts(left, right, null);\n                return true;\n            }\n\n            // if try to insert digit before minus\n            if (cCode >= '0' && cCode <= '9') {\n                if (settingsClone.aNeg && left === '' && contains(right, settingsClone.aNeg)) {\n                    left = settingsClone.aNeg;\n                    right = right.substring(1, right.length);\n                }\n                if (settingsClone.vMax <= 0 && settingsClone.vMin < settingsClone.vMax && !contains(this.value, settingsClone.aNeg) && cCode !== '0') {\n                    left = settingsClone.aNeg + left;\n                }\n                this.setValueParts(left + cCode, right, null);\n                return true;\n            }\n\n            // prevent any other character\n            settingsClone.throwInput = false;\n\n            return true;\n        },\n\n\n        /**\r\n         * formatting of just processed value with keeping of cursor position\r\n         */\n        formatQuick: function formatQuick(e) {\n            var _this = this;\n\n            var settingsClone = this.settingsClone;\n            var leftLength = this.value;\n            var kuCode = e.keyCode;\n\n            var _getBeforeAfterStripe7 = this.getBeforeAfterStriped(),\n                _getBeforeAfterStripe8 = _slicedToArray(_getBeforeAfterStripe7, 1),\n                left = _getBeforeAfterStripe8[0];\n\n            // no grouping separator and no currency sign\n\n\n            if ((settingsClone.aSep === '' || settingsClone.aSep !== '' && !contains(leftLength, settingsClone.aSep)) && (settingsClone.aSign === '' || settingsClone.aSign !== '' && !contains(leftLength, settingsClone.aSign))) {\n                var _leftLength$split = leftLength.split(settingsClone.aDec),\n                    _leftLength$split2 = _slicedToArray(_leftLength$split, 1),\n                    subParts = _leftLength$split2[0];\n\n                var nSign = '';\n                if (contains(subParts, '-')) {\n                    nSign = '-';\n                    subParts = subParts.replace('-', '');\n                    left = left.replace('-', '');\n                }\n\n                // strip leading zero on positive value if need\n                if (nSign === '' && subParts.length > settingsClone.mIntPos && left.charAt(0) === '0') {\n                    left = left.slice(1);\n                }\n\n                // strip leading zero on negative value if need\n                if (nSign === '-' && subParts.length > settingsClone.mIntNeg && left.charAt(0) === '0') {\n                    left = left.slice(1);\n                }\n                left = nSign + left;\n            }\n\n            var value = autoGroup(this.value, this.settingsClone);\n            var position = value.length;\n            if (value) {\n                // prepare regexp which searches for cursor position from unformatted left part\n                var leftAr = left.split('');\n\n                // fixes caret position with trailing minus sign\n                if ((settingsClone.pNeg === 's' || settingsClone.pSign === 's' && settingsClone.pNeg !== 'p') && leftAr[0] === '-' && settingsClone.aNeg !== '') {\n                    leftAr.shift();\n                    if (settingsClone.pSign === 's' && settingsClone.pNeg === 'l' && (kuCode === keyCode.Backspace || this.kdCode === keyCode.Backspace || kuCode === keyCode.Delete || this.kdCode === keyCode.Delete) && settingsClone.caretFix) {\n                        leftAr.push('-');\n                        settingsClone.caretFix = Boolean(e.type === 'keydown');\n                    }\n                    if (settingsClone.pSign === 'p' && settingsClone.pNeg === 's' && (kuCode === keyCode.Backspace || this.kdCode === keyCode.Backspace || kuCode === keyCode.Delete || this.kdCode === keyCode.Delete) && settingsClone.caretFix) {\n                        leftAr.push('-');\n                        settingsClone.caretFix = Boolean(e.type === 'keydown');\n                    }\n                    if (settingsClone.pSign === 's' && settingsClone.pNeg === 'r' && (kuCode === keyCode.Backspace || this.kdCode === keyCode.Backspace || kuCode === keyCode.Delete || this.kdCode === keyCode.Delete) && settingsClone.caretFix) {\n                        (function () {\n                            var signParts = settingsClone.aSign.split('');\n                            var escapeChr = ['\\\\', '^', '$', '.', '|', '?', '*', '+', '(', ')', '['];\n                            var escapedParts = [];\n                            $.each(signParts, function (i, miniParts) {\n                                miniParts = signParts[i];\n                                if (isInArray(miniParts, escapeChr)) {\n                                    escapedParts.push('\\\\' + miniParts);\n                                } else {\n                                    escapedParts.push(miniParts);\n                                }\n                            });\n                            if (kuCode === keyCode.Backspace || _this.kdCode === keyCode.Backspace) {\n                                escapedParts.push('-');\n                            }\n\n                            // pushing the escaped sign\n                            leftAr.push(escapedParts.join(''));\n                            settingsClone.caretFix = Boolean(e.type === 'keydown');\n                        })();\n                    }\n                }\n\n                for (var i = 0; i < leftAr.length; i++) {\n                    if (!leftAr[i].match('\\\\d')) {\n                        leftAr[i] = '\\\\' + leftAr[i];\n                    }\n                }\n\n                var leftReg = new RegExp('^.*?' + leftAr.join('.*?'));\n\n                // search cursor position in formatted value\n                var newLeft = value.match(leftReg);\n                if (newLeft) {\n                    position = newLeft[0].length;\n\n                    // if we are just before sign which is in prefix position\n                    if ((position === 0 && value.charAt(0) !== settingsClone.aNeg || position === 1 && value.charAt(0) === settingsClone.aNeg) && settingsClone.aSign && settingsClone.pSign === 'p') {\n                        // place caret after prefix sign\n                        position = this.settingsClone.aSign.length + (value.charAt(0) === '-' ? 1 : 0);\n                    }\n                } else {\n                    if (settingsClone.aSign && settingsClone.pSign === 's') {\n                        // if we could not find a place for cursor and have a sign as a suffix\n                        // place caret before suffix currency sign\n                        position -= settingsClone.aSign.length;\n                    }\n                    if (settingsClone.aSuffix) {\n                        // if we could not find a place for cursor and have a suffix\n                        // place caret before suffix\n                        position -= settingsClone.aSuffix.length;\n                    }\n                }\n            }\n            this.that.value = value;\n            this.setPosition(position);\n            this.formatted = true;\n        }\n    };\n\n    /**\r\n     * This function factorise the `getString()` and `getArray()` functions since they share quite a lot of code.\r\n     *\r\n     * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\r\n     * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\r\n     *\r\n     * It then loops through the string and un-formats the inputs with autoNumeric.\r\n     * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\r\n     * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" => please see option \"localeOutput\" for details\r\n     *\r\n     * @param {boolean} getArrayBehavior - If set to TRUE, then this function behave like `getArray()`, otherwise if set to FALSE, it behave like `getString()`\r\n     * @returns {*}\r\n     * @private\r\n     */\n    function _getStringOrArray() {\n        var getArrayBehavior = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        var that = arguments[1];\n\n        var $this = autoGet($(that));\n        var formIndex = $('form').index($this);\n        var allFormElements = $('form:eq(' + formIndex + ')')[0];\n        var aiIndex = [];\n\n        // all input index\n        var scIndex = [];\n\n        // successful control index\n        var rSubmitterTypes = /^(?:submit|button|image|reset|file)$/i;\n\n        // from jQuery serialize method\n        var rSubmittable = /^(?:input|select|textarea|keygen)/i;\n\n        // from jQuery serialize method\n        var rCheckableType = /^(?:checkbox|radio)$/i;\n        var rNonAutoNumericTypes = /^(?:button|checkbox|color|date|datetime|datetime-local|email|file|image|month|number|password|radio|range|reset|search|submit|time|url|week)/i;\n\n        var count = 0;\n\n        // index of successful elements\n        $.each(allFormElements, function (i, field) {\n            if (field.name !== '' && rSubmittable.test(field.localName) && !rSubmitterTypes.test(field.type) && !field.disabled && (field.checked || !rCheckableType.test(field.type))) {\n                scIndex.push(count);\n                count++;\n            } else {\n                scIndex.push(-1);\n            }\n        });\n\n        // index of all inputs tags except checkbox\n        count = 0;\n        $.each(allFormElements, function (i, field) {\n            if (field.localName === 'input' && (field.type === '' || field.type === 'text' || field.type === 'hidden' || field.type === 'tel')) {\n                aiIndex.push(count);\n                count++;\n            } else {\n                aiIndex.push(-1);\n                if (field.localName === 'input' && rNonAutoNumericTypes.test(field.type)) {\n                    count++;\n                }\n            }\n        });\n\n        if (getArrayBehavior) {\n            var formFields = $this.serializeArray();\n\n            $.each(formFields, function (i, field) {\n                var scElement = $.inArray(i, scIndex);\n\n                if (scElement > -1 && aiIndex[scElement] > -1) {\n                    var testInput = $('form:eq(' + formIndex + ') input:eq(' + aiIndex[scElement] + ')');\n                    var settings = testInput.data('autoNumeric');\n\n                    if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                        field.value = testInput.autoNumeric('get', settings.localeOutput).toString();\n                    }\n                }\n            });\n\n            return formFields;\n        } else {\n            var _ret2 = function () {\n                // getString() behavior\n                var formFields = $this.serialize();\n                var formParts = formFields.split('&');\n\n                $.each(formParts, function (i) {\n                    var _formParts$i$split = formParts[i].split('='),\n                        _formParts$i$split2 = _slicedToArray(_formParts$i$split, 2),\n                        inputName = _formParts$i$split2[0],\n                        inputValue = _formParts$i$split2[1];\n\n                    var scElement = $.inArray(i, scIndex);\n\n                    // If the current element is a valid element\n                    if (scElement > -1 && aiIndex[scElement] > -1) {\n                        var testInput = $('form:eq(' + formIndex + ') input:eq(' + aiIndex[scElement] + ')');\n                        var settings = testInput.data('autoNumeric');\n\n                        if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                            if (inputValue !== null) {\n                                var modifiedInputValue = testInput.autoNumeric('get', settings.localeOutput).toString();\n                                formParts[i] = inputName + '=' + modifiedInputValue;\n                            }\n                        }\n                    }\n                });\n\n                return {\n                    v: formParts.join('&')\n                };\n            }();\n\n            if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === \"object\") return _ret2.v;\n        }\n    }\n\n    /**\r\n     * Methods supported by autoNumeric\r\n     */\n    var methods = {\n        /**\r\n         * Method to initiate autoNumeric and attach the settings (options can be passed as a parameter)\r\n         * The options passed as a parameter is an object that contains the settings (ie. {aSep: \".\", aDec: \",\", aSign: '€ '})\r\n         *\r\n         * @example\r\n         * $(someSelector).autoNumeric('init');            // initiate autoNumeric with defaults\r\n         * $(someSelector).autoNumeric();                  // initiate autoNumeric with defaults\r\n         * $(someSelector).autoNumeric('init', {options}); // initiate autoNumeric with options\r\n         * $(someSelector).autoNumeric({options});         // initiate autoNumeric with options\r\n         */\n        init: function init(options) {\n            return this.each(function () {\n                var $this = $(this);\n\n                // attempt to grab HTML5 data, if they don't exist we'll get \"undefined\"\n                var tagData = $this.data();\n\n                // supported input type\n                var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n\n                // attempt to grab \"autoNumeric\" settings, if they don't exist returns \"undefined\"\n                var settings = $this.data('autoNumeric');\n\n                // If we couldn't grab settings, create them from defaults and passed options\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                    settings = $.extend({}, $.fn.autoNumeric.defaults, tagData, options, {\n                        onOff: false,\n                        runOnce: false,\n                        rawValue: '',\n                        trailingNegative: false,\n                        caretFix: false,\n                        throwInput: true,\n                        strip: true,\n                        tagList: ['b', 'caption', 'cite', 'code', 'const', 'dd', 'del', 'div', 'dfn', 'dt', 'em', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ins', 'kdb', 'label', 'li', 'option', 'output', 'p', 'q', 's', 'sample', 'span', 'strong', 'td', 'th', 'u']\n                    });\n\n                    // Merge defaults, tagData and options\n                    if (settings.aDec === settings.aSep) {\n                        throwError('autoNumeric will not function properly when the decimal character aDec [' + settings.aDec + '] and the thousand separator aSep [' + settings.aSep + '] are the same character', settings.debug);\n                    }\n\n                    $.each(settings, function (key, value) {\n                        if (value === 'true' || value === 'false') {\n                            settings[key] = Boolean(value === 'true');\n                        }\n                    });\n\n                    // Save our new settings\n                    $this.data('autoNumeric', settings);\n                } else {\n                    return this;\n                }\n\n                // original settings saved for use when eDec, scaleDivisor & nSep options are being used\n                settings = originalSettings(settings);\n                var holder = getHolder($this, settings);\n\n                settings.mDec = settings.scaleDivisor && settings.scaleDecimal ? settings.scaleDecimal : settings.mDec;\n\n                // checks for non-supported input types\n                if (!$input && $this.prop('tagName').toLowerCase() === 'input') {\n                    throwError('The input type \"' + $this.prop('type') + '\" is not supported by autoNumeric', settings.debug);\n                }\n\n                // checks for non-supported tags\n                if (!isInArray($this.prop('tagName').toLowerCase(), settings.tagList) && $this.prop('tagName').toLowerCase() !== 'input') {\n                    throwError('The <' + $this.prop('tagName').toLowerCase() + '> tag is not supported by autoNumeric', settings.debug);\n                }\n\n                //TODO Replace the two next tests with a `validateOptions()` function\n                // checks if the decimal and thousand are characters are the same\n                if (settings.aDec === settings.aSep) {\n                    throwError('autoNumeric will not function properly when the decimal character aDec [' + settings.aDec + '] and the thousand separator aSep [' + settings.aSep + '] are the same character', settings.debug);\n                }\n\n                // checks the extended decimal places \"eDec\" is greater than the normal decimal places \"mDec\"\n                if (settings.eDec < settings.mDec && settings.eDec !== null) {\n                    throwError('autoNumeric will not function properly when the extended decimal places eDec [' + settings.eDec + '] is greater than the mDec [' + settings.mDec + '] value', settings.debug);\n                }\n\n                // routine to format default value on page load\n                if (settings.runOnce === false && settings.aForm) {\n                    var setValue = true;\n                    if ($input) {\n                        var currentValue = $this.val();\n\n                        /*\r\n                         * If the input value has been set by the dev, but not directly as an attribute in the html, then it takes\r\n                         * precedence and should get formatted on init (if that this input value is a valid number and that the\r\n                         * developer wants it formatted on init (cf. `settings.aForm`)). Note; this is true whatever the developer\r\n                         * has set for `data-an-default` in the html (asp.net users).\r\n                         *\r\n                         * In other words : if `anDefault` is not null, it means the developer is trying to prevent postback problems.\r\n                         * But if `input.value` is set to a number, and `$this.attr('value')` is not set, then it means the dev has\r\n                         * changed the input value, and then it means we should not overwrite his own decision to do so.\r\n                         * Hence, if `anDefault` is not null, but `input.value` is a number and `$this.attr('value')` is not set,\r\n                         * we should ignore `anDefault` altogether.\r\n                         */\n                        if (settings.aForm && currentValue !== '' && isUndefinedOrNullOrEmpty($this.attr('value'))) {\n                            // Check if the `value` is valid or not\n                            var testedCurrentValue = parseFloat(currentValue.replace(',', '.')); //TODO Replace whatever locale character is used by a '.', and not only the comma ','\n                            if (!isNaN(testedCurrentValue) && Infinity !== testedCurrentValue) {\n                                $this.autoNumeric('set', testedCurrentValue);\n                                setValue = false;\n                            } else {\n                                // If not, inform the developer that nothing usable has been provided\n                                throwError('The value [' + currentValue + '] used in the input is not a valid value autoNumeric can work with.', false);\n                            }\n                        } else {\n                            /* Checks for :\r\n                             * - page reload from back button, and\r\n                             * - ASP.net form post back\r\n                             *      The following HTML data attribute is REQUIRED (data-an-default=\"same value as the value attribute\")\r\n                             *      example: <asp:TextBox runat=\"server\" id=\"someID\" text=\"1234.56\" data-an-default=\"1234.56\">\r\n                             */\n                            //TODO Replace whatever locale character is used by a '.', and not only the comma ',', based on the locale used by the user\n                            if (settings.anDefault !== null && settings.anDefault.toString() !== currentValue || settings.anDefault === null && currentValue !== '' && currentValue !== $this.attr('value') || currentValue !== '' && $this.attr('type') === 'hidden' && !$.isNumeric(currentValue.replace(',', '.'))) {\n                                if (settings.eDec !== null && settings.aStor) {\n                                    settings.rawValue = autoSave($this, settings, 'get');\n                                }\n                                if (settings.scaleDivisor && settings.aStor) {\n                                    settings.rawValue = autoSave($this, settings, 'get');\n                                }\n                                if (!settings.aStor) {\n                                    var toStrip = void 0;\n                                    if (settings.nBracket !== null && settings.aNeg !== '') {\n                                        settings.onOff = true;\n                                        toStrip = negativeBracket(currentValue, settings);\n                                    } else {\n                                        toStrip = currentValue;\n                                    }\n                                    settings.rawValue = (settings.pNeg === 's' || settings.pSign === 's' && settings.pNeg !== 'p') && settings.aNeg !== '' && contains(currentValue, '-') ? '-' + autoStrip(toStrip, settings) : autoStrip(toStrip, settings);\n                                }\n                                setValue = false;\n                            }\n                        }\n\n                        if (currentValue === '') {\n                            switch (settings.wEmpty) {\n                                case 'focus':\n                                    setValue = false;\n                                    break;\n                                case 'always':\n                                    $this.val(settings.aSign);\n                                    setValue = false;\n                                    break;\n                                case 'zero':\n                                    $this.autoNumeric('set', '0');\n                                    setValue = false;\n                                    break;\n                                default:\n                                //\n                            }\n                        } else if (setValue && currentValue === $this.attr('value')) {\n                            $this.autoNumeric('set', currentValue);\n                        }\n                    }\n\n                    if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList) && $this.text() !== '') {\n                        if (settings.anDefault !== null) {\n                            if (settings.anDefault === $this.text()) {\n                                $this.autoNumeric('set', $this.text());\n                            }\n                        } else {\n                            $this.autoNumeric('set', $this.text());\n                        }\n                    }\n                }\n\n                settings.runOnce = true;\n\n                //TODO Extract the event listeners to another function\n                // input types supported \"text\", \"hidden\", \"tel\" and no type\n                if ($input) {\n                    $this.on('focusin.autoNumeric', function () {\n                        holder = getHolder($this);\n                        var $settings = holder.settingsClone;\n                        $settings.onOff = true;\n                        if ($settings.nBracket !== null && $settings.aNeg !== '') {\n                            $this.val(negativeBracket($this.val(), $settings));\n                        }\n                        var result = void 0;\n                        if ($settings.eDec) {\n                            $settings.mDec = $settings.eDec;\n                            $this.autoNumeric('set', $settings.rawValue);\n                        } else if ($settings.scaleDivisor) {\n                            $settings.mDec = $settings.oDec;\n                            $this.autoNumeric('set', $settings.rawValue);\n                        } else if ($settings.nSep) {\n                            $settings.aSep = '';\n                            $settings.aSign = '';\n                            $settings.aSuffix = '';\n                            $this.autoNumeric('set', $settings.rawValue);\n                        } else if ((result = autoStrip($this.val(), $settings)) !== $settings.rawValue) {\n                            $this.autoNumeric('set', result);\n                        }\n                        holder.inVal = $this.val();\n                        holder.lastVal = holder.inVal;\n                        var onEmpty = checkEmpty(holder.inVal, $settings, true);\n                        if (onEmpty !== null && onEmpty !== '' && $settings.wEmpty === 'focus') {\n                            $this.val(onEmpty);\n                        }\n                    });\n\n                    $this.on('keydown.autoNumeric', function (e) {\n                        holder = getHolder($this);\n                        if (holder.that.readOnly) {\n                            holder.processed = true;\n                            return true;\n                        }\n\n                        /* // The code below allows the \"enter\" keydown to throw a change() event\r\n                        if (e.keyCode === keyCode.Enter && holder.inVal !== $this.val()) {\r\n                            $this.change();\r\n                            holder.inVal = $this.val();\r\n                        } */\n                        holder.init(e);\n                        if (holder.skipAlways(e)) {\n                            holder.processed = true;\n                            return true;\n                        }\n                        if (holder.processAlways()) {\n                            holder.processed = true;\n                            holder.formatQuick(e);\n                            var _currentValue = $this.val();\n                            if (_currentValue !== holder.lastVal && holder.settingsClone.throwInput) {\n                                // throws input event in deletion character\n                                $this.trigger('input');\n                            }\n                            holder.lastVal = _currentValue;\n                            holder.settingsClone.throwInput = true;\n                            e.preventDefault();\n                            return false;\n                        }\n                        holder.formatted = false;\n                        return true;\n                    });\n\n                    $this.on('keypress.autoNumeric', function (e) {\n                        // Firefox fix for Shift && insert paste event\n                        if (e.shiftKey && e.keyCode === keyCode.Insert) {\n                            return;\n                        }\n                        holder = getHolder($this);\n                        var processed = holder.processed;\n                        holder.init(e);\n                        if (holder.skipAlways(e)) {\n                            return true;\n                        }\n                        if (processed) {\n                            e.preventDefault();\n                            return false;\n                        }\n                        if (holder.processAlways() || holder.processKeypress()) {\n                            holder.formatQuick(e);\n                            var _currentValue2 = $this.val();\n                            if (_currentValue2 !== holder.lastVal && holder.settingsClone.throwInput) {\n                                // throws input event on adding character\n                                $this.trigger('input');\n                            }\n                            holder.lastVal = _currentValue2;\n                            holder.settingsClone.throwInput = true;\n                            e.preventDefault();\n                            return;\n                        }\n                        holder.formatted = false;\n                    });\n\n                    $this.on('keyup.autoNumeric', function (e) {\n                        holder = getHolder($this);\n                        holder.init(e);\n                        var skip = holder.skipAlways(e);\n                        var tab = holder.kdCode;\n                        holder.kdCode = 0;\n                        delete holder.valuePartsBeforePaste;\n\n                        // added to properly place the caret when only the currency sign is present\n                        if ($this[0].value === holder.settingsClone.aSign) {\n                            if (holder.settingsClone.pSign === 's') {\n                                setElementSelection(this, 0, 0);\n                            } else {\n                                setElementSelection(this, holder.settingsClone.aSign.length, holder.settingsClone.aSign.length);\n                            }\n                        } else if (tab === keyCode.Tab) {\n                            setElementSelection(this, 0, $this.val().length);\n                        }\n                        if ($this[0].value === holder.settingsClone.aSuffix) {\n                            setElementSelection(this, 0, 0);\n                        }\n                        if (holder.settingsClone.rawValue === '' && holder.settingsClone.aSign !== '' && holder.settingsClone.aSuffix !== '') {\n                            setElementSelection(this, 0, 0);\n                        }\n\n                        // saves the extended decimal to preserve the data when navigating away from the page\n                        if (holder.settingsClone.eDec !== null && holder.settingsClone.aStor) {\n                            autoSave($this, settings, 'set');\n                        }\n                        if (skip) {\n                            return true;\n                        }\n                        if (this.value === '') {\n                            return true;\n                        }\n                        if (!holder.formatted) {\n                            holder.formatQuick(e);\n                        }\n                    });\n\n                    $this.on('focusout.autoNumeric', function () {\n                        holder = getHolder($this);\n                        var value = $this.val();\n                        var origValue = value;\n                        var $settings = holder.settingsClone;\n                        $settings.onOff = false;\n                        if ($settings.aStor) {\n                            autoSave($this, $settings, 'set');\n                        }\n                        if ($settings.nSep === true) {\n                            $settings.aSep = $settings.oSep;\n                            $settings.aSign = $settings.oSign;\n                            $settings.aSuffix = $settings.oSuffix;\n                        }\n                        if ($settings.eDec !== null) {\n                            $settings.mDec = $settings.oDec;\n                            $settings.aPad = $settings.oPad;\n                            $settings.nBracket = $settings.oBracket;\n                        }\n                        value = autoStrip(value, $settings);\n                        if (value !== '') {\n                            if ($settings.trailingNegative) {\n                                value = '-' + value;\n                                $settings.trailingNegative = false;\n                            }\n\n                            var _autoCheck3 = autoCheck(value, $settings),\n                                _autoCheck4 = _slicedToArray(_autoCheck3, 2),\n                                minTest = _autoCheck4[0],\n                                maxTest = _autoCheck4[1];\n\n                            if (checkEmpty(value, $settings) === null && minTest && maxTest) {\n                                value = fixNumber(value, $settings.aDec, $settings.aNeg);\n                                $settings.rawValue = value;\n                                if ($settings.scaleDivisor) {\n                                    value = value / $settings.scaleDivisor;\n                                    value = value.toString();\n                                }\n                                $settings.mDec = $settings.scaleDivisor && $settings.scaleDecimal ? +$settings.scaleDecimal : $settings.mDec;\n                                value = autoRound(value, $settings);\n                                value = presentNumber(value, $settings);\n                            } else {\n                                if (!minTest) {\n                                    $this.trigger('autoNumeric:minExceeded');\n                                }\n                                if (!maxTest) {\n                                    $this.trigger('autoNumeric:maxExceeded');\n                                }\n                                value = $settings.rawValue;\n                            }\n                        } else {\n                            if ($settings.wEmpty === 'zero') {\n                                $settings.rawValue = '0';\n                                value = autoRound('0', $settings);\n                            } else {\n                                $settings.rawValue = '';\n                            }\n                        }\n                        var groupedValue = checkEmpty(value, $settings, false);\n                        if (groupedValue === null) {\n                            groupedValue = autoGroup(value, $settings);\n                        }\n                        if (groupedValue !== origValue) {\n                            groupedValue = $settings.scaleSymbol ? groupedValue + $settings.scaleSymbol : groupedValue;\n                            $this.val(groupedValue);\n                        }\n                        if (groupedValue !== holder.inVal) {\n                            $this.change();\n                            delete holder.inVal;\n                        }\n                    });\n\n                    $this.on('paste', function (e) {\n                        //FIXME After a paste, the caret is put on the far right of the input, it should be set to something like `newCaretPosition = oldCaretPosition + pasteText.length;`, while taking into account the thousand separators and the decimal character\n                        e.preventDefault();\n                        holder = getHolder($this);\n                        function prepare(text) {\n                            return autoStrip(text, holder.settingsClone).replace(holder.settingsClone.aDec, '.');\n                        }\n\n                        function isValid(text) {\n                            return text !== '' && !isNaN(text);\n                        }\n\n                        var oldRawValue = $this.autoNumeric('get');\n                        var currentValue = this.value || '';\n                        var selectionStart = this.selectionStart || 0;\n                        var selectionEnd = this.selectionEnd || 0;\n                        var prefix = currentValue.substring(0, selectionStart);\n                        var suffix = currentValue.substring(selectionEnd, currentValue.length);\n                        var pastedText = prepare(e.originalEvent.clipboardData.getData('text/plain'));\n                        if (isValid(pastedText)) {\n                            var newValue = prepare(prefix + Number(pastedText).valueOf() + suffix);\n                            if (isValid(newValue) && Number(oldRawValue).valueOf() !== Number(newValue).valueOf()) {\n                                $this.autoNumeric('set', newValue);\n                                $this.trigger('input');\n                            }\n                        } else {\n                            this.selectionStart = selectionEnd;\n                        }\n                    });\n\n                    $this.closest('form').on('submit.autoNumeric', function () {\n                        holder = getHolder($this);\n                        if (holder) {\n                            var $settings = holder.settingsClone;\n                            if ($settings.unSetOnSubmit) {\n                                $this.val($settings.rawValue);\n                            }\n                        }\n                    });\n                }\n            });\n        },\n\n\n        /**\r\n         * method to remove settings and stop autoNumeric() - does not remove the formatting\r\n         * $(someSelector).autoNumeric(\"destroy\"); // destroys autoNumeric\r\n         * no parameters accepted\r\n         */\n        destroy: function destroy() {\n            return $(this).each(function () {\n                var $this = autoGet($(this));\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    $this.val('');\n                    autoSave($this, settings, 'wipe');\n                    $this.removeData('autoNumeric');\n                    $this.off('.autoNumeric');\n                }\n            });\n        },\n\n\n        /**\r\n         * method to clear the value and sessionStorage or cookie depending on browser supports\r\n         * $(someSelector).autoNumeric(\"wipe\"); // removes session storage and cookies from memory\r\n         * no parameters accepted\r\n         */\n        wipe: function wipe() {\n            return $(this).each(function () {\n                var $this = autoGet($(this));\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    $this.val('');\n                    settings.rawValue = '';\n                    autoSave($this, settings, 'wipe');\n                }\n            });\n        },\n\n\n        /**\r\n         * Method that updates the autoNumeric settings\r\n         * It can be called multiple times if needed\r\n         * The options passed as a parameter is an object that contains the settings (ie. {aSep: \".\", aDec: \",\", aSign: '€ '})\r\n         *\r\n         * @usage $(someSelector).autoNumeric(\"update\", {options}); // updates the settings\r\n         */\n        update: function update(options) {\n            return $(this).each(function () {\n                var $this = autoGet($(this));\n                var settings = $this.data('autoNumeric');\n\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                    throwError('Initializing autoNumeric is required prior to calling the \"update\" method', true);\n                }\n                var strip = $this.autoNumeric('get');\n                settings = $.extend(settings, options);\n\n                if (settings.scaleDivisor) {\n                    settings.mDec = settings.scaleDecimal ? settings.scaleDecimal : settings.mDec;\n                }\n                settings = originalSettings(settings);\n                getHolder($this, settings, true);\n\n                if (settings.aDec === settings.aSep) {\n                    throwError('autoNumeric will not function properly when the decimal character aDec: \"' + settings.aDec + '\" and thousand separator aSep: \"' + settings.aSep + '\" are the same character', settings.debug);\n                }\n                $this.data('autoNumeric', settings);\n\n                if ($this.val() !== '' || $this.text() !== '') {\n                    return $this.autoNumeric('set', strip);\n                }\n            });\n        },\n\n\n        /**\r\n         * Method to format the value passed as a parameter.\r\n         * $(someSelector).autoNumeric('set', 'value'); // formats the value being passed as the second parameter\r\n         * If the value is passed as a string, it can be an integer '1234' or a double '1234.56789'\r\n         * and must contain only numbers and one decimal (period) character\r\n         */\n        set: function set(valueIn) {\n            return $(this).each(function () {\n                if (valueIn === null || isUndefined(valueIn)) {\n                    return;\n                }\n                var $this = autoGet($(this));\n                var settings = $this.data('autoNumeric');\n                var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n                var value = valueIn.toString();\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                    throwError('Initializing autoNumeric is required prior to calling the \"set\" method', true);\n                }\n\n                // allows locale decimal separator to be a comma - no thousand separator allowed\n                value = fromLocale(value);\n\n                // Throws an error if the value being set is not numeric\n                if (!$.isNumeric(Number(value))) {\n                    throwError('The value \"' + value + '\" being \"set\" is not numeric and has caused a error to be thrown', settings.debug);\n                    return $this.val('');\n                }\n\n                if (value !== '') {\n                    var _autoCheck5 = autoCheck(value, settings),\n                        _autoCheck6 = _slicedToArray(_autoCheck5, 2),\n                        minTest = _autoCheck6[0],\n                        maxTest = _autoCheck6[1];\n\n                    if (minTest && maxTest) {\n                        if ($input && (settings.eDec || settings.scaleDivisor)) {\n                            settings.rawValue = value;\n                        }\n\n                        // checks if the value falls within the min max range\n                        if ($input || isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                            if (settings.scaleDivisor && !settings.onOff) {\n                                value = value / settings.scaleDivisor;\n                                value = value.toString();\n                                settings.mDec = settings.scaleDecimal ? settings.scaleDecimal : settings.mDec;\n                            }\n                            value = autoRound(value, settings);\n                            if (settings.eDec === null && settings.scaleDivisor === null) {\n                                settings.rawValue = value;\n                            }\n                            value = presentNumber(value, settings);\n                            value = autoGroup(value, settings);\n                        }\n                        if (settings.aStor && (settings.eDec || settings.scaleDivisor)) {\n                            autoSave($this, settings, 'set');\n                        }\n                    } else {\n                        settings.rawValue = '';\n                        autoSave($this, settings, 'wipe');\n                        var attemptedValue = value;\n                        value = '';\n                        if (!minTest) {\n                            $this.trigger('autoNumeric:minExceeded');\n                        }\n                        if (!maxTest) {\n                            $this.trigger('autoNumeric:maxExceeded');\n                        }\n                        throwError('The value [' + attemptedValue + '] being set falls outside the vMin [' + settings.vMin + '] and vMax [' + settings.vMax + '] settings for this element', settings.debug);\n                        return $this.val('');\n                    }\n                } else {\n                    return $this.val('');\n                }\n\n                if (!settings.onOff && settings.scaleSymbol) {\n                    value = value + settings.scaleSymbol;\n                }\n                if ($input) {\n                    return $this.val(value);\n                }\n                if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                    return $this.text(value);\n                }\n\n                return false;\n            });\n        },\n\n\n        /**\r\n         * method to un-format inputs - handy to use right before form submission\r\n         * $(someSelector).autoNumeric('unSet'); // no parameter accepted\r\n         * by defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\r\n         * locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" => please see option \"localeOutput\" for details\r\n         */\n        unSet: function unSet() {\n            return $(this).each(function () {\n                var $this = autoGet($(this));\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    settings.onOff = true;\n                    $this.val($this.autoNumeric('get'));\n                }\n            });\n        },\n\n\n        /**\r\n         * method to re-format inputs - handy to use right after form submission\r\n         * $(someSelector).autoNumeric('reSet'); // no parameters accepted\r\n         * this is called after the 'unSet' method to reformat the input\r\n         */\n        reSet: function reSet() {\n            return $(this).each(function () {\n                var $this = autoGet($(this));\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    $this.autoNumeric('set', $this.val());\n                }\n            });\n        },\n\n\n        /**\r\n         * method to get the unformatted that accepts up to one parameter\r\n         * $(someSelector).autoNumeric('get'); no parameter supported\r\n         * by defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\r\n         * locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" => please see option \"localeOutput\" for details\r\n         */\n        get: function get() {\n            var $this = autoGet($(this));\n            var settings = $this.data('autoNumeric');\n            var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n            var value = '';\n            if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                throwError('Initializing autoNumeric is required prior to calling the \"get\" method', true);\n            }\n\n            // determine the element type then use .eq(0) selector to grab the value of the first element in selector\n            if ($input) {\n                value = $this.eq(0).val();\n            } else if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                value = $this.eq(0).text();\n            } else {\n                throwError('The \"<' + $this.prop('tagName').toLowerCase() + '>\" tag is not supported by autoNumeric', settings.debug);\n            }\n\n            if (settings.eDec || settings.scaleDivisor) {\n                value = settings.rawValue;\n            } else {\n                if (!(/\\d/.test(value) || Number(value) === 0) && settings.wEmpty === 'focus') {\n                    return '';\n                }\n                if (value !== '' && settings.nBracket !== null) {\n                    settings.onOff = true;\n                    value = negativeBracket(value, settings);\n                }\n                if (settings.runOnce || settings.aForm === false) {\n                    value = autoStrip(value, settings);\n                }\n                value = fixNumber(value, settings.aDec, settings.aNeg);\n            }\n\n            if (Number(value) === 0 && settings.lZero !== 'keep') {\n                value = '0';\n            }\n            if (settings.localeOutput) {\n                value = toLocale(value, settings.localeOutput);\n            }\n\n            // returned Numeric String\n            // TODO Shouldn't we return `Number(value)` since the goal of `get` is to get the raw javascript value?\n            return value;\n        },\n\n\n        /**\r\n         * Return the current formatted value of the autoNumeric element.\r\n         * @usage aNInput.autoNumeric('getFormatted'))\r\n         *\r\n         * @returns {string}\r\n         */\n        getFormatted: function getFormatted() {\n            // Make sure `this[0]` exists as well as `.value` before trying to access that property\n            if (!isArray(this) || this.length !== 1 || !this[0].hasOwnProperty('value')) {\n                throwError('Unable to get the formatted string from the element.');\n            }\n\n            return this[0].value;\n        },\n\n\n        /**\r\n         * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\r\n         *\r\n         * It then loops through the string and un-formats the inputs with autoNumeric.\r\n         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\r\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" => please see option \"localeOutput\" for details\r\n         */\n        getString: function getString() {\n            return _getStringOrArray(false, this);\n        },\n\n\n        /**\r\n         * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\r\n         *\r\n         * It then loops through the string and un-formats the inputs with autoNumeric.\r\n         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\r\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" => please see option \"localeOutput\" for details\r\n         */\n        getArray: function getArray() {\n            return _getStringOrArray(true, this);\n        },\n\n\n        /**\r\n         * The 'getSettings' function returns the object with autoNumeric settings for those who need to look under the hood\r\n         * $(someSelector).autoNumeric('getSettings'); // no parameters accepted\r\n         * $(someSelector).autoNumeric('getSettings').aDec; // return the aDec setting as a string - ant valid setting can be used\r\n         */\n        getSettings: function getSettings() {\n            var $this = autoGet($(this));\n\n            return $this.eq(0).data('autoNumeric');\n        }\n    };\n\n    /**\r\n     * autoNumeric function\r\n     */\n    $.fn.autoNumeric = function (method) {\n        if (methods[method]) {\n            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                args[_key - 1] = arguments[_key];\n            }\n\n            return methods[method].apply(this, args);\n        }\n\n        if ((typeof method === 'undefined' ? 'undefined' : _typeof(method)) === 'object' || !method) {\n            // The options have been passed directly, without using a named method\n            //TODO First validate the options passed as an argument, before using `init`\n            return methods.init.apply(this, [method]);\n        }\n\n        throwError('Method \"' + method + '\" is not supported by autoNumeric', true);\n    };\n\n    /*\r\n     * Defaults are public - these can be overridden by the following:\r\n     * HTML5 data attributes\r\n     * Options passed by the 'init' or 'update' methods\r\n     * Use jQuery's `$.extend` method for global changes - also a great way to pass ASP.NET current culture settings\r\n     */\n    $.fn.autoNumeric.defaults = {\n        /* allowed thousand separator characters\r\n         * comma = \",\"\r\n         * period \"full stop\" = \".\"\r\n         * apostrophe is escaped = \"\\\"\"\r\n         * space = \" \"\r\n         * none = \"\"\r\n         * NOTE: do not use numeric characters\r\n         */\n        aSep: ',',\n\n        /* When true => removes the thousand seperator, currency symbol & suffix \"focusin\"\r\n         * example if the input value \"$ 1,999.88 suffix\"\r\n         * on \"focusin\" it becomes \"1999.88\" and back to \"$ 1,999.88 suffix\" on focus out.\r\n         */\n        nSep: false,\n\n        /* digital grouping for the thousand separator used in Format\r\n         * dGroup: \"2\", results in 99,99,99,999 India's lakhs\r\n         * dGroup: \"2s\", results in 99,999,99,99,999 India's lakhs scaled\r\n         * dGroup: \"3\", results in 999,999,999 default\r\n         * dGroup: \"4\", results in 9999,9999,9999 used in some Asian countries\r\n         */\n        dGroup: '3',\n\n        /* allowed decimal separator characters\r\n         * period \"full stop\" = \".\"\r\n         * comma = \",\"\r\n         */\n        aDec: '.',\n\n        /* allow to declare alternative decimal separator which is automatically replaced by aDec\r\n         * developed for countries the use a comma \",\" as the decimal character\r\n         * and have keyboards\\numeric pads that have a period 'full stop' as the decimal characters (Spain is an example)\r\n         */\n        altDec: null,\n\n        /* aSign = allowed currency symbol\r\n         * Must be in quotes aSign: \"$\"\r\n         * space to the right of the currency symbol aSign: '$ '\r\n         * space to the left of the currency symbol aSign: ' $'\r\n         */\n        aSign: '',\n\n        /* pSign = placement of currency sign as a p=prefix or s=suffix\r\n         * for prefix pSign: \"p\" (default)\r\n         * for suffix pSign: \"s\"\r\n         */\n        pSign: 'p',\n\n        /* placement of negative sign relative to the aSign option l=left, r=right, p=prefix & s=suffix\r\n         * -1,234.56  => default no options required\r\n         * -$1,234.56 => {aSign: \"$\"}\r\n         * $-1,234.56 => {aSign: \"$\", pNeg: \"r\"}\r\n         * -1,234.56$ => {aSign: \"$\", pSign: \"s\", pNeg: \"p\"}\r\n         * 1,234.56-  => {pNeg: \"s\"}\r\n         * $1,234.56- => {aSign: \"$\", pNeg: \"s\"}\r\n         * 1,234.56-$ => {aSign: \"$\", pSign: \"s\"}\r\n         * 1,234.56$- => {aSign: \"$\", pSign: \"s\", pNeg: \"r\"}\r\n         */\n        pNeg: 'l',\n\n        /* Additional suffix\r\n         * Must be in quotes aSuffix: 'gross', a space is allowed aSuffix: ' dollars'\r\n         * Numeric characters and negative sign not allowed'\r\n         */\n        aSuffix: '',\n\n        /* override min max limits'\r\n         * oLimits: \"ceiling\" adheres to vMax and ignores vMin settings\r\n         * oLimits: \"floor\" adheres to vMin and ignores vMax settings\r\n         * oLimits: \"ignore\" ignores both vMin & vMax\r\n         */\n        oLimits: null,\n\n        /* maximum possible value\r\n         * value must be enclosed in quotes and use the period for the decimal point\r\n         * value must be larger than vMin\r\n         */\n        vMax: '9999999999999.99',\n\n        /* minimum possible value\r\n         * value must be enclosed in quotes and use the period for the decimal point\r\n         * value must be smaller than vMax\r\n         */\n        vMin: '-9999999999999.99',\n\n        /* Maximum number of decimal places = used to override decimal places set by the vMin & vMax values\r\n         * value must be enclosed in quotes example mDec: \"3\",\r\n         */\n        mDec: null,\n\n        /* Expanded decimal places visible when input has focus - example:\r\n         * {eDec: \"5\"} and the default 2 decimal places with focus \"1,000.12345\" without focus \"1,000.12\" the results depends on the rounding method used\r\n         * the \"get\" method returns the extended decimal places\r\n         */\n        eDec: null,\n\n        /* The next three options (scaleDivisor, scaleDecimal & scaleSymbol) handle scaling of the input when the input does not have focus\r\n         * Please note that the non-scaled value is held in data and it is advised that you use the \"aStore\" option to ensure retaining the value         * [\"divisor\", \"decimal places\", \"symbol\"]\r\n         * Example: with the following options set {scaleDivisor: '1000', scaleDecimal: '1', scaleSymbol: ' K'}\r\n         * Example: focusin value \"1,111.11\" focusout value \"1.1 K\"\r\n         */\n\n        /* scaleDivisor devides the on focus value and places the result in the input on focusout\r\n         * example {scaleDivisor: '1000'} or <input data-scale-divisor=\"1000\">\r\n         * the divisor value - does not need to be whole number but please understand that Javascript has limited accuracy in math\r\n         * the \"get\" method returns the full value.\r\n         */\n        scaleDivisor: null,\n\n        /*\r\n         * scaledDecimal option is the number of decimal place when not in focus - for this to function scaledDivisor must not be null\r\n         * this is \"optional\" if omitted the decimal places will be the same when the input has focus\r\n         */\n        scaleDecimal: null,\n\n        /*\r\n         * scaledSymbol option is a symbol placed as a suffix when not in focus.\r\n         * this is \"optional\"\r\n         */\n        scaleSymbol: null,\n\n        /* Set to true to allow the eDec value to be saved with sessionStorage\r\n         * if ie 6 or 7 the value will be saved as a session cookie\r\n         */\n        aStor: false,\n\n        /* method used for rounding\r\n         * mRound: \"S\", Round-Half-Up Symmetric (default)\r\n         * mRound: \"A\", Round-Half-Up Asymmetric\r\n         * mRound: \"s\", Round-Half-Down Symmetric (lower case s)\r\n         * mRound: \"a\", Round-Half-Down Asymmetric (lower case a)\r\n         * mRound: \"B\", Round-Half-Even \"Bankers Rounding\"\r\n         * mRound: \"U\", Round Up \"Round-Away-From-Zero\"\r\n         * mRound: \"D\", Round Down \"Round-Toward-Zero\" - same as truncate\r\n         * mRound: \"C\", Round to Ceiling \"Toward Positive Infinity\"\r\n         * mRound: \"F\", Round to Floor \"Toward Negative Infinity\"\r\n         * mRound: \"N05\" Rounds to the nearest .05 => same as \"CHF\" used in 1.9X and still valid\r\n         * mRound: \"U05\" Rounds up to next .05\r\n         * mRound: \"D05\" Rounds down to next .05\r\n         */\n        mRound: 'S',\n\n        /* controls decimal padding\r\n         * aPad: true - always Pad decimals with zeros\r\n         * aPad: false - does not pad with zeros.\r\n         * thanks to Jonas Johansson for the suggestion\r\n         */\n        aPad: true,\n\n        /* places brackets on negative value -$ 999.99 to (999.99)\r\n         * visible only when the field does NOT have focus the left and right symbols should be enclosed in quotes and separated by a comma\r\n         * nBracket: null - (default)\r\n         * nBracket: '(,)', nBracket: '[,]', nBracket: '<,>' or nBracket: '{,}'\r\n         */\n        nBracket: null,\n\n        /* Displayed on empty string \"\"\r\n         * wEmpty: \"focus\" - (default) currency sign displayed and the input receives focus\r\n         * wEmpty: \"press\" - currency sign displays on any key being pressed\r\n         * wEmpty: \"always\" - always displays the currency sign only\r\n         * wEmpty: \"zero\" - if the input has no value on focus out displays a zero \"rounded\" with or with a currency sign\r\n         */\n        //TODO Add an option to display the currency sign only on hover (if the input is empty)\n        wEmpty: 'focus',\n\n        /* controls leading zero behavior\r\n         * lZero: \"allow\", - allows leading zeros to be entered. Zeros will be truncated when entering additional digits. On focusout zeros will be deleted.\r\n         * lZero: \"deny\", - allows only one leading zero on values less than one\r\n         * lZero: \"keep\", - allows leading zeros to be entered. on focusout zeros will be retained.\r\n         */\n        lZero: 'allow',\n\n        /* determine if the default value will be formatted on initialization.\r\n         * true = automatically formats the default value on initialization\r\n         * false = will not format the default value\r\n         */\n        aForm: true,\n\n        /* determine if the select all keyboard command will select\r\n         * the complete input text or only the input numeric value\r\n         * if the currency symbol is between the numeric value and the negative sign only the numeric value will selected\r\n         */\n        sNumber: false,\n\n        /* helper option for ASP.NET postback\r\n         * should be the value of the unformatted default value\r\n         * examples:\r\n         * no default value=\"\" {anDefault: \"\"}\r\n         * value=1234.56 {anDefault: '1234.56'}\r\n         */\n        anDefault: null,\n\n        /* removes formatting on submit event\r\n         * this output format: positive nnnn.nn, negative -nnnn.nn\r\n         * review the 'unSet' method for other formats\r\n         */\n        unSetOnSubmit: false,\n\n        /* allows the output to be in the locale format via the \"get\", \"getString\" & \"getArray\" methods\r\n         * null => nnnn.nn or -nnnn.nn default\r\n         * \",\"  => nnnn,nn or -nnnn,nn can als be \"-,\"\r\n         * \".-\" => nnnn.nn or nnnn.nn-\r\n         * \",-\" => nnnn,nn or nnnn,nn-\r\n         */\n        localeOutput: null,\n\n        /* error handling function\r\n         * true => all errors are thrown - helpful in site development\r\n         * false => throws errors when calling methods prior to the supported element has been initialized be autoNumeric\r\n         */\n        debug: false\n    };\n\n    getDefaultConfig = function getDefaultConfig() {\n        return $.fn.autoNumeric.defaults;\n    };\n\n    /**\r\n     * public function that allows formatting without an element trigger\r\n     */\n    autoFormat = function autoFormat(value, options) {\n        if (isUndefined(value) || value === null) {\n            return null;\n        }\n\n        var settings = $.extend({}, $.fn.autoNumeric.defaults, { strip: false }, options);\n        value = value.toString();\n        value = fromLocale(value);\n        if (Number(value) < 0) {\n            settings.aNeg = '-';\n        }\n        if (settings.mDec === null) {\n            var vMax = settings.vMax.toString().split('.');\n            var vMin = !settings.vMin && settings.vMin !== 0 ? [] : settings.vMin.toString().split('.');\n            settings.mDec = decLength(vMin, vMax);\n        }\n\n        var _autoCheck7 = autoCheck(value, settings),\n            _autoCheck8 = _slicedToArray(_autoCheck7, 2),\n            minTest = _autoCheck8[0],\n            maxTest = _autoCheck8[1];\n\n        if (!minTest || !maxTest) {\n            // Throw a custom event\n            sendCustomEvent('autoFormat.autoNumeric', 'Range test failed');\n            throwError('The value [' + value + '] being set falls outside the vMin [' + settings.vMin + '] and vMax [' + settings.vMax + '] settings', settings.debug);\n        }\n        value = autoRound(value, settings);\n        value = presentNumber(value, settings);\n        value = autoGroup(value, settings);\n\n        return value;\n    };\n\n    $.fn.autoFormat = autoFormat;\n\n    /**\r\n     * public function that allows unformatting without an element\r\n     */\n    autoUnFormat = function autoUnFormat(value, options) {\n        if (isUndefined(value) || value === null) {\n            return null;\n        }\n\n        var settings = $.extend({}, $.fn.autoNumeric.defaults, { strip: false }, options);\n        var allowed = '-0123456789\\\\' + settings.aDec;\n        var autoStrip = new RegExp('[^' + allowed + ']', 'gi');\n        value = value.toString();\n        if (value.charAt(0) === '-') {\n            settings.aNeg = '-';\n        } else if (settings.nBracket && settings.nBracket.split(',')[0] === value.charAt(0)) {\n            settings.aNeg = '-';\n            settings.onOff = true;\n            value = negativeBracket(value, settings);\n        }\n        value = value.replace(autoStrip, '');\n        value = value.replace(',', '.');\n        if (settings.localeOutput) {\n            value = toLocale(value, settings.localeOutput);\n        }\n\n        return Number(value);\n    };\n\n    $.fn.autoUnformat = autoUnFormat;\n\n    /**\r\n     * Create a custom event.\r\n     * cf. https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent\r\n     *\r\n     * @param eventName string\r\n     * @param detail\r\n     * @returns {CustomEvent}\r\n     */\n    function createCustomEvent(eventName, detail) {\n        /* let eventInfo = new CustomEventInit(); //This should be used instead, but IE does not support 'CustomEventInit' yet\r\n        eventInfo.detail = detail;\r\n        return new CustomEvent(eventName, eventInfo); */\n        return new CustomEvent(eventName, { detail: detail, bubbles: false, cancelable: false }); // This is not supported by default by IE ; We use the polyfill for IE9 and later.\n    }\n\n    /**\r\n     * Create a custom event and immediately broadcast it.\r\n     *\r\n     * @param eventName string\r\n     * @param detail\r\n     * @returns {boolean}\r\n     */\n    function sendCustomEvent(eventName) {\n        var detail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n        return document.dispatchEvent(createCustomEvent(eventName, detail));\n    }\n\n    /**\r\n     * Polyfill from https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent for obsolete browsers (IE)\r\n     */\n    (function () {\n        if (typeof window.CustomEvent === 'function') {\n            return false;\n        }\n\n        function CustomEvent(event, params) {\n            params = params || { bubbles: false, cancelable: false, detail: void 0 };\n            var evt = document.createEvent('CustomEvent');\n            evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n            return evt;\n        }\n\n        CustomEvent.prototype = window.Event.prototype;\n        window.CustomEvent = CustomEvent;\n    })();\n});\n\n/**\r\n * This exports the interface for the autoNumeric object\r\n */\n/* export default {\r\n    format  : autoFormat,\r\n    unFormat: autoUnFormat,\r\n    getDefaultConfig,\r\n\r\n    //TODO Complete the interface with functions having the following signatures :\r\n    //init         : an.init(options, input)\r\n    //get          : an.get(input)\r\n    //set          : an.set(value, input)\r\n    //formString   : an.formString(form)\r\n    //formArray    : an.formArray(form)\r\n    //getFormatted : an.getFormatted(input)\r\n    //unset        : an.unset(input) //to rename to 'unformat'? (and merge with autoUnFormat/unFormat?)\r\n    //reformat     : an.reformat(input) // 'reSet' is very to close to 'reset' and therefore should be renamed. We could still expose 'reSet', but add a @deprecated tag on its declaration.\r\n    //settings     : an.settings(input)\r\n    //update       : an.update(options, input)\r\n    //wipe         : an.wipe(input)\r\n    //destroy      : an.destroy(input)\r\n    //validate     : an.validate(options)\r\n}; */\n}.call(window));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9ib2Jrbi9Eb2N1bWVudHMvR2l0SHViL2F1dG9OdW1lcmljL3NyYy9hdXRvTnVtZXJpYy5qcz81OTRhIl0sIm5hbWVzIjpbImF1dG9Gb3JtYXQiLCJhdXRvVW5Gb3JtYXQiLCJnZXREZWZhdWx0Q29uZmlnIiwiZmFjdG9yeSIsImRlZmluZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIiwid2luZG93IiwialF1ZXJ5Iiwia2V5Q29kZSIsIkJhY2tzcGFjZSIsIlRhYiIsIkVudGVyIiwiU2hpZnQiLCJDdHJsIiwiQWx0IiwiUGF1c2VCcmVhayIsIkNhcHNMb2NrIiwiRXNjIiwiU3BhY2UiLCJQYWdlVXAiLCJQYWdlRG93biIsIkVuZCIsIkhvbWUiLCJMZWZ0QXJyb3ciLCJVcEFycm93IiwiUmlnaHRBcnJvdyIsIkRvd25BcnJvdyIsIkluc2VydCIsIkRlbGV0ZSIsIm51bTAiLCJudW0xIiwibnVtMiIsIm51bTMiLCJudW00IiwibnVtNSIsIm51bTYiLCJudW03IiwibnVtOCIsIm51bTkiLCJhIiwiYiIsImMiLCJkIiwiZSIsImYiLCJnIiwiaCIsImkiLCJqIiwiayIsImwiLCJtIiwibiIsIm8iLCJwIiwicSIsInIiLCJzIiwidCIsInUiLCJ2IiwidyIsIngiLCJ5IiwieiIsIldpbmRvd3MiLCJSaWdodENsaWNrIiwibnVtcGFkMCIsIm51bXBhZDEiLCJudW1wYWQyIiwibnVtcGFkMyIsIm51bXBhZDQiLCJudW1wYWQ1IiwibnVtcGFkNiIsIm51bXBhZDciLCJudW1wYWQ4IiwibnVtcGFkOSIsIk11bHRpcGx5TnVtcGFkIiwiUGx1c051bXBhZCIsIk1pbnVzTnVtcGFkIiwiRG90TnVtcGFkIiwiU2xhc2hOdW1wYWQiLCJGMSIsIkYyIiwiRjMiLCJGNCIsIkY1IiwiRjYiLCJGNyIsIkY4IiwiRjkiLCJGMTAiLCJGMTEiLCJGMTIiLCJOdW1Mb2NrIiwiU2Nyb2xsTG9jayIsIk15Q29tcHV0ZXIiLCJNeUNhbGN1bGF0b3IiLCJTZW1pY29sb24iLCJFcXVhbCIsIkNvbW1hIiwiSHlwaGVuIiwiRG90IiwiU2xhc2giLCJCYWNrcXVvdGUiLCJMZWZ0QnJhY2tldCIsIkJhY2tzbGFzaCIsIlJpZ2h0QnJhY2tldCIsIlF1b3RlIiwiQ29tbWFuZCIsImlzVW5kZWZpbmVkIiwidmFsdWUiLCJpc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkiLCJpc1N0cmluZyIsInN0ciIsIlN0cmluZyIsImNvbnRhaW5zIiwibmVlZGxlIiwiaW5kZXhPZiIsImlzSW5BcnJheSIsImFycmF5IiwiaXNBcnJheSIsImFyciIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsIkFycmF5IiwiRXJyb3IiLCJnZXRFbGVtZW50U2VsZWN0aW9uIiwidGhhdCIsInBvc2l0aW9uIiwic2VsZWN0aW9uU3RhcnQiLCJmb2N1cyIsInNlbGVjdCIsImRvY3VtZW50Iiwic2VsZWN0aW9uIiwiY3JlYXRlUmFuZ2UiLCJsZW5ndGgiLCJ0ZXh0IiwibW92ZVN0YXJ0IiwiZW5kIiwic3RhcnQiLCJzZWxlY3Rpb25FbmQiLCJzZXRFbGVtZW50U2VsZWN0aW9uIiwicmFuZ2UiLCJjcmVhdGVUZXh0UmFuZ2UiLCJjb2xsYXBzZSIsIm1vdmVFbmQiLCJ0aHJvd0Vycm9yIiwibWVzc2FnZSIsImRlYnVnIiwicnVuQ2FsbGJhY2tzIiwiJHRoaXMiLCJzZXR0aW5ncyIsIiQiLCJlYWNoIiwidmFsIiwiYXV0b051bWVyaWMiLCJkZWNMZW5ndGgiLCJ2TWluIiwidk1heCIsInZNYXhMZW5ndGgiLCJ2TWluTGVuZ3RoIiwiTWF0aCIsIm1heCIsImF1dG9Db2RlIiwic3BsaXQiLCJhTmVnIiwicmVwbGFjZSIsIm1JbnRQb3MiLCJtSW50TmVnIiwibURlYyIsIm9EZWMiLCJOdW1iZXIiLCJzY2FsZURpdmlzb3IiLCJzY2FsZURlY2ltYWwiLCJhbHREZWMiLCJhRGVjIiwiYVNlcCIsImFOZWdSZWciLCJhTmVnUmVnQXV0b1N0cmlwIiwic2tpcEZpcnN0QXV0b1N0cmlwIiwiUmVnRXhwIiwic2tpcExhc3RBdXRvU3RyaXAiLCJhbGxvd2VkIiwiYWxsb3dlZEF1dG9TdHJpcCIsIm51bVJlZ0F1dG9TdHJpcCIsImF1dG9TdHJpcCIsImFTaWduIiwiYVN1ZmZpeCIsInBOZWciLCJwU2lnbiIsInRyYWlsaW5nTmVnYXRpdmUiLCJtYXRjaCIsImpvaW4iLCJsWmVybyIsIm5TaWduIiwiaW50ZWdlclBhcnQiLCJkZWNpbWFsUGFydCIsIm1vZGlmaWVkSW50ZWdlclBhcnQiLCJjaGFyQXQiLCJzbGljZSIsIm9uT2ZmIiwic3RyaXBSZWciLCJuZWdhdGl2ZUJyYWNrZXQiLCJuQnJhY2tldCIsImZpcnN0QnJhY2tldCIsImxhc3RCcmFja2V0IiwiZnJvbUxvY2FsZSIsImxhc3RJbmRleE9mIiwidG9Mb2NhbGUiLCJsb2NhbGUiLCJmaXhOdW1iZXIiLCJwcmVzZW50TnVtYmVyIiwiY2hlY2tFbXB0eSIsIml2Iiwic2lnbk9uRW1wdHkiLCJ3RW1wdHkiLCJhdXRvR3JvdXAiLCJzdHJpcCIsImVtcHR5IiwiaXNOZWciLCJkaWdpdGFsR3JvdXAiLCJkR3JvdXAiLCJ0ZXN0Iiwic3Vic3RyaW5nIiwicmF3VmFsdWUiLCJ0cnVuY2F0ZVplcm9zIiwiaXZSb3VuZGVkIiwickRlYyIsInJlZ2V4IiwiYXV0b1JvdW5kIiwibVJvdW5kIiwicm91bmQiLCJjZWlsIiwiZmxvb3IiLCJyZXN1bHQiLCJhUGFkIiwiZFBvcyIsInZkUG9zIiwiY0RlYyIsInplcm9zIiwickxlbmd0aCIsInRSb3VuZCIsIm9kZCIsIml2QXJyYXkiLCJ0cnVuY2F0ZURlY2ltYWwiLCJwYXN0ZSIsIm1vZGlmaWVkRGVjaW1hbFBhcnQiLCJwYXJzZVN0ciIsIm5MIiwic2VhcmNoIiwidGVzdE1pbk1heCIsInhjIiwieWMiLCJ4TmVnIiwiYXV0b0NoZWNrIiwibWluUGFyc2UiLCJtYXhQYXJzZSIsInZhbFBhcnNlIiwib0xpbWl0cyIsImF1dG9HZXQiLCJvYmoiLCJnZXRIb2xkZXIiLCIkdGhhdCIsInVwZGF0ZSIsImRhdGEiLCJob2xkZXIiLCJBdXRvTnVtZXJpY0hvbGRlciIsImdldCIsIm9yaWdpbmFsU2V0dGluZ3MiLCJvUGFkIiwib0JyYWNrZXQiLCJvU2VwIiwib1NpZ24iLCJvU3VmZml4IiwicmVhZENvb2tpZSIsIm5hbWUiLCJuYW1lRVEiLCJjYSIsImNvb2tpZSIsInN0b3JhZ2VUZXN0IiwibW9kIiwic2Vzc2lvblN0b3JhZ2UiLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSIsImF1dG9TYXZlIiwidG9EbyIsImFTdG9yIiwic3RvcmVkTmFtZSIsImRlY29kZVVSSUNvbXBvbmVudCIsImlkIiwiZGF0ZSIsImV4cGlyZXMiLCJEYXRlIiwic2V0VGltZSIsImdldFRpbWUiLCJ0b1VUQ1N0cmluZyIsImdldEl0ZW0iLCJmb3JtYXR0ZWQiLCJzZXR0aW5nc0Nsb25lIiwiaW5pdCIsImN0cmxLZXkiLCJjbWRLZXkiLCJtZXRhS2V5Iiwic2hpZnRLZXkiLCJ0eXBlIiwia2RDb2RlIiwid2hpY2giLCJwcm9jZXNzZWQiLCJzZXRTZWxlY3Rpb24iLCJzZXRSZWFsIiwibWluIiwic2V0UG9zaXRpb24iLCJwb3MiLCJnZXRCZWZvcmVBZnRlciIsImxlZnQiLCJyaWdodCIsImdldEJlZm9yZUFmdGVyU3RyaXBlZCIsIm5vcm1hbGl6ZVBhcnRzIiwibmV3VmFsdWUiLCJzZXRWYWx1ZVBhcnRzIiwiYWR2ZW50IiwicGFydHMiLCJtaW5UZXN0IiwibWF4VGVzdCIsInRlc3RWYWx1ZSIsInRyaWdnZXIiLCJzaWduUG9zaXRpb24iLCJhU2lnbkxlbiIsImhhc05lZyIsInZhbHVlTGVuIiwiZXhwYW5kU2VsZWN0aW9uT25TaWduIiwiY2hlY2tQYXN0ZSIsInZhbHVlUGFydHNCZWZvcmVQYXN0ZSIsIm9sZFBhcnRzIiwibW9kaWZpZWRMZWZ0UGFydCIsInN1YnN0ciIsInNraXBBbHdheXMiLCJzTnVtYmVyIiwicHJldmVudERlZmF1bHQiLCJuZWdMZW4iLCJhU3VmZml4TGVuIiwic3RhcnRKdW1wIiwicHJvY2Vzc1RyYWlsaW5nIiwiY2FyZXRGaXgiLCJCb29sZWFuIiwicHJvY2Vzc0Fsd2F5cyIsInRocm93SW5wdXQiLCJwcm9jZXNzS2V5cHJlc3MiLCJjQ29kZSIsImZyb21DaGFyQ29kZSIsImZvcm1hdFF1aWNrIiwibGVmdExlbmd0aCIsImt1Q29kZSIsInN1YlBhcnRzIiwibGVmdEFyIiwic2hpZnQiLCJwdXNoIiwic2lnblBhcnRzIiwiZXNjYXBlQ2hyIiwiZXNjYXBlZFBhcnRzIiwibWluaVBhcnRzIiwibGVmdFJlZyIsIm5ld0xlZnQiLCJfZ2V0U3RyaW5nT3JBcnJheSIsImdldEFycmF5QmVoYXZpb3IiLCJmb3JtSW5kZXgiLCJpbmRleCIsImFsbEZvcm1FbGVtZW50cyIsImFpSW5kZXgiLCJzY0luZGV4IiwiclN1Ym1pdHRlclR5cGVzIiwiclN1Ym1pdHRhYmxlIiwickNoZWNrYWJsZVR5cGUiLCJyTm9uQXV0b051bWVyaWNUeXBlcyIsImNvdW50IiwiZmllbGQiLCJsb2NhbE5hbWUiLCJkaXNhYmxlZCIsImNoZWNrZWQiLCJmb3JtRmllbGRzIiwic2VyaWFsaXplQXJyYXkiLCJzY0VsZW1lbnQiLCJpbkFycmF5IiwidGVzdElucHV0IiwibG9jYWxlT3V0cHV0Iiwic2VyaWFsaXplIiwiZm9ybVBhcnRzIiwiaW5wdXROYW1lIiwiaW5wdXRWYWx1ZSIsIm1vZGlmaWVkSW5wdXRWYWx1ZSIsIm1ldGhvZHMiLCJvcHRpb25zIiwidGFnRGF0YSIsIiRpbnB1dCIsImlzIiwiZXh0ZW5kIiwiZm4iLCJkZWZhdWx0cyIsInJ1bk9uY2UiLCJ0YWdMaXN0Iiwia2V5IiwicHJvcCIsInRvTG93ZXJDYXNlIiwiZURlYyIsImFGb3JtIiwic2V0VmFsdWUiLCJjdXJyZW50VmFsdWUiLCJhdHRyIiwidGVzdGVkQ3VycmVudFZhbHVlIiwicGFyc2VGbG9hdCIsImlzTmFOIiwiSW5maW5pdHkiLCJhbkRlZmF1bHQiLCJpc051bWVyaWMiLCJ0b1N0cmlwIiwib24iLCIkc2V0dGluZ3MiLCJuU2VwIiwiaW5WYWwiLCJsYXN0VmFsIiwib25FbXB0eSIsInJlYWRPbmx5Iiwic2tpcCIsInRhYiIsIm9yaWdWYWx1ZSIsImdyb3VwZWRWYWx1ZSIsInNjYWxlU3ltYm9sIiwiY2hhbmdlIiwicHJlcGFyZSIsImlzVmFsaWQiLCJvbGRSYXdWYWx1ZSIsInByZWZpeCIsInN1ZmZpeCIsInBhc3RlZFRleHQiLCJvcmlnaW5hbEV2ZW50IiwiY2xpcGJvYXJkRGF0YSIsImdldERhdGEiLCJ2YWx1ZU9mIiwiY2xvc2VzdCIsInVuU2V0T25TdWJtaXQiLCJkZXN0cm95IiwicmVtb3ZlRGF0YSIsIm9mZiIsIndpcGUiLCJzZXQiLCJ2YWx1ZUluIiwiYXR0ZW1wdGVkVmFsdWUiLCJ1blNldCIsInJlU2V0IiwiZXEiLCJnZXRGb3JtYXR0ZWQiLCJoYXNPd25Qcm9wZXJ0eSIsImdldFN0cmluZyIsImdldEFycmF5IiwiZ2V0U2V0dGluZ3MiLCJtZXRob2QiLCJhcmdzIiwiYXBwbHkiLCJzZW5kQ3VzdG9tRXZlbnQiLCJhdXRvVW5mb3JtYXQiLCJjcmVhdGVDdXN0b21FdmVudCIsImV2ZW50TmFtZSIsImRldGFpbCIsIkN1c3RvbUV2ZW50IiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJkaXNwYXRjaEV2ZW50IiwiZXZlbnQiLCJwYXJhbXMiLCJldnQiLCJjcmVhdGVFdmVudCIsImluaXRDdXN0b21FdmVudCIsIkV2ZW50Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0NBLElBQUlBLG1CQUFKO0FBQ0EsSUFBSUMscUJBQUo7QUFDQSxJQUFJQyx5QkFBSjs7QUFFQTs7QUFFQyxXQUFTQyxPQUFULEVBQWtCO0FBQ2Y7QUFDSixRQUFJLElBQUosRUFBZ0Q7QUFDNUM7QUFDQUMsUUFBQSxpQ0FBTyxDQUFDLHNCQUFELENBQVAsb0NBQW1CRCxPQUFuQjtBQUNILEtBSEQsTUFHTyxJQUFJLFFBQU9FLE1BQVAseUNBQU9BLE1BQVAsT0FBa0IsUUFBbEIsSUFBOEJBLE9BQU9DLE9BQXpDLEVBQWtEO0FBQ3JEO0FBQ0FE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QUFHQSxlQUFPLElBQUlDLFdBQUosQ0FBZ0JGLFNBQWhCLEVBQTJCLEVBQUVDLGNBQUYsRUFBVUUsU0FBUyxLQUFuQixFQUEwQkMsWUFBWSxLQUF0QyxFQUEzQixDQUFQLENBSjBDLENBSXdDO0FBQ3JGOztBQUVEOzs7Ozs7O0FBT0EsYUFBU1AsZUFBVCxDQUF5QkcsU0FBekIsRUFBbUQ7QUFBQSxZQUFmQyxNQUFlLHVFQUFOLElBQU07O0FBQy9DLGVBQU8xVSxTQUFTOFUsYUFBVCxDQUF1Qk4sa0JBQWtCQyxTQUFsQixFQUE2QkMsTUFBN0IsQ0FBdkIsQ0FBUDtBQUNIOztBQUVEOzs7QUFHQSxLQUFDLFlBQVc7QUFDUixZQUFJLE9BQU8zYyxPQUFPNGMsV0FBZCxLQUE4QixVQUFsQyxFQUE4QztBQUMxQyxtQkFBTyxLQUFQO0FBQ0g7O0FBRUQsaUJBQVNBLFdBQVQsQ0FBcUJJLEtBQXJCLEVBQTRCQyxNQUE1QixFQUFvQztBQUNoQ0EscUJBQVNBLFVBQVUsRUFBRUosU0FBUyxLQUFYLEVBQWtCQyxZQUFZLEtBQTlCLEVBQXFDSCxRQUFRLEtBQUssQ0FBbEQsRUFBbkI7QUFDQSxnQkFBTU8sTUFBTWpWLFNBQVNrVixXQUFULENBQXFCLGFBQXJCLENBQVo7QUFDQUQsZ0JBQUlFLGVBQUosQ0FBb0JKLEtBQXBCLEVBQTJCQyxPQUFPSixPQUFsQyxFQUEyQ0ksT0FBT0gsVUFBbEQsRUFBOERHLE9BQU9OLE1BQXJFO0FBQ0EsbUJBQU9PLEdBQVA7QUFDSDs7QUFFRE4sb0JBQVl0VixTQUFaLEdBQXdCdEgsT0FBT3FkLEtBQVAsQ0FBYS9WLFNBQXJDO0FBQ0F0SCxlQUFPNGMsV0FBUCxHQUFxQkEsV0FBckI7QUFDSCxLQWREO0FBZUgsQ0FyeUZBLENBQUQ7O0FBdXlGQTs7O0FBR0EiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4qIGF1dG9OdW1lcmljLmpzXHJcbiogQGF1dGhvcjogQm9iIEtub3RoZVxyXG4qIEBjb250cmlidXRvcnM6IFNva29sb3YgWXVyYSBhbmQgb3RoZXIgR2l0aHViIHVzZXJzXHJcbiogQHZlcnNpb246IDIuMCAtIDIwMTYtMTEtMjUgR01UIDIzOjAwXHJcbipcclxuKiBDcmVhdGVkIGJ5IFJvYmVydCBKLiBLbm90aGUgb24gMjAwOS0wOC0wOS4gUGxlYXNlIHJlcG9ydCBhbnkgYnVncyB0byBodHRwczovL2dpdGh1Yi5jb20vQm9iS25vdGhlL2F1dG9OdW1lcmljXHJcbipcclxuKiBDb3B5cmlnaHQgKGMpIDIwMDkgUm9iZXJ0IEouIEtub3RoZSBodHRwOi8vd3d3LmRlY29ycGxhbml0LmNvbS9wbHVnaW4vXHJcbipcclxuKiBUaGUgTUlUIExpY2Vuc2UgKGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwKVxyXG4qXHJcbiogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cclxuKiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxyXG4qIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxyXG4qIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxyXG4qIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YiBsaWNlbnNlLCBhbmQvb3Igc2VsbFxyXG4qIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxyXG4qIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXHJcbiogY29uZGl0aW9uczpcclxuKlxyXG4qIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXHJcbiogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbipcclxuKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxyXG4qIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xyXG4qIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXHJcbiogTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcclxuKiBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcclxuKiBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcclxuKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXHJcbiogT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG4qL1xyXG5cclxubGV0IGF1dG9Gb3JtYXQ7XHJcbmxldCBhdXRvVW5Gb3JtYXQ7XHJcbmxldCBnZXREZWZhdWx0Q29uZmlnO1xyXG5cclxuLyogZ2xvYmFsIG1vZHVsZSwgcmVxdWlyZSwgZGVmaW5lICovXHJcblxyXG4oZnVuY3Rpb24oZmFjdG9yeSkge1xyXG4gICAgLy9UT0RPIFRoaXMgc3VyZWx5IGNhbiBiZSBpbXByb3ZlZCBieSBsZXR0aW5nIHdlYnBhY2sgdGFrZSBjYXJlIG9mIGdlbmVyYXRpbmcgdGhpcyBVTUQgcGFydFxyXG5pZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXHJcbiAgICBkZWZpbmUoWydqcXVlcnknXSwgZmFjdG9yeSk7XHJcbn0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcclxuICAgIC8vIE5vZGUvQ29tbW9uSlNcclxuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCdqcXVlcnknKSk7XHJcbn0gZWxzZSB7XHJcbiAgICAvLyBCcm93c2VyIGdsb2JhbHNcclxuICAgIGZhY3Rvcnkod2luZG93LmpRdWVyeSk7XHJcbn1cclxufSgkID0+IHtcclxuICAgIC8qKlxyXG4gICAgICogV3JhcHBlciB2YXJpYWJsZSB0aGF0IGhvbGQgbmFtZWQga2V5Ym9hcmQga2V5cyB3aXRoIHRoZWlyIHJlc3BlY3RpdmUga2V5Q29kZSBhcyBzZWVuIGluIERPTSBldmVudHMuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IGtleUNvZGUgPSB7XHJcbiAgICAgICAgQmFja3NwYWNlOiAgICAgIDgsXHJcbiAgICAgICAgVGFiOiAgICAgICAgICAgIDksXHJcbiAgICAgICAgRW50ZXI6ICAgICAgICAgIDEzLFxyXG4gICAgICAgIFNoaWZ0OiAgICAgICAgICAxNixcclxuICAgICAgICBDdHJsOiAgICAgICAgICAgMTcsXHJcbiAgICAgICAgQWx0OiAgICAgICAgICAgIDE4LFxyXG4gICAgICAgIFBhdXNlQnJlYWs6ICAgICAxOSxcclxuICAgICAgICBDYXBzTG9jazogICAgICAgMjAsXHJcbiAgICAgICAgRXNjOiAgICAgICAgICAgIDI3LFxyXG4gICAgICAgIFNwYWNlOiAgICAgICAgICAzMixcclxuICAgICAgICBQYWdlVXA6ICAgICAgICAgMzMsXHJcbiAgICAgICAgUGFnZURvd246ICAgICAgIDM0LFxyXG4gICAgICAgIEVuZDogICAgICAgICAgICAzNSxcclxuICAgICAgICBIb21lOiAgICAgICAgICAgMzYsXHJcbiAgICAgICAgTGVmdEFycm93OiAgICAgIDM3LFxyXG4gICAgICAgIFVwQXJyb3c6ICAgICAgICAzOCxcclxuICAgICAgICBSaWdodEFycm93OiAgICAgMzksXHJcbiAgICAgICAgRG93bkFycm93OiAgICAgIDQwLFxyXG4gICAgICAgIEluc2VydDogICAgICAgICA0NSxcclxuICAgICAgICBEZWxldGU6ICAgICAgICAgNDYsXHJcbiAgICAgICAgbnVtMDogICAgICAgICAgIDQ4LFxyXG4gICAgICAgIG51bTE6ICAgICAgICAgICA0OSxcclxuICAgICAgICBudW0yOiAgICAgICAgICAgNTAsXHJcbiAgICAgICAgbnVtMzogICAgICAgICAgIDUxLFxyXG4gICAgICAgIG51bTQ6ICAgICAgICAgICA1MixcclxuICAgICAgICBudW01OiAgICAgICAgICAgNTMsXHJcbiAgICAgICAgbnVtNjogICAgICAgICAgIDU0LFxyXG4gICAgICAgIG51bTc6ICAgICAgICAgICA1NSxcclxuICAgICAgICBudW04OiAgICAgICAgICAgNTYsXHJcbiAgICAgICAgbnVtOTogICAgICAgICAgIDU3LFxyXG4gICAgICAgIGE6ICAgICAgICAgICAgICA2NSxcclxuICAgICAgICBiOiAgICAgICAgICAgICAgNjYsXHJcbiAgICAgICAgYzogICAgICAgICAgICAgIDY3LFxyXG4gICAgICAgIGQ6ICAgICAgICAgICAgICA2OCxcclxuICAgICAgICBlOiAgICAgICAgICAgICAgNjksXHJcbiAgICAgICAgZjogICAgICAgICAgICAgIDcwLFxyXG4gICAgICAgIGc6ICAgICAgICAgICAgICA3MSxcclxuICAgICAgICBoOiAgICAgICAgICAgICAgNzIsXHJcbiAgICAgICAgaTogICAgICAgICAgICAgIDczLFxyXG4gICAgICAgIGo6ICAgICAgICAgICAgICA3NCxcclxuICAgICAgICBrOiAgICAgICAgICAgICAgNzUsXHJcbiAgICAgICAgbDogICAgICAgICAgICAgIDc2LFxyXG4gICAgICAgIG06ICAgICAgICAgICAgICA3NyxcclxuICAgICAgICBuOiAgICAgICAgICAgICAgNzgsXHJcbiAgICAgICAgbzogICAgICAgICAgICAgIDc5LFxyXG4gICAgICAgIHA6ICAgICAgICAgICAgICA4MCxcclxuICAgICAgICBxOiAgICAgICAgICAgICAgODEsXHJcbiAgICAgICAgcjogICAgICAgICAgICAgIDgyLFxyXG4gICAgICAgIHM6ICAgICAgICAgICAgICA4MyxcclxuICAgICAgICB0OiAgICAgICAgICAgICAgODQsXHJcbiAgICAgICAgdTogICAgICAgICAgICAgIDg1LFxyXG4gICAgICAgIHY6ICAgICAgICAgICAgICA4NixcclxuICAgICAgICB3OiAgICAgICAgICAgICAgODcsXHJcbiAgICAgICAgeDogICAgICAgICAgICAgIDg4LFxyXG4gICAgICAgIHk6ICAgICAgICAgICAgICA4OSxcclxuICAgICAgICB6OiAgICAgICAgICAgICAgOTAsXHJcbiAgICAgICAgV2luZG93czogICAgICAgIDkxLFxyXG4gICAgICAgIFJpZ2h0Q2xpY2s6ICAgICA5MyxcclxuICAgICAgICBudW1wYWQwOiAgICAgICAgOTYsXHJcbiAgICAgICAgbnVtcGFkMTogICAgICAgIDk3LFxyXG4gICAgICAgIG51bXBhZDI6ICAgICAgICA5OCxcclxuICAgICAgICBudW1wYWQzOiAgICAgICAgOTksXHJcbiAgICAgICAgbnVtcGFkNDogICAgICAgIDEwMCxcclxuICAgICAgICBudW1wYWQ1OiAgICAgICAgMTAxLFxyXG4gICAgICAgIG51bXBhZDY6ICAgICAgICAxMDIsXHJcbiAgICAgICAgbnVtcGFkNzogICAgICAgIDEwMyxcclxuICAgICAgICBudW1wYWQ4OiAgICAgICAgMTA0LFxyXG4gICAgICAgIG51bXBhZDk6ICAgICAgICAxMDUsXHJcbiAgICAgICAgTXVsdGlwbHlOdW1wYWQ6IDEwNixcclxuICAgICAgICBQbHVzTnVtcGFkOiAgICAgMTA3LFxyXG4gICAgICAgIE1pbnVzTnVtcGFkOiAgICAxMDksXHJcbiAgICAgICAgRG90TnVtcGFkOiAgICAgIDExMCxcclxuICAgICAgICBTbGFzaE51bXBhZDogICAgMTExLFxyXG4gICAgICAgIEYxOiAgICAgICAgICAgICAxMTIsXHJcbiAgICAgICAgRjI6ICAgICAgICAgICAgIDExMyxcclxuICAgICAgICBGMzogICAgICAgICAgICAgMTE0LFxyXG4gICAgICAgIEY0OiAgICAgICAgICAgICAxMTUsXHJcbiAgICAgICAgRjU6ICAgICAgICAgICAgIDExNixcclxuICAgICAgICBGNjogICAgICAgICAgICAgMTE3LFxyXG4gICAgICAgIEY3OiAgICAgICAgICAgICAxMTgsXHJcbiAgICAgICAgRjg6ICAgICAgICAgICAgIDExOSxcclxuICAgICAgICBGOTogICAgICAgICAgICAgMTIwLFxyXG4gICAgICAgIEYxMDogICAgICAgICAgICAxMjEsXHJcbiAgICAgICAgRjExOiAgICAgICAgICAgIDEyMixcclxuICAgICAgICBGMTI6ICAgICAgICAgICAgMTIzLFxyXG4gICAgICAgIE51bUxvY2s6ICAgICAgICAxNDQsXHJcbiAgICAgICAgU2Nyb2xsTG9jazogICAgIDE0NSxcclxuICAgICAgICBNeUNvbXB1dGVyOiAgICAgMTgyLFxyXG4gICAgICAgIE15Q2FsY3VsYXRvcjogICAxODMsXHJcbiAgICAgICAgU2VtaWNvbG9uOiAgICAgIDE4NixcclxuICAgICAgICBFcXVhbDogICAgICAgICAgMTg3LFxyXG4gICAgICAgIENvbW1hOiAgICAgICAgICAxODgsXHJcbiAgICAgICAgSHlwaGVuOiAgICAgICAgIDE4OSxcclxuICAgICAgICBEb3Q6ICAgICAgICAgICAgMTkwLFxyXG4gICAgICAgIFNsYXNoOiAgICAgICAgICAxOTEsXHJcbiAgICAgICAgQmFja3F1b3RlOiAgICAgIDE5MixcclxuICAgICAgICBMZWZ0QnJhY2tldDogICAgMjE5LFxyXG4gICAgICAgIEJhY2tzbGFzaDogICAgICAyMjAsXHJcbiAgICAgICAgUmlnaHRCcmFja2V0OiAgIDIyMSxcclxuICAgICAgICBRdW90ZTogICAgICAgICAgMjIyLFxyXG4gICAgICAgIENvbW1hbmQ6ICAgICAgICAyMjQsXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIGB2YWx1ZWAgaXMgdW5kZWZpbmVkXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSB2b2lkKDApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIGB2YWx1ZWAgaXMgdW5kZWZpbmVkLCBudWxsIG9yIGVtcHR5XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWRPck51bGxPckVtcHR5KHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkKDApIHx8ICcnID09PSB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBnaXZlbiBwYXJhbWV0ZXIgaXMgYXMgU3RyaW5nXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsqfSBzdHJcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc1N0cmluZyhzdHIpIHtcclxuICAgICAgICByZXR1cm4gKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnIHx8IHN0ciBpbnN0YW5jZW9mIFN0cmluZyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gVFJVRSBpcyB0aGUgc3RyaW5nIGBzdHJgIGNvbnRhaW5zIHRoZSBzdHJpbmcgYG5lZWRsZWBcclxuICAgICAqIE5vdGU6IHRoaXMgZnVuY3Rpb24gZG9lcyBub3QgY29lcmNlIHRoZSBwYXJhbWV0ZXJzIHR5cGVzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5lZWRsZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNvbnRhaW5zKHN0ciwgbmVlZGxlKSB7XHJcbiAgICAgICAgaWYgKCFpc1N0cmluZyhzdHIpIHx8ICFpc1N0cmluZyhuZWVkbGUpIHx8IHN0ciA9PT0gJycgfHwgbmVlZGxlID09PSAnJykge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gc3RyLmluZGV4T2YobmVlZGxlKSAhPT0gLTE7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgYG5lZWRsZWAgaXMgaW4gdGhlIGFycmF5XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlcclxuICAgICAqIEBwYXJhbSB7Kn0gbmVlZGxlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNJbkFycmF5KG5lZWRsZSwgYXJyYXkpIHtcclxuICAgICAgICBpZiAoIWlzQXJyYXkoYXJyYXkpIHx8IGFycmF5ID09PSBbXSB8fCBpc1VuZGVmaW5lZChuZWVkbGUpIHx8IG5lZWRsZSA9PT0gJycgfHwgbmVlZGxlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBhcnJheS5pbmRleE9mKG5lZWRsZSkgIT09IC0xO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIHBhcmFtZXRlciBpcyBhbiBBcnJheVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Kn0gYXJyXHJcbiAgICAgKiBAdGhyb3dzIEVycm9yXHJcbiAgICAgKiBAcmV0dXJucyB7Knxib29sZWFufVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc0FycmF5KGFycikge1xyXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoW10pID09PSAnW29iamVjdCBBcnJheV0nKSB7IC8vIE1ha2Ugc3VyZSBhbiBhcnJheSBoYXMgYSBjbGFzcyBhdHRyaWJ1dGUgb2YgW29iamVjdCBBcnJheV1cclxuICAgICAgICAgICAgLy8gVGVzdCBwYXNzZWQsIG5vdyBjaGVjayBpZiBpcyBhbiBBcnJheVxyXG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcnIpIHx8ICh0eXBlb2YgYXJyID09PSAnb2JqZWN0JyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PT0gJ1tvYmplY3QgQXJyYXldJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RvU3RyaW5nIG1lc3NhZ2UgY2hhbmdlZCBmb3IgT2JqZWN0IEFycmF5Jyk7IC8vIFZlcmlmeSB0aGF0IHRoZSBzdHJpbmcgcmV0dXJuZWQgYnkgYHRvU3RyaW5nYCBkb2VzIG5vdCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZSAoY2YuIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzgzNjUyMTUpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3Jvc3MgYnJvd3NlciByb3V0aW5lIGZvciBnZXR0aW5nIHNlbGVjdGVkIHJhbmdlL2N1cnNvciBwb3NpdGlvblxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRFbGVtZW50U2VsZWN0aW9uKHRoYXQpIHtcclxuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHt9O1xyXG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh0aGF0LnNlbGVjdGlvblN0YXJ0KSkge1xyXG4gICAgICAgICAgICB0aGF0LmZvY3VzKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdCA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xyXG4gICAgICAgICAgICBwb3NpdGlvbi5sZW5ndGggPSBzZWxlY3QudGV4dC5sZW5ndGg7XHJcbiAgICAgICAgICAgIHNlbGVjdC5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIC10aGF0LnZhbHVlLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uLmVuZCA9IHNlbGVjdC50ZXh0Lmxlbmd0aDtcclxuICAgICAgICAgICAgcG9zaXRpb24uc3RhcnQgPSBwb3NpdGlvbi5lbmQgLSBwb3NpdGlvbi5sZW5ndGg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcG9zaXRpb24uc3RhcnQgPSB0aGF0LnNlbGVjdGlvblN0YXJ0O1xyXG4gICAgICAgICAgICBwb3NpdGlvbi5lbmQgPSB0aGF0LnNlbGVjdGlvbkVuZDtcclxuICAgICAgICAgICAgcG9zaXRpb24ubGVuZ3RoID0gcG9zaXRpb24uZW5kIC0gcG9zaXRpb24uc3RhcnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcG9zaXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcm9zcyBicm93c2VyIHJvdXRpbmUgZm9yIHNldHRpbmcgc2VsZWN0ZWQgcmFuZ2UvY3Vyc29yIHBvc2l0aW9uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHNldEVsZW1lbnRTZWxlY3Rpb24odGhhdCwgc3RhcnQsIGVuZCkge1xyXG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh0aGF0LnNlbGVjdGlvblN0YXJ0KSkge1xyXG4gICAgICAgICAgICB0aGF0LmZvY3VzKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gdGhhdC5jcmVhdGVUZXh0UmFuZ2UoKTtcclxuICAgICAgICAgICAgcmFuZ2UuY29sbGFwc2UodHJ1ZSk7XHJcbiAgICAgICAgICAgIHJhbmdlLm1vdmVFbmQoJ2NoYXJhY3RlcicsIGVuZCk7XHJcbiAgICAgICAgICAgIHJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgc3RhcnQpO1xyXG4gICAgICAgICAgICByYW5nZS5zZWxlY3QoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGF0LnNlbGVjdGlvblN0YXJ0ID0gc3RhcnQ7XHJcbiAgICAgICAgICAgIHRoYXQuc2VsZWN0aW9uRW5kID0gZW5kO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZ1bmN0aW9uIHRvIGhhbmRsZSBlcnJvcnMgbWVzc2FnZXNcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdGhyb3dFcnJvcihtZXNzYWdlLCBkZWJ1Zykge1xyXG4gICAgICAgIGlmIChkZWJ1Zykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcnVuIGNhbGxiYWNrcyBpbiBwYXJhbWV0ZXJzIGlmIGFueVxyXG4gICAgICogYW55IHBhcmFtZXRlciBjb3VsZCBiZSBhIGNhbGxiYWNrOlxyXG4gICAgICogLSBhIGZ1bmN0aW9uLCB3aGljaCBpbnZva2VkIHdpdGggalF1ZXJ5IGVsZW1lbnQsIHBhcmFtZXRlcnMgYW5kIHRoaXMgcGFyYW1ldGVyIG5hbWUgYW5kIHJldHVybnMgcGFyYW1ldGVyIHZhbHVlXHJcbiAgICAgKiAtIGEgbmFtZSBvZiBmdW5jdGlvbiwgYXR0YWNoZWQgdG8gJChzZWxlY3RvcikuYXV0b051bWVyaWMuZnVuY3Rpb25OYW1lKCl7fSAtIHdoaWNoIHdhcyBjYWxsZWQgcHJldmlvdXNseVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBydW5DYWxsYmFja3MoJHRoaXMsIHNldHRpbmdzKSB7XHJcbiAgICAgICAgLy8gbG9vcHMgdGhyb3VnaCB0aGUgc2V0dGluZ3Mgb2JqZWN0IChvcHRpb24gYXJyYXkpIHRvIGZpbmQgdGhlIGZvbGxvd2luZ1xyXG4gICAgICAgICQuZWFjaChzZXR0aW5ncywgKGssIHZhbCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3Nba10gPSB2YWwoJHRoaXMsIHNldHRpbmdzLCBrKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgJHRoaXMuYXV0b051bWVyaWNbdmFsXSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgLy8gY2FsbHMgdGhlIGF0dGFjaGVkIGZ1bmN0aW9uIGZyb20gdGhlIGh0bWw1IGRhdGEgZXhhbXBsZTogZGF0YS1hLXNpZ249XCJmdW5jdGlvbk5hbWVcIlxyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3Nba10gPSAkdGhpcy5hdXRvTnVtZXJpY1t2YWxdKCR0aGlzLCBzZXR0aW5ncywgayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERldGVybWluZSB0aGUgZGVjaW1hbCBsZW5ndGggZnJvbSB0aGUgdk1pbiB2TWF4IHNldHRpbmdzXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGRlY0xlbmd0aCh2TWluLCB2TWF4KSB7XHJcbiAgICAgICAgbGV0IHZNYXhMZW5ndGggPSAwO1xyXG4gICAgICAgIGxldCB2TWluTGVuZ3RoID0gMDtcclxuICAgICAgICBpZiAodk1heFsxXSkge1xyXG4gICAgICAgICAgICB2TWF4TGVuZ3RoID0gdk1heFsxXS5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2TWluWzFdKSB7XHJcbiAgICAgICAgICAgIHZNaW5MZW5ndGggPSB2TWluWzFdLmxlbmd0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBNYXRoLm1heCh2TWF4TGVuZ3RoLCB2TWluTGVuZ3RoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFByZXBhcmluZyB1c2VyIGRlZmluZWQgb3B0aW9ucyBmb3IgZnVydGhlciB1c2FnZVxyXG4gICAgICogbWVyZ2UgdGhlbSB3aXRoIGRlZmF1bHRzIGFwcHJvcHJpYXRlbHlcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYXV0b0NvZGUoJHRoaXMsIHNldHRpbmdzKSB7XHJcbiAgICAgICAgcnVuQ2FsbGJhY2tzKCR0aGlzLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgY29uc3Qgdk1heCA9IHNldHRpbmdzLnZNYXgudG9TdHJpbmcoKS5zcGxpdCgnLicpO1xyXG4gICAgICAgIGNvbnN0IHZNaW4gPSAoIXNldHRpbmdzLnZNaW4gJiYgc2V0dGluZ3Mudk1pbiAhPT0gMCkgPyBbXSA6IHNldHRpbmdzLnZNaW4udG9TdHJpbmcoKS5zcGxpdCgnLicpO1xyXG4gICAgICAgIHNldHRpbmdzLmFOZWcgPSBzZXR0aW5ncy52TWluIDwgMCA/ICctJyA6ICcnO1xyXG4gICAgICAgIHZNYXhbMF0gPSB2TWF4WzBdLnJlcGxhY2UoJy0nLCAnJyk7XHJcbiAgICAgICAgdk1pblswXSA9IHZNaW5bMF0ucmVwbGFjZSgnLScsICcnKTtcclxuICAgICAgICBzZXR0aW5ncy5tSW50UG9zID0gTWF0aC5tYXgodk1heFswXS5sZW5ndGgsIDEpO1xyXG4gICAgICAgIHNldHRpbmdzLm1JbnROZWcgPSBNYXRoLm1heCh2TWluWzBdLmxlbmd0aCwgMSk7XHJcbiAgICAgICAgaWYgKHNldHRpbmdzLm1EZWMgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgc2V0dGluZ3MubURlYyA9IGRlY0xlbmd0aCh2TWluLCB2TWF4KTtcclxuICAgICAgICAgICAgc2V0dGluZ3Mub0RlYyA9IHNldHRpbmdzLm1EZWM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc2V0dGluZ3MubURlYyA9IE51bWJlcihzZXR0aW5ncy5tRGVjKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0dGluZ3MubURlYyA9IChzZXR0aW5ncy5zY2FsZURpdmlzb3IgJiYgc2V0dGluZ3Muc2NhbGVEZWNpbWFsKSA/IHNldHRpbmdzLnNjYWxlRGVjaW1hbCA6IHNldHRpbmdzLm1EZWM7XHJcblxyXG4gICAgICAgIC8vIHNldCBhbHRlcm5hdGl2ZSBkZWNpbWFsIHNlcGFyYXRvciBrZXlcclxuICAgICAgICBpZiAoc2V0dGluZ3MuYWx0RGVjID09PSBudWxsICYmIHNldHRpbmdzLm1EZWMgPiAwKSB7XHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5hRGVjID09PSAnLicgJiYgc2V0dGluZ3MuYVNlcCAhPT0gJywnKSB7XHJcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5hbHREZWMgPSAnLCc7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3MuYURlYyA9PT0gJywnICYmIHNldHRpbmdzLmFTZXAgIT09ICcuJykge1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuYWx0RGVjID0gJy4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjYWNoZSByZWdleHBzIGZvciBhdXRvU3RyaXBcclxuICAgICAgICBjb25zdCBhTmVnUmVnID0gc2V0dGluZ3MuYU5lZyA/YChbLVxcXFwke3NldHRpbmdzLmFOZWd9XT8pYCA6JygtPyknO1xyXG4gICAgICAgIHNldHRpbmdzLmFOZWdSZWdBdXRvU3RyaXAgPSBhTmVnUmVnO1xyXG4gICAgICAgIHNldHRpbmdzLnNraXBGaXJzdEF1dG9TdHJpcCA9IG5ldyBSZWdFeHAoYCR7YU5lZ1JlZ31bXi0keyhzZXR0aW5ncy5hTmVnP2BcXFxcJHtzZXR0aW5ncy5hTmVnfWA6JycpfVxcXFwke3NldHRpbmdzLmFEZWN9XFxcXGRdLio/KFxcXFxkfFxcXFwke3NldHRpbmdzLmFEZWN9XFxcXGQpYCk7XHJcbiAgICAgICAgc2V0dGluZ3Muc2tpcExhc3RBdXRvU3RyaXAgPSBuZXcgUmVnRXhwKGAoXFxcXGRcXFxcJHtzZXR0aW5ncy5hRGVjfT8pW15cXFxcJHtzZXR0aW5ncy5hRGVjfVxcXFxkXVxcXFxEKiRgKTtcclxuICAgICAgICBjb25zdCBhbGxvd2VkID0gYC0wMTIzNDU2Nzg5XFxcXCR7c2V0dGluZ3MuYURlY31gO1xyXG4gICAgICAgIHNldHRpbmdzLmFsbG93ZWRBdXRvU3RyaXAgPSBuZXcgUmVnRXhwKGBbXiR7YWxsb3dlZH1dYCwgJ2dpJyk7XHJcbiAgICAgICAgc2V0dGluZ3MubnVtUmVnQXV0b1N0cmlwID0gbmV3IFJlZ0V4cChgJHthTmVnUmVnfSg/OlxcXFwke3NldHRpbmdzLmFEZWN9PyhcXFxcZCtcXFxcJHtzZXR0aW5ncy5hRGVjfVxcXFxkKyl8KFxcXFxkKig/OlxcXFwke3NldHRpbmdzLmFEZWN9XFxcXGQqKT8pKWApO1xyXG5cclxuICAgICAgICByZXR1cm4gc2V0dGluZ3M7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBzdHJpcCBhbGwgdW53YW50ZWQgY2hhcmFjdGVycyBhbmQgbGVhdmUgb25seSBhIG51bWJlciBhbGVydFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBhdXRvU3RyaXAocywgc2V0dGluZ3MpIHtcclxuICAgICAgICBpZiAoc2V0dGluZ3MuYVNpZ24gIT09ICcnKSB7XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZSBjdXJyZW5jeSBzaWduXHJcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3MuYVNpZ24sICcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNldHRpbmdzLmFTdWZmaXgpIHtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlIHN1ZmZpeFxyXG4gICAgICAgICAgICB3aGlsZSAoY29udGFpbnMocywgc2V0dGluZ3MuYVN1ZmZpeCkpIHtcclxuICAgICAgICAgICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3MuYVN1ZmZpeCwgJycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBmaXJzdCByZXBsYWNlIGFueXRoaW5nIGJlZm9yZSBkaWdpdHNcclxuICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLnNraXBGaXJzdEF1dG9TdHJpcCwgJyQxJDInKTtcclxuXHJcbiAgICAgICAgaWYgKChzZXR0aW5ncy5wTmVnID09PSAncycgfHwgKHNldHRpbmdzLnBTaWduID09PSAncycgJiYgc2V0dGluZ3MucE5lZyAhPT0gJ3AnKSkgJiYgY29udGFpbnMocywgJy0nKSAmJiBzICE9PSAnJykge1xyXG4gICAgICAgICAgICBzZXR0aW5ncy50cmFpbGluZ05lZ2F0aXZlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHRoZW4gcmVwbGFjZSBhbnl0aGluZyBhZnRlciBkaWdpdHNcclxuICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLnNraXBMYXN0QXV0b1N0cmlwLCAnJDEnKTtcclxuXHJcbiAgICAgICAgLy8gdGhlbiByZW1vdmUgYW55IHVuaW50ZXJlc3RlZCBjaGFyYWN0ZXJzXHJcbiAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5hbGxvd2VkQXV0b1N0cmlwLCAnJyk7XHJcbiAgICAgICAgaWYgKHNldHRpbmdzLmFsdERlYykge1xyXG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLmFsdERlYywgc2V0dGluZ3MuYURlYyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBnZXQgb25seSBudW1iZXIgc3RyaW5nXHJcbiAgICAgICAgY29uc3QgbSA9IHMubWF0Y2goc2V0dGluZ3MubnVtUmVnQXV0b1N0cmlwKTtcclxuICAgICAgICBzID0gbSA/IFttWzFdLCBtWzJdLCBtWzNdXS5qb2luKCcnKSA6ICcnO1xyXG4gICAgICAgIGlmIChzZXR0aW5ncy5sWmVybyA9PT0gJ2FsbG93JyB8fCBzZXR0aW5ncy5sWmVybyA9PT0gJ2tlZXAnKSB7XHJcbiAgICAgICAgICAgIGxldCBuU2lnbiA9ICcnO1xyXG4gICAgICAgICAgICBjb25zdCBbaW50ZWdlclBhcnQsIGRlY2ltYWxQYXJ0XSA9IHMuc3BsaXQoc2V0dGluZ3MuYURlYyk7XHJcbiAgICAgICAgICAgIGxldCBtb2RpZmllZEludGVnZXJQYXJ0ID0gaW50ZWdlclBhcnQ7XHJcbiAgICAgICAgICAgIGlmIChjb250YWlucyhtb2RpZmllZEludGVnZXJQYXJ0LCBzZXR0aW5ncy5hTmVnKSkge1xyXG4gICAgICAgICAgICAgICAgblNpZ24gPSBzZXR0aW5ncy5hTmVnO1xyXG4gICAgICAgICAgICAgICAgbW9kaWZpZWRJbnRlZ2VyUGFydCA9IG1vZGlmaWVkSW50ZWdlclBhcnQucmVwbGFjZShzZXR0aW5ncy5hTmVnLCAnJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIHN0cmlwIGxlYWRpbmcgemVybyBvbiBwb3NpdGl2ZSB2YWx1ZSBpZiBuZWVkXHJcbiAgICAgICAgICAgIGlmIChuU2lnbiA9PT0gJycgJiYgbW9kaWZpZWRJbnRlZ2VyUGFydC5sZW5ndGggPiBzZXR0aW5ncy5tSW50UG9zICYmIG1vZGlmaWVkSW50ZWdlclBhcnQuY2hhckF0KDApID09PSAnMCcpIHtcclxuICAgICAgICAgICAgICAgIG1vZGlmaWVkSW50ZWdlclBhcnQgPSBtb2RpZmllZEludGVnZXJQYXJ0LnNsaWNlKDEpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBzdHJpcCBsZWFkaW5nIHplcm8gb24gbmVnYXRpdmUgdmFsdWUgaWYgbmVlZFxyXG4gICAgICAgICAgICBpZiAoblNpZ24gIT09ICcnICYmIG1vZGlmaWVkSW50ZWdlclBhcnQubGVuZ3RoID4gc2V0dGluZ3MubUludE5lZyAmJiBtb2RpZmllZEludGVnZXJQYXJ0LmNoYXJBdCgwKSA9PT0gJzAnKSB7XHJcbiAgICAgICAgICAgICAgICBtb2RpZmllZEludGVnZXJQYXJ0ID0gbW9kaWZpZWRJbnRlZ2VyUGFydC5zbGljZSgxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzID0gYCR7blNpZ259JHttb2RpZmllZEludGVnZXJQYXJ0fSR7aXNVbmRlZmluZWQoZGVjaW1hbFBhcnQpPycnOnNldHRpbmdzLmFEZWMgKyBkZWNpbWFsUGFydH1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHNldHRpbmdzLm9uT2ZmICYmIHNldHRpbmdzLmxaZXJvID09PSAnZGVueScpIHx8IChzZXR0aW5ncy5sWmVybyA9PT0gJ2FsbG93JyAmJiBzZXR0aW5ncy5vbk9mZiA9PT0gZmFsc2UpKSB7XHJcbiAgICAgICAgICAgIC8vIFVzaW5nIHRoaXMgcmVnZXggdmVyc2lvbiBgXiR7c2V0dGluZ3MuYU5lZ1JlZ0F1dG9TdHJpcH0wKihcXFxcZHwkKWAgZW50aXJlbHkgY2xlYXIgdGhlIGlucHV0IG9uIGJsdXJcclxuICAgICAgICAgICAgbGV0IHN0cmlwUmVnID0gYF4ke3NldHRpbmdzLmFOZWdSZWdBdXRvU3RyaXB9MCooXFxcXGQpYDtcclxuICAgICAgICAgICAgc3RyaXBSZWcgPSBuZXcgUmVnRXhwKHN0cmlwUmVnKTtcclxuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShzdHJpcFJlZywgJyQxJDInKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcGxhY2VzIG9yIHJlbW92ZXMgYnJhY2tldHMgb24gbmVnYXRpdmUgdmFsdWVzXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG5lZ2F0aXZlQnJhY2tldChzLCBzZXR0aW5ncykge1xyXG4gICAgICAgIGlmICgoc2V0dGluZ3MucFNpZ24gPT09ICdwJyAmJiBzZXR0aW5ncy5wTmVnID09PSAnbCcpIHx8IChzZXR0aW5ncy5wU2lnbiA9PT0gJ3MnICYmIHNldHRpbmdzLnBOZWcgPT09ICdwJykpIHtcclxuICAgICAgICAgICAgY29uc3QgW2ZpcnN0QnJhY2tldCwgbGFzdEJyYWNrZXRdID0gc2V0dGluZ3MubkJyYWNrZXQuc3BsaXQoJywnKTtcclxuICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5vbk9mZikge1xyXG4gICAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5hTmVnLCAnJyk7XHJcbiAgICAgICAgICAgICAgICBzID0gZmlyc3RCcmFja2V0ICsgcyArIGxhc3RCcmFja2V0O1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLm9uT2ZmICYmIHMuY2hhckF0KDApID09PSBmaXJzdEJyYWNrZXQpIHtcclxuICAgICAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoZmlyc3RCcmFja2V0LCBzZXR0aW5ncy5hTmVnKTtcclxuICAgICAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UobGFzdEJyYWNrZXQsICcnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBjb252ZXJ0IGxvY2FsZSBmb3JtYXQgdG8gSmF2YXNjcmlwdCBudW1lcmljIHN0cmluZ1xyXG4gICAgICogYWxsb3dzIGxvY2FsZSBkZWNpbWFsIHNlcGFyYXRvciB0byBiZSBhIHBlcmlvZCBvciBjb21tYSAtIG5vIHRob3VzYW5kIHNlcGFyYXRvciBhbGxvd2VkIG9mIGN1cnJlbmN5IHNpZ25zIGFsbG93ZWRcclxuICAgICAqICcxMjM0LjU2JyAgICBPS1xyXG4gICAgICogJy0xMjM0LjU2JyAgIE9LXHJcbiAgICAgKiAnMTIzNC41Ni0nICAgT0tcclxuICAgICAqICcxMjM0LDU2JyAgICBPS1xyXG4gICAgICogJy0xMjM0LDU2JyAgIE9LXHJcbiAgICAgKiAnMTIzNCw1Ni0nICAgT0tcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZnJvbUxvY2FsZShzKSB7XHJcbiAgICAgICAgcyA9IHMucmVwbGFjZSgnLCcsICcuJyk7XHJcbiAgICAgICAgaWYgKGNvbnRhaW5zKHMsICctJykgJiYgcy5sYXN0SW5kZXhPZignLScpID09PSBzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgcyA9IHMucmVwbGFjZSgnLScsICcnKTtcclxuICAgICAgICAgICAgcyA9ICctJyArIHM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIGNvbnZlcnRzIHRoZSBJU08gbnVtZXJpYyBzdHJpbmcgdG8gdGhlIGxvY2FsZSBkZWNpbWFsIGFuZCBtaW51cyBzaWduIHBsYWNlbWVudFxyXG4gICAgICogc2VlIFwibG9jYWxlT3V0cHV0XCIgb3B0aW9uIGZvciBkZXRlcm1pbmVcclxuICAgICAqIG51bGwgPT4gbm5ubi5ubiBvciAtbm5ubi5ubiBkZWZhdWx0XHJcbiAgICAgKiBcIixcIiAgPT4gbm5ubixubiBvciAtbm5ubixubiBjYW4gYWxzIGJlIFwiLSxcIlxyXG4gICAgICogXCIuLVwiID0+IG5ubm4ubm4gb3Igbm5ubi5ubi1cclxuICAgICAqIFwiLC1cIiA9PiBubm5uLG5uIG9yIG5ubm4sbm4tXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRvTG9jYWxlKHZhbHVlLCBsb2NhbGUpIHtcclxuICAgICAgICBpZiAobG9jYWxlID09PSAnLi0nKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gY29udGFpbnModmFsdWUsICctJykgPyB2YWx1ZS5yZXBsYWNlKCctJywgJycpICsgJy0nIDogdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsb2NhbGUgPT09ICcsJyB8fCBsb2NhbGUgPT09ICctLCcpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKCcuJywgJywnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxvY2FsZSA9PT0gJywtJykge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoJy4nLCAnLCcpO1xyXG4gICAgICAgICAgICB2YWx1ZSA9IGNvbnRhaW5zKHZhbHVlLCAnLScpID8gdmFsdWUucmVwbGFjZSgnLScsICcnKSArICctJyA6IHZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcHJlcGFyZSBudW1iZXIgc3RyaW5nIHRvIGJlIGNvbnZlcnRlZCB0byByZWFsIG51bWJlclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmaXhOdW1iZXIocywgYURlYywgYU5lZykge1xyXG4gICAgICAgIGlmIChhRGVjICYmIGFEZWMgIT09ICcuJykge1xyXG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKGFEZWMsICcuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhTmVnICYmIGFOZWcgIT09ICctJykge1xyXG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKGFOZWcsICctJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghcy5tYXRjaCgvXFxkLykpIHtcclxuICAgICAgICAgICAgcyArPSAnMCc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHByZXBhcmUgcmVhbCBudW1iZXIgdG8gYmUgY29udmVydGVkIHRvIG91ciBmb3JtYXRcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcHJlc2VudE51bWJlcihzLCBzZXR0aW5ncykge1xyXG4gICAgICAgIGlmIChzZXR0aW5ncy5hTmVnICYmIHNldHRpbmdzLmFOZWcgIT09ICctJykge1xyXG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKCctJywgc2V0dGluZ3MuYU5lZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzZXR0aW5ncy5hRGVjICYmIHNldHRpbmdzLmFEZWMgIT09ICcuJykge1xyXG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKCcuJywgc2V0dGluZ3MuYURlYyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHByaXZhdGUgZnVuY3Rpb24gdG8gY2hlY2sgZm9yIGVtcHR5IHZhbHVlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNoZWNrRW1wdHkoaXYsIHNldHRpbmdzLCBzaWduT25FbXB0eSkge1xyXG4gICAgICAgIGlmIChpdiA9PT0gJycgfHwgaXYgPT09IHNldHRpbmdzLmFOZWcpIHtcclxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLndFbXB0eSA9PT0gJ2Fsd2F5cycgfHwgc2lnbk9uRW1wdHkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoc2V0dGluZ3MucE5lZyA9PT0gJ2wnKSA/IGl2ICsgc2V0dGluZ3MuYVNpZ24gKyBzZXR0aW5ncy5hU3VmZml4IDogc2V0dGluZ3MuYVNpZ24gKyBpdiArIHNldHRpbmdzLmFTdWZmaXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGl2O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBwcml2YXRlIGZ1bmN0aW9uIHRoYXQgZm9ybWF0cyBvdXIgbnVtYmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGF1dG9Hcm91cChpdiwgc2V0dGluZ3MpIHtcclxuICAgICAgICBpZiAoc2V0dGluZ3Muc3RyaXApIHtcclxuICAgICAgICAgICAgaXYgPSBhdXRvU3RyaXAoaXYsIHNldHRpbmdzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNldHRpbmdzLnRyYWlsaW5nTmVnYXRpdmUgJiYgIWNvbnRhaW5zKGl2LCAnLScpKSB7XHJcbiAgICAgICAgICAgIGl2ID0gJy0nICsgaXY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGVtcHR5ID0gY2hlY2tFbXB0eShpdiwgc2V0dGluZ3MsIHRydWUpO1xyXG4gICAgICAgIGNvbnN0IGlzTmVnID0gY29udGFpbnMoaXYsICctJyk7XHJcbiAgICAgICAgaWYgKGlzTmVnKSB7XHJcbiAgICAgICAgICAgIGl2ID0gaXYucmVwbGFjZSgnLScsICcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVtcHR5ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlbXB0eTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGRpZ2l0YWxHcm91cCA9ICcnO1xyXG4gICAgICAgIHNldHRpbmdzLmRHcm91cCA9IHNldHRpbmdzLmRHcm91cC50b1N0cmluZygpO1xyXG4gICAgICAgIGlmIChzZXR0aW5ncy5kR3JvdXAgPT09ICcyJykge1xyXG4gICAgICAgICAgICBkaWdpdGFsR3JvdXAgPSAvKFxcZCkoKFxcZCkoXFxkezJ9PykrKSQvO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3MuZEdyb3VwID09PSAnMnMnKSB7XHJcbiAgICAgICAgICAgIGRpZ2l0YWxHcm91cCA9IC8oXFxkKSgoPzpcXGR7Mn0pezAsMn1cXGR7M30oPzooPzpcXGR7Mn0pezJ9XFxkezN9KSo/KSQvO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3MuZEdyb3VwID09PSAnNCcpIHtcclxuICAgICAgICAgICAgZGlnaXRhbEdyb3VwID0gLyhcXGQpKChcXGR7NH0/KSspJC87XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZGlnaXRhbEdyb3VwID0gLyhcXGQpKChcXGR7M30/KSspJC87XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBzcGxpdHMgdGhlIHN0cmluZyBhdCB0aGUgZGVjaW1hbCBzdHJpbmdcclxuICAgICAgICBsZXQgW2ludGVnZXJQYXJ0LCBkZWNpbWFsUGFydF0gPSBpdi5zcGxpdChzZXR0aW5ncy5hRGVjKTtcclxuICAgICAgICBpZiAoc2V0dGluZ3MuYWx0RGVjICYmIGlzVW5kZWZpbmVkKGRlY2ltYWxQYXJ0KSkge1xyXG4gICAgICAgICAgICBbaW50ZWdlclBhcnQsIGRlY2ltYWxQYXJ0XSA9IGl2LnNwbGl0KHNldHRpbmdzLmFsdERlYyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzZXR0aW5ncy5hU2VwICE9PSAnJykge1xyXG4gICAgICAgICAgICAvLyByZS1pbnNlcnRzIHRoZSB0aG91c2FuZCBzZXBhcmF0b3IgdmlhIGEgcmVndWxhciBleHByZXNzaW9uXHJcbiAgICAgICAgICAgIHdoaWxlIChkaWdpdGFsR3JvdXAudGVzdChpbnRlZ2VyUGFydCkpIHtcclxuICAgICAgICAgICAgICAgIGludGVnZXJQYXJ0ID0gaW50ZWdlclBhcnQucmVwbGFjZShkaWdpdGFsR3JvdXAsIGAkMSR7c2V0dGluZ3MuYVNlcH0kMmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzZXR0aW5ncy5tRGVjICE9PSAwICYmICFpc1VuZGVmaW5lZChkZWNpbWFsUGFydCkpIHtcclxuICAgICAgICAgICAgaWYgKGRlY2ltYWxQYXJ0Lmxlbmd0aCA+IHNldHRpbmdzLm1EZWMpIHtcclxuICAgICAgICAgICAgICAgIGRlY2ltYWxQYXJ0ID0gZGVjaW1hbFBhcnQuc3Vic3RyaW5nKDAsIHNldHRpbmdzLm1EZWMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBqb2lucyB0aGUgd2hvbGUgbnVtYmVyIHdpdGggdGhlIGRlY2ltYWwgdmFsdWVcclxuICAgICAgICAgICAgaXYgPSBpbnRlZ2VyUGFydCArIHNldHRpbmdzLmFEZWMgKyBkZWNpbWFsUGFydDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBpZiB3aG9sZSBudW1iZXJzIG9ubHlcclxuICAgICAgICAgICAgaXYgPSBpbnRlZ2VyUGFydDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNldHRpbmdzLnBTaWduID09PSAncCcpIHtcclxuICAgICAgICAgICAgaWYgKGlzTmVnICYmIHNldHRpbmdzLnBOZWcgPT09ICdsJykge1xyXG4gICAgICAgICAgICAgICAgaXYgPSBzZXR0aW5ncy5hTmVnICsgc2V0dGluZ3MuYVNpZ24gKyBpdjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNOZWcgJiYgc2V0dGluZ3MucE5lZyA9PT0gJ3InKSB7XHJcbiAgICAgICAgICAgICAgICBpdiA9IHNldHRpbmdzLmFTaWduICsgc2V0dGluZ3MuYU5lZyArIGl2O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc05lZyAmJiBzZXR0aW5ncy5wTmVnID09PSAncycpIHtcclxuICAgICAgICAgICAgICAgIGl2ID0gc2V0dGluZ3MuYVNpZ24gKyBpdiArIHNldHRpbmdzLmFOZWc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFpc05lZykge1xyXG4gICAgICAgICAgICAgICAgaXYgPSBzZXR0aW5ncy5hU2lnbiArIGl2O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzZXR0aW5ncy5wU2lnbiA9PT0gJ3MnKSB7XHJcbiAgICAgICAgICAgIGlmIChpc05lZyAmJiBzZXR0aW5ncy5wTmVnID09PSAncicpIHtcclxuICAgICAgICAgICAgICAgIGl2ID0gaXYgKyBzZXR0aW5ncy5hU2lnbiArIHNldHRpbmdzLmFOZWc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzTmVnICYmIHNldHRpbmdzLnBOZWcgPT09ICdsJykge1xyXG4gICAgICAgICAgICAgICAgaXYgPSBpdiArIHNldHRpbmdzLmFOZWcgKyBzZXR0aW5ncy5hU2lnbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNOZWcgJiYgc2V0dGluZ3MucE5lZyA9PT0gJ3AnKSB7XHJcbiAgICAgICAgICAgICAgICBpdiA9IHNldHRpbmdzLmFOZWcgKyBpdiArIHNldHRpbmdzLmFTaWduO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaXNOZWcpIHtcclxuICAgICAgICAgICAgICAgIGl2ID0gaXYgKyBzZXR0aW5ncy5hU2lnbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gcmVtb3ZlcyB0aGUgbmVnYXRpdmUgc2lnbiBhbmQgcGxhY2VzIGJyYWNrZXRzXHJcbiAgICAgICAgaWYgKHNldHRpbmdzLm5CcmFja2V0ICE9PSBudWxsICYmIChzZXR0aW5ncy5yYXdWYWx1ZSA8IDAgfHwgaXYuY2hhckF0KDApID09PSAnLScpKSB7XHJcbiAgICAgICAgICAgIGl2ID0gbmVnYXRpdmVCcmFja2V0KGl2LCBzZXR0aW5ncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldHRpbmdzLnRyYWlsaW5nTmVnYXRpdmUgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGl2ICsgc2V0dGluZ3MuYVN1ZmZpeDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRydW5jYXRlIG5vdCBuZWVkZWQgemVyb3NcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdHJ1bmNhdGVaZXJvcyhpdlJvdW5kZWQsIHJEZWMpIHtcclxuICAgICAgICBsZXQgcmVnZXg7XHJcbiAgICAgICAgc3dpdGNoIChyRGVjKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgIC8vIHByZXZlbnRzIHBhZGRpbmcgLSByZW1vdmVzIHRyYWlsaW5nIHplcm9zIHRvIHRoZSBmaXJzdCBzaWduaWZpY2FudCBkaWdpdFxyXG4gICAgICAgICAgICAgICAgcmVnZXggPSAvKFxcLig/OlxcZCpbMS05XSk/KTAqJC87XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgLy8gYWxsb3dzIHBhZGRpbmcgd2hlbiBtRGVjIGVxdWFscyBvbmUgLSBsZWF2ZXMgb25lIHplcm8gdHJhaWxpbmcgdGhlIGRlY2ltYWwgY2hhcmFjdGVyXHJcbiAgICAgICAgICAgICAgICByZWdleCA9IC8oXFwuXFxkKD86XFxkKlsxLTldKT8pMCokLztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0IDpcclxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZXMgYWNjZXNzIHplcm9zIHRvIHRoZSBtRGVjIGxlbmd0aCB3aGVuIGFQYWQgaXMgc2V0IHRydWVcclxuICAgICAgICAgICAgICAgIHJlZ2V4ID0gbmV3IFJlZ0V4cChgKFxcXFwuXFxcXGR7JHtyRGVjfX0oPzpcXFxcZCpbMS05XSk/KTAqYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gZGVjaW1hbCBwbGFjZXMsIHdlIGRvbid0IG5lZWQgYSBkZWNpbWFsIHBvaW50IGF0IHRoZSBlbmRcclxuICAgICAgICBpdlJvdW5kZWQgPSBpdlJvdW5kZWQucmVwbGFjZShyZWdleCwgJyQxJyk7XHJcbiAgICAgICAgaWYgKHJEZWMgPT09IDApIHtcclxuICAgICAgICAgICAgaXZSb3VuZGVkID0gaXZSb3VuZGVkLnJlcGxhY2UoL1xcLiQvLCAnJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gaXZSb3VuZGVkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcm91bmQgbnVtYmVyIGFmdGVyIHNldHRpbmcgYnkgcGFzdGluZyBvciAkKCkuYXV0b051bWVyaWNTZXQoKVxyXG4gICAgICogcHJpdmF0ZSBmdW5jdGlvbiBmb3Igcm91bmQgdGhlIG51bWJlclxyXG4gICAgICogcGxlYXNlIG5vdGUgdGhpcyBoYW5kbGVkIGFzIHRleHQgLSBKYXZhU2NyaXB0IG1hdGggZnVuY3Rpb24gY2FuIHJldHVybiBpbmFjY3VyYXRlIHZhbHVlc1xyXG4gICAgICogYWxzbyB0aGlzIG9mZmVycyBtdWx0aXBsZSByb3VuZGluZyBtZXRob2RzIHRoYXQgYXJlIG5vdCBlYXNpbHkgYWNjb21wbGlzaGVkIGluIEphdmFTY3JpcHRcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYXV0b1JvdW5kKGl2LCBzZXR0aW5ncykgeyAvLyB2YWx1ZSB0byBzdHJpbmdcclxuICAgICAgICBpdiA9IChpdiA9PT0gJycpID8gJzAnIDogaXYudG9TdHJpbmcoKTtcclxuICAgICAgICBpZiAoc2V0dGluZ3MubVJvdW5kID09PSAnTjA1JyB8fCBzZXR0aW5ncy5tUm91bmQgPT09ICdDSEYnIHx8IHNldHRpbmdzLm1Sb3VuZCA9PT0gJ1UwNScgfHwgc2V0dGluZ3MubVJvdW5kID09PSAnRDA1Jykge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLm1Sb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnTjA1JzpcclxuICAgICAgICAgICAgICAgICAgICBpdiA9IChNYXRoLnJvdW5kKGl2ICogMjApIC8gMjApLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdVMDUnOlxyXG4gICAgICAgICAgICAgICAgICAgIGl2ID0gKE1hdGguY2VpbChpdiAqIDIwKSAvIDIwKS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdCA6XHJcbiAgICAgICAgICAgICAgICAgICAgaXYgPSAoTWF0aC5mbG9vcihpdiAqIDIwKSAvIDIwKS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xyXG4gICAgICAgICAgICBpZiAoIWNvbnRhaW5zKGl2LCAnLicpKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpdiArICcuMDAnO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGl2Lmxlbmd0aCAtIGl2LmluZGV4T2YoJy4nKSA8IDMpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGl2ICsgJzAnO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaXY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBpdlJvdW5kZWQgPSAnJztcclxuICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgbGV0IG5TaWduID0gJyc7XHJcbiAgICAgICAgbGV0IHJEZWM7XHJcbiAgICAgICAgLy8gc2V0cyB0aGUgdHJ1bmNhdGUgemVybyBtZXRob2RcclxuICAgICAgICBpZiAoc2V0dGluZ3MuYVBhZCkge1xyXG4gICAgICAgICAgICByRGVjID0gc2V0dGluZ3MubURlYztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByRGVjID0gMFxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDaGVja3MgaWYgdGhlIGl2IChpbnB1dCBWYWx1ZSlpcyBhIG5lZ2F0aXZlIHZhbHVlXHJcbiAgICAgICAgaWYgKGl2LmNoYXJBdCgwKSA9PT0gJy0nKSB7XHJcbiAgICAgICAgICAgIG5TaWduID0gJy0nO1xyXG5cclxuICAgICAgICAgICAgLy8gcmVtb3ZlcyB0aGUgbmVnYXRpdmUgc2lnbiB3aWxsIGJlIGFkZGVkIGJhY2sgbGF0ZXIgaWYgcmVxdWlyZWRcclxuICAgICAgICAgICAgaXYgPSBpdi5yZXBsYWNlKCctJywgJycpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gYXBwZW5kIGEgemVybyBpZiBmaXJzdCBjaGFyYWN0ZXIgaXMgbm90IGEgZGlnaXQgKHRoZW4gaXQgaXMgbGlrZWx5IHRvIGJlIGEgZG90XHJcbiAgICAgICAgaWYgKCFpdi5tYXRjaCgvXlxcZC8pKSB7XHJcbiAgICAgICAgICAgIGl2ID0gJzAnICsgaXY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBkZXRlcm1pbmVzIGlmIHRoZSB2YWx1ZSBpcyB6ZXJvIC0gaWYgemVybyBubyBuZWdhdGl2ZSBzaWduXHJcbiAgICAgICAgaWYgKG5TaWduID09PSAnLScgJiYgTnVtYmVyKGl2KSA9PT0gMCkge1xyXG4gICAgICAgICAgICBuU2lnbiA9ICcnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gdHJpbXMgbGVhZGluZyB6ZXJvJ3MgbmVlZGVkXHJcbiAgICAgICAgaWYgKChOdW1iZXIoaXYpID4gMCAmJiBzZXR0aW5ncy5sWmVybyAhPT0gJ2tlZXAnKSB8fCAoaXYubGVuZ3RoID4gMCAmJiBzZXR0aW5ncy5sWmVybyA9PT0gJ2FsbG93JykpIHtcclxuICAgICAgICAgICAgaXYgPSBpdi5yZXBsYWNlKC9eMCooXFxkKS8sICckMScpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgZFBvcyA9IGl2Lmxhc3RJbmRleE9mKCcuJyk7XHJcblxyXG4gICAgICAgIC8vIHZpcnR1YWwgZGVjaW1hbCBwb3NpdGlvblxyXG4gICAgICAgIGNvbnN0IHZkUG9zID0gKGRQb3MgPT09IC0xKSA/IGl2Lmxlbmd0aCAtIDEgOiBkUG9zO1xyXG5cclxuICAgICAgICAvLyBjaGVja3MgZGVjaW1hbCBwbGFjZXMgdG8gZGV0ZXJtaW5lIGlmIHJvdW5kaW5nIGlzIHJlcXVpcmVkIDpcclxuICAgICAgICAvLyBjaGVjayBpZiBubyByb3VuZGluZyBpcyByZXF1aXJlZFxyXG4gICAgICAgIGxldCBjRGVjID0gKGl2Lmxlbmd0aCAtIDEpIC0gdmRQb3M7XHJcbiAgICAgICAgaWYgKGNEZWMgPD0gc2V0dGluZ3MubURlYykge1xyXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIHBhZCB3aXRoIHplcm9zXHJcbiAgICAgICAgICAgIGl2Um91bmRlZCA9IGl2O1xyXG4gICAgICAgICAgICBpZiAoY0RlYyA8IHJEZWMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkUG9zID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGl2Um91bmRlZCArPSBzZXR0aW5ncy5hRGVjO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IHplcm9zID0gJzAwMDAwMCc7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoY0RlYyA8IHJEZWMpIHtcclxuICAgICAgICAgICAgICAgICAgICB6ZXJvcyA9IHplcm9zLnN1YnN0cmluZygwLCByRGVjIC0gY0RlYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaXZSb3VuZGVkICs9IHplcm9zO1xyXG4gICAgICAgICAgICAgICAgICAgIGNEZWMgKz0gemVyb3MubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNEZWMgPiByRGVjKSB7XHJcbiAgICAgICAgICAgICAgICBpdlJvdW5kZWQgPSB0cnVuY2F0ZVplcm9zKGl2Um91bmRlZCwgckRlYyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY0RlYyA9PT0gMCAmJiByRGVjID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBpdlJvdW5kZWQgPSBpdlJvdW5kZWQucmVwbGFjZSgvXFwuJC8sICcnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIChOdW1iZXIoaXZSb3VuZGVkKSA9PT0gMCkgPyBpdlJvdW5kZWQgOiBuU2lnbiArIGl2Um91bmRlZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHJvdW5kZWQgbGVuZ3RoIG9mIHRoZSBzdHJpbmcgYWZ0ZXIgcm91bmRpbmdcclxuICAgICAgICBjb25zdCByTGVuZ3RoID0gZFBvcyArIHNldHRpbmdzLm1EZWM7IC8vVE9ETyBNb2RpZnkgYGRQb3NgIGhlcmUgaWYgaXQncyBub3QgaW50ZW5kZWQgdGhhdCBpdCBjYW4gYmUgZXF1YWwgdG8gJy0xJ1xyXG4gICAgICAgIGNvbnN0IHRSb3VuZCA9IE51bWJlcihpdi5jaGFyQXQockxlbmd0aCArIDEpKTtcclxuICAgICAgICBjb25zdCBvZGQgPSAoaXYuY2hhckF0KHJMZW5ndGgpID09PSAnLicpID8gKGl2LmNoYXJBdChyTGVuZ3RoIC0gMSkgJSAyKSA6IChpdi5jaGFyQXQockxlbmd0aCkgJSAyKTtcclxuICAgICAgICBsZXQgaXZBcnJheSA9IGl2LnN1YnN0cmluZygwLCByTGVuZ3RoICsgMSkuc3BsaXQoJycpO1xyXG4gICAgICAgIGlmICgodFJvdW5kID4gNCAmJiBzZXR0aW5ncy5tUm91bmQgPT09ICdTJykgICAgICAgICAgICAgICAgICB8fCAvLyBSb3VuZCBoYWxmIHVwIHN5bW1ldHJpY1xyXG4gICAgICAgICAgICAodFJvdW5kID4gNCAmJiBzZXR0aW5ncy5tUm91bmQgPT09ICdBJyAmJiBuU2lnbiA9PT0gJycpICB8fCAvLyBSb3VuZCBoYWxmIHVwIGFzeW1tZXRyaWMgcG9zaXRpdmUgdmFsdWVzXHJcbiAgICAgICAgICAgICh0Um91bmQgPiA1ICYmIHNldHRpbmdzLm1Sb3VuZCA9PT0gJ0EnICYmIG5TaWduID09PSAnLScpIHx8IC8vIFJvdW5kIGhhbGYgdXAgYXN5bW1ldHJpYyBuZWdhdGl2ZSB2YWx1ZXNcclxuICAgICAgICAgICAgKHRSb3VuZCA+IDUgJiYgc2V0dGluZ3MubVJvdW5kID09PSAncycpICAgICAgICAgICAgICAgICAgfHwgLy8gUm91bmQgaGFsZiBkb3duIHN5bW1ldHJpY1xyXG4gICAgICAgICAgICAodFJvdW5kID4gNSAmJiBzZXR0aW5ncy5tUm91bmQgPT09ICdBJyAmJiBuU2lnbiA9PT0gJycpICB8fCAvLyBSb3VuZCBoYWxmIGRvd24gYXN5bW1ldHJpYyBwb3NpdGl2ZSB2YWx1ZXNcclxuICAgICAgICAgICAgKHRSb3VuZCA+IDQgJiYgc2V0dGluZ3MubVJvdW5kID09PSAnQScgJiYgblNpZ24gPT09ICctJykgfHwgLy8gUm91bmQgaGFsZiBkb3duIGFzeW1tZXRyaWMgbmVnYXRpdmUgdmFsdWVzXHJcbiAgICAgICAgICAgICh0Um91bmQgPiA1ICYmIHNldHRpbmdzLm1Sb3VuZCA9PT0gJ0InKSAgICAgICAgICAgICAgICAgIHx8IC8vIFJvdW5kIGhhbGYgZXZlbiBcIkJhbmtlcidzIFJvdW5kaW5nXCJcclxuICAgICAgICAgICAgKHRSb3VuZCA9PT0gNSAmJiBzZXR0aW5ncy5tUm91bmQgPT09ICdCJyAmJiBvZGQgPT09IDEpICAgfHwgLy8gUm91bmQgaGFsZiBldmVuIFwiQmFua2VyJ3MgUm91bmRpbmdcIlxyXG4gICAgICAgICAgICAodFJvdW5kID4gMCAmJiBzZXR0aW5ncy5tUm91bmQgPT09ICdDJyAmJiBuU2lnbiA9PT0gJycpICB8fCAvLyBSb3VuZCB0byBjZWlsaW5nIHRvd2FyZCBwb3NpdGl2ZSBpbmZpbml0ZVxyXG4gICAgICAgICAgICAodFJvdW5kID4gMCAmJiBzZXR0aW5ncy5tUm91bmQgPT09ICdGJyAmJiBuU2lnbiA9PT0gJy0nKSB8fCAvLyBSb3VuZCB0byBmbG9vciB0b3dhcmQgbmVnYXRpdmUgaW5maW5pdGVcclxuICAgICAgICAgICAgKHRSb3VuZCA+IDAgJiYgc2V0dGluZ3MubVJvdW5kID09PSAnVScpKSB7ICAgICAgICAgICAgICAgICAgLy8gUm91bmQgdXAgYXdheSBmcm9tIHplcm9cclxuICAgICAgICAgICAgLy8gUm91bmQgdXAgdGhlIGxhc3QgZGlnaXQgaWYgcmVxdWlyZWQsIGFuZCBjb250aW51ZSB1bnRpbCBubyBtb3JlIDkncyBhcmUgZm91bmRcclxuICAgICAgICAgICAgZm9yIChpID0gKGl2QXJyYXkubGVuZ3RoIC0gMSk7IGkgPj0gMDsgaSAtPSAxKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXZBcnJheVtpXSAhPT0gJy4nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXZBcnJheVtpXSA9ICtpdkFycmF5W2ldICsgMTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXZBcnJheVtpXSA8IDEwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXZBcnJheVtpXSA9ICcwJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlY29uc3RydWN0IHRoZSBzdHJpbmcsIGNvbnZlcnRpbmcgYW55IDEwJ3MgdG8gMCdzXHJcbiAgICAgICAgaXZBcnJheSA9IGl2QXJyYXkuc2xpY2UoMCwgckxlbmd0aCArIDEpO1xyXG5cclxuICAgICAgICAvLyByZXR1cm4gcm91bmRlZCB2YWx1ZVxyXG4gICAgICAgIGl2Um91bmRlZCA9IHRydW5jYXRlWmVyb3MoaXZBcnJheS5qb2luKCcnKSwgckRlYyk7XHJcblxyXG4gICAgICAgIHJldHVybiAoTnVtYmVyKGl2Um91bmRlZCkgPT09IDApID8gaXZSb3VuZGVkIDogblNpZ24gKyBpdlJvdW5kZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiB0cnVuY2F0ZXMgdGhlIGRlY2ltYWwgcGFydCBvZiBhIG51bWJlclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0cnVuY2F0ZURlY2ltYWwocywgc2V0dGluZ3MsIHBhc3RlKSB7XHJcbiAgICAgICAgY29uc3QgYURlYyA9IHNldHRpbmdzLmFEZWM7XHJcbiAgICAgICAgY29uc3QgbURlYyA9IHNldHRpbmdzLm1EZWM7XHJcbiAgICAgICAgcyA9IChwYXN0ZSA9PT0gJ3Bhc3RlJykgPyBhdXRvUm91bmQocywgc2V0dGluZ3MpIDogcztcclxuICAgICAgICBpZiAoYURlYyAmJiBtRGVjKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IFtpbnRlZ2VyUGFydCwgZGVjaW1hbFBhcnRdID0gcy5zcGxpdChhRGVjKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHRydW5jYXRlIGRlY2ltYWwgcGFydCB0byBzYXRpc2Z5aW5nIGxlbmd0aCBzaW5jZSB3ZSB3b3VsZCByb3VuZCBpdCBhbnl3YXlcclxuICAgICAgICAgICAgaWYgKGRlY2ltYWxQYXJ0ICYmIGRlY2ltYWxQYXJ0Lmxlbmd0aCA+IG1EZWMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChtRGVjID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkRGVjaW1hbFBhcnQgPSBkZWNpbWFsUGFydC5zdWJzdHJpbmcoMCwgbURlYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcyA9IGAke2ludGVnZXJQYXJ0fSR7YURlY30ke21vZGlmaWVkRGVjaW1hbFBhcnR9YDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcyA9IGludGVnZXJQYXJ0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZ1bmN0aW9uIHRvIHBhcnNlIHZNaW4sIHZNYXggJiB0aGUgaW5wdXQgdmFsdWUgdG8gcHJlcGFyZSBmb3IgdGVzdGluZyB0byBkZXRlcm1pbmUgaWYgdGhlIHZhbHVlIGZhbGxzIHdpdGhpbiB0aGUgbWluIC8gbWF4IHJhbmdlXHJcbiAgICAgKiBSZXR1cm4gYW4gb2JqZWN0IGV4YW1wbGU6IHZNaW46IFwiOTk5OTk5OTk5OTk5OTk5Ljk5XCIgcmV0dXJucyB0aGUgZm9sbG93aW5nIFwie3M6IC0xLCBlOiAxMiwgYzogQXJyYXlbMTVdfVwiXHJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGFkYXB0ZWQgZnJvbSBCaWcuanMgaHR0cHM6Ly9naXRodWIuY29tL01pa2VNY2wvYmlnLmpzL1xyXG4gICAgICogTWFueSB0aGFua3MgdG8gTWlrZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBwYXJzZVN0cihuKSB7XHJcbiAgICAgICAgY29uc3QgeCA9IHt9O1xyXG4gICAgICAgIGxldCBlO1xyXG4gICAgICAgIGxldCBpO1xyXG4gICAgICAgIGxldCBuTDtcclxuICAgICAgICBsZXQgajtcclxuXHJcbiAgICAgICAgLy8gTWludXMgemVybz9cclxuICAgICAgICBpZiAobiA9PT0gMCAmJiAxIC8gbiA8IDApIHtcclxuICAgICAgICAgICAgbiA9ICctMCc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEZXRlcm1pbmUgc2lnbi4gMSBwb3NpdGl2ZSwgLTEgbmVnYXRpdmVcclxuICAgICAgICBuID0gbi50b1N0cmluZygpO1xyXG4gICAgICAgIGlmIChuLmNoYXJBdCgwKSA9PT0gJy0nKSB7XHJcbiAgICAgICAgICAgIG4gPSBuLnNsaWNlKDEpO1xyXG4gICAgICAgICAgICB4LnMgPSAtMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB4LnMgPSAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRGVjaW1hbCBwb2ludD9cclxuICAgICAgICBlID0gbi5pbmRleE9mKCcuJyk7XHJcbiAgICAgICAgaWYgKGUgPiAtMSkge1xyXG4gICAgICAgICAgICBuID0gbi5yZXBsYWNlKCcuJywgJycpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gbGVuZ3RoIG9mIHN0cmluZyBpZiBubyBkZWNpbWFsIGNoYXJhY3RlclxyXG4gICAgICAgIGlmIChlIDwgMCkge1xyXG4gICAgICAgICAgICAvLyBJbnRlZ2VyXHJcbiAgICAgICAgICAgIGUgPSBuLmxlbmd0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERldGVybWluZSBsZWFkaW5nIHplcm9zXHJcbiAgICAgICAgaSA9IChuLnNlYXJjaCgvWzEtOV0vaSkgPT09IC0xKSA/IG4ubGVuZ3RoIDogbi5zZWFyY2goL1sxLTldL2kpO1xyXG4gICAgICAgIG5MID0gbi5sZW5ndGg7XHJcbiAgICAgICAgaWYgKGkgPT09IG5MKSB7XHJcbiAgICAgICAgICAgIC8vIFplcm9cclxuICAgICAgICAgICAgeC5lID0gMDtcclxuICAgICAgICAgICAgeC5jID0gWzBdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvc1xyXG4gICAgICAgICAgICBmb3IgKGogPSBuTCAtIDE7IG4uY2hhckF0KGopID09PSAnMCc7IGogLT0gMSkge1xyXG4gICAgICAgICAgICAgICAgbkwgLT0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuTCAtPSAxO1xyXG5cclxuICAgICAgICAgICAgLy8gRGVjaW1hbCBsb2NhdGlvblxyXG4gICAgICAgICAgICB4LmUgPSBlIC0gaSAtIDE7XHJcbiAgICAgICAgICAgIHguYyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29udmVydCBzdHJpbmcgdG8gYXJyYXkgb2YgZGlnaXRzIHdpdGhvdXQgbGVhZGluZy90cmFpbGluZyB6ZXJvc1xyXG4gICAgICAgICAgICBmb3IgKGUgPSAwOyBpIDw9IG5MOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgICAgIHguY1tlXSA9ICtuLmNoYXJBdChpKTtcclxuICAgICAgICAgICAgICAgIGUgKz0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGdW5jdGlvbiB0byB0ZXN0IGlmIHRoZSBpbnB1dCB2YWx1ZSBmYWxscyB3aXRoIHRoZSBNaW4gLyBNYXggc2V0dGluZ3NcclxuICAgICAqIFRoaXMgdXNlcyB0aGUgcGFyc2VkIHN0cmluZ3MgZm9yIHRoZSBhYm92ZSBwYXJzZVN0ciBmdW5jdGlvblxyXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBhZGFwdGVkIGZyb20gQmlnLmpzIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWtlTWNsL2JpZy5qcy9cclxuICAgICAqIE1hbnkgdGhhbmtzIHRvIE1pa2VcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdGVzdE1pbk1heCh5LCB4KSB7XHJcbiAgICAgICAgY29uc3QgeGMgPSB4LmM7XHJcbiAgICAgICAgY29uc3QgeWMgPSB5LmM7XHJcbiAgICAgICAgbGV0IGkgPSB4LnM7XHJcbiAgICAgICAgbGV0IGogPSB5LnM7XHJcbiAgICAgICAgbGV0IGsgPSB4LmU7XHJcbiAgICAgICAgbGV0IGwgPSB5LmU7XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciB6ZXJvP1xyXG4gICAgICAgIGlmICgheGNbMF0gfHwgIXljWzBdKSB7XHJcbiAgICAgICAgICAgIGxldCByZXN1bHQ7XHJcbiAgICAgICAgICAgIGlmICgheGNbMF0pIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9ICF5Y1swXT8wOi1qO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gICAgICAgIGlmIChpICE9PSBqKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB4TmVnID0gaSA8IDA7XHJcblxyXG4gICAgICAgIC8vIENvbXBhcmUgZXhwb25lbnRzXHJcbiAgICAgICAgaWYgKGsgIT09IGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChrID4gbCBeIHhOZWcpPzE6LTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGkgPSAtMTtcclxuICAgICAgICBrID0geGMubGVuZ3RoO1xyXG4gICAgICAgIGwgPSB5Yy5sZW5ndGg7XHJcbiAgICAgICAgaiA9IChrIDwgbCkgPyBrIDogbDtcclxuXHJcbiAgICAgICAgLy8gQ29tcGFyZSBkaWdpdCBieSBkaWdpdFxyXG4gICAgICAgIGZvciAoaSArPSAxOyBpIDwgajsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgIGlmICh4Y1tpXSAhPT0geWNbaV0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoeGNbaV0gPiB5Y1tpXSBeIHhOZWcpPzE6LTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENvbXBhcmUgbGVuZ3Roc1xyXG4gICAgICAgIGxldCByZXN1bHQ7XHJcbiAgICAgICAgaWYgKGsgPT09IGwpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gMDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHQgPSAoayA+IGwgXiB4TmVnKT8xOi0xO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIGNoZWNraW5nIHRoYXQgbnVtYmVyIHNhdGlzZnkgZm9ybWF0IGNvbmRpdGlvbnNcclxuICAgICAqIGFuZCBsYXlzIGJldHdlZW4gc2V0dGluZ3Mudk1pbiBhbmQgc2V0dGluZ3Mudk1heFxyXG4gICAgICogYW5kIHRoZSBzdHJpbmcgbGVuZ3RoIGRvZXMgbm90IGV4Y2VlZCB0aGUgZGlnaXRzIGluIHNldHRpbmdzLnZNaW4gYW5kIHNldHRpbmdzLnZNYXhcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYXV0b0NoZWNrKHMsIHNldHRpbmdzKSB7XHJcbiAgICAgICAgcyA9IHMudG9TdHJpbmcoKTtcclxuICAgICAgICBzID0gcy5yZXBsYWNlKCcsJywgJy4nKTtcclxuICAgICAgICBjb25zdCBtaW5QYXJzZSA9IHBhcnNlU3RyKHNldHRpbmdzLnZNaW4pO1xyXG4gICAgICAgIGNvbnN0IG1heFBhcnNlID0gcGFyc2VTdHIoc2V0dGluZ3Mudk1heCk7XHJcbiAgICAgICAgY29uc3QgdmFsUGFyc2UgPSBwYXJzZVN0cihzKTtcclxuXHJcbiAgICAgICAgbGV0IHJlc3VsdDtcclxuICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLm9MaW1pdHMpIHtcclxuICAgICAgICAgICAgY2FzZSAnZmxvb3InOlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW3Rlc3RNaW5NYXgobWluUGFyc2UsIHZhbFBhcnNlKSA+IC0xLCB0cnVlXTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdjZWlsaW5nJzpcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFt0cnVlLCB0ZXN0TWluTWF4KG1heFBhcnNlLCB2YWxQYXJzZSkgPCAxXTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdpZ25vcmUnOlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW3RydWUsIHRydWVdO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbdGVzdE1pbk1heChtaW5QYXJzZSwgdmFsUGFyc2UpID4gLTEsIHRlc3RNaW5NYXgobWF4UGFyc2UsIHZhbFBhcnNlKSA8IDFdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHRoYW5rcyB0byBBbnRob255ICYgRXZhbiBDXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGF1dG9HZXQob2JqKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnIHx8IG9iaiBpbnN0YW5jZW9mIFN0cmluZykge1xyXG4gICAgICAgICAgICBvYmogPSBvYmoucmVwbGFjZSgvXFxbL2csICdcXFxcWycpLnJlcGxhY2UoL10vZywgJ1xcXFxdJyk7XHJcbiAgICAgICAgICAgIG9iaiA9ICcjJyArIG9iai5yZXBsYWNlKC8oOnxcXC4pL2csICdcXFxcJDEnKTtcclxuICAgICAgICAgICAgLy8gcG9zc2libGUgbW9kaWZpY2F0aW9uIHRvIHJlcGxhY2UgdGhlIGFib3ZlIDIgbGluZXNcclxuICAgICAgICAgICAgLy8gb2JqID0gJyMnICsgb2JqLnJlcGxhY2UoLyhbOyYsXFwuXFwrXFwqXFx+JzpcIlxcIVxcXiMkJUBcXFtcXF1cXChcXCk9PlxcfF0pL2csICdcXFxcJDEnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAkKG9iaik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBmdW5jdGlvbiB0byBhdHRhY2ggZGF0YSB0byB0aGUgZWxlbWVudFxyXG4gICAgICogYW5kIGltaXRhdGUgdGhlIGhvbGRlclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRIb2xkZXIoJHRoYXQsIHNldHRpbmdzLCB1cGRhdGUpIHtcclxuICAgICAgICBsZXQgZGF0YSA9ICR0aGF0LmRhdGEoJ2F1dG9OdW1lcmljJyk7XHJcbiAgICAgICAgaWYgKCFkYXRhKSB7XHJcbiAgICAgICAgICAgIGRhdGEgPSB7fTtcclxuICAgICAgICAgICAgJHRoYXQuZGF0YSgnYXV0b051bWVyaWMnLCBkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGhvbGRlciA9IGRhdGEuaG9sZGVyO1xyXG4gICAgICAgIGlmICgoaXNVbmRlZmluZWQoaG9sZGVyKSAmJiBzZXR0aW5ncykgfHwgdXBkYXRlKSB7XHJcbiAgICAgICAgICAgIGhvbGRlciA9IG5ldyBBdXRvTnVtZXJpY0hvbGRlcigkdGhhdC5nZXQoMCksIHNldHRpbmdzKTtcclxuICAgICAgICAgICAgZGF0YS5ob2xkZXIgPSBob2xkZXI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gaG9sZGVyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogb3JpZ2luYWwgc2V0dGluZ3Mgc2F2ZWQgZm9yIHVzZSB3aGVuIGVEZWMgJiBuU2VwIG9wdGlvbnMgYXJlIGJlaW5nIHVzZWRcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gb3JpZ2luYWxTZXR0aW5ncyhzZXR0aW5ncykge1xyXG4gICAgICAgIHNldHRpbmdzLm9EZWMgICAgID0gc2V0dGluZ3MubURlYztcclxuICAgICAgICBzZXR0aW5ncy5vUGFkICAgICA9IHNldHRpbmdzLmFQYWQ7XHJcbiAgICAgICAgc2V0dGluZ3Mub0JyYWNrZXQgPSBzZXR0aW5ncy5uQnJhY2tldDtcclxuICAgICAgICBzZXR0aW5ncy5vU2VwICAgICA9IHNldHRpbmdzLmFTZXA7XHJcbiAgICAgICAgc2V0dGluZ3Mub1NpZ24gICAgPSBzZXR0aW5ncy5hU2lnbjtcclxuICAgICAgICBzZXR0aW5ncy5vU3VmZml4ICA9IHNldHRpbmdzLmFTdWZmaXhcclxuXHJcbiAgICAgICAgcmV0dXJuIHNldHRpbmdzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogb3JpZ2luYWwgc2V0dGluZ3Mgc2F2ZWQgZm9yIHVzZSB3aGVuIGVEZWMgb3B0aW9ucyBhcmUgYmVpbmcgdXNlZFxyXG4gICAgICogdGFrZW4gZnJvbSBRdWlya3Ntb2RlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHJlYWRDb29raWUobmFtZSkge1xyXG4gICAgICAgIGNvbnN0IG5hbWVFUSA9IG5hbWUgKyAnPSc7XHJcbiAgICAgICAgY29uc3QgY2EgPSBkb2N1bWVudC5jb29raWUuc3BsaXQoJzsnKTtcclxuICAgICAgICBsZXQgYyA9ICcnO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2EubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgYyA9IGNhW2ldO1xyXG4gICAgICAgICAgICB3aGlsZSAoYy5jaGFyQXQoMCkgPT09ICcgJykge1xyXG4gICAgICAgICAgICAgICAgYyA9IGMuc3Vic3RyaW5nKDEsIGMubGVuZ3RoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYy5pbmRleE9mKG5hbWVFUSkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjLnN1YnN0cmluZyhuYW1lRVEubGVuZ3RoLCBjLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdCBpZiBzZXNzaW9uU3RvcmFnZSBpcyBzdXBwb3J0ZWQgLSB0YWtlbiBmcm9tIG1vZGVybml6clxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBzdG9yYWdlVGVzdCgpIHtcclxuICAgICAgICBjb25zdCBtb2QgPSAnbW9kZXJuaXpyJztcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKG1vZCwgbW9kKTtcclxuICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShtb2QpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBjcmVhdGVzIG9yIHJlbW92ZXMgc2Vzc2lvblN0b3JhZ2Ugb3IgY29va2llIGRlcGVuZGluZyBvbiBicm93c2VyIHN1cHBvcnRcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYXV0b1NhdmUoJHRoaXMsIHNldHRpbmdzLCB0b0RvKSB7XHJcbiAgICAgICAgaWYgKHNldHRpbmdzLmFTdG9yKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0b3JlZE5hbWUgPSAoJHRoaXNbMF0ubmFtZSAhPT0gJycgJiYgIWlzVW5kZWZpbmVkKCR0aGlzWzBdLm5hbWUpKSA/YEFVVE9fJHtkZWNvZGVVUklDb21wb25lbnQoJHRoaXNbMF0ubmFtZSl9YCA6YEFVVE9fJHskdGhpc1swXS5pZH1gO1xyXG4gICAgICAgICAgICBsZXQgZGF0ZTtcclxuICAgICAgICAgICAgbGV0IGV4cGlyZXM7XHJcblxyXG4gICAgICAgICAgICAvLyBzZXRzIGNvb2tpZSBmb3IgYnJvd3NlciB0aGF0IGRvIG5vdCBzdXBwb3J0IHNlc3Npb25TdG9yYWdlIElFIDYgJiBJRSA3XHJcbiAgICAgICAgICAgIGlmIChzdG9yYWdlVGVzdCgpID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoICh0b0RvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2V0JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY29va2llID0gYCR7c3RvcmVkTmFtZX09JHtzZXR0aW5ncy5yYXdWYWx1ZX07IGV4cGlyZXM9IDsgcGF0aD0vYDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnd2lwZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlLnNldFRpbWUoZGF0ZS5nZXRUaW1lKCkgKyAoLTEgKiAyNCAqIDYwICogNjAgKiAxMDAwKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGlyZXMgPSAnOyBleHBpcmVzPScgKyBkYXRlLnRvVVRDU3RyaW5nKCk7IC8vIE5vdGUgOiBgdG9HTVRTdHJpbmcoKWAgaGFzIGJlZW4gZGVwcmVjYXRlZCAoY2YuIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGUvdG9HTVRTdHJpbmcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGAke3N0b3JlZE5hbWV9PScnIDske2V4cGlyZXN9OyBwYXRoPS9gO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdnZXQnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVhZENvb2tpZShzdG9yZWROYW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAodG9Ebykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NldCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oc3RvcmVkTmFtZSwgc2V0dGluZ3MucmF3VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICd3aXBlJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShzdG9yZWROYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZ2V0JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oc3RvcmVkTmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIb2xkZXIgb2JqZWN0IGZvciBmaWVsZCBwcm9wZXJ0aWVzXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEF1dG9OdW1lcmljSG9sZGVyKHRoYXQsIHNldHRpbmdzKSB7XHJcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xyXG4gICAgICAgIHRoaXMudGhhdCA9IHRoYXQ7XHJcbiAgICAgICAgdGhpcy4kdGhhdCA9ICQodGhhdCk7XHJcbiAgICAgICAgdGhpcy5mb3JtYXR0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnNldHRpbmdzQ2xvbmUgPSBhdXRvQ29kZSh0aGlzLiR0aGF0LCB0aGlzLnNldHRpbmdzKTtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdGhhdC52YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBBdXRvTnVtZXJpY0hvbGRlci5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgaW5pdChlKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnRoYXQudmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3NDbG9uZSA9IGF1dG9Db2RlKHRoaXMuJHRoYXQsIHRoaXMuc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICB0aGlzLmN0cmxLZXkgPSBlLmN0cmxLZXk7XHJcbiAgICAgICAgICAgIHRoaXMuY21kS2V5ID0gZS5tZXRhS2V5O1xyXG4gICAgICAgICAgICB0aGlzLnNoaWZ0S2V5ID0gZS5zaGlmdEtleTtcclxuXHJcbiAgICAgICAgICAgIC8vIGtleXByZXNzIGV2ZW50IG92ZXJ3cml0ZXMgbWVhbmluZ2Z1bCB2YWx1ZSBvZiBlLmtleUNvZGVcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBnZXRFbGVtZW50U2VsZWN0aW9uKHRoaXMudGhhdCk7XHJcbiAgICAgICAgICAgIGlmIChlLnR5cGUgPT09ICdrZXlkb3duJyB8fCBlLnR5cGUgPT09ICdrZXl1cCcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMua2RDb2RlID0gZS5rZXlDb2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMud2hpY2ggPSBlLndoaWNoO1xyXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmZvcm1hdHRlZCA9IGZhbHNlO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldFNlbGVjdGlvbihzdGFydCwgZW5kLCBzZXRSZWFsKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoc3RhcnQsIDApO1xyXG4gICAgICAgICAgICBlbmQgPSBNYXRoLm1pbihlbmQsIHRoaXMudGhhdC52YWx1ZS5sZW5ndGgpO1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgZW5kLFxyXG4gICAgICAgICAgICAgICAgbGVuZ3RoOiBlbmQgLSBzdGFydCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHNldFJlYWwpIHx8IHNldFJlYWwpIHtcclxuICAgICAgICAgICAgICAgIHNldEVsZW1lbnRTZWxlY3Rpb24odGhpcy50aGF0LCBzdGFydCwgZW5kKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldFBvc2l0aW9uKHBvcywgc2V0UmVhbCkge1xyXG4gICAgICAgICAgICB0aGlzLnNldFNlbGVjdGlvbihwb3MsIHBvcywgc2V0UmVhbCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZ2V0QmVmb3JlQWZ0ZXIoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy52YWx1ZTtcclxuICAgICAgICAgICAgY29uc3QgbGVmdCA9IHZhbHVlLnN1YnN0cmluZygwLCB0aGlzLnNlbGVjdGlvbi5zdGFydCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gdmFsdWUuc3Vic3RyaW5nKHRoaXMuc2VsZWN0aW9uLmVuZCwgdmFsdWUubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBbbGVmdCwgcmlnaHRdO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGdldEJlZm9yZUFmdGVyU3RyaXBlZCgpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcclxuICAgICAgICAgICAgbGV0IFtsZWZ0LCByaWdodF0gPSB0aGlzLmdldEJlZm9yZUFmdGVyKCk7XHJcbiAgICAgICAgICAgIGxlZnQgPSBhdXRvU3RyaXAobGVmdCwgdGhpcy5zZXR0aW5nc0Nsb25lKTtcclxuICAgICAgICAgICAgcmlnaHQgPSBhdXRvU3RyaXAocmlnaHQsIHRoaXMuc2V0dGluZ3NDbG9uZSk7XHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLnRyYWlsaW5nTmVnYXRpdmUgJiYgIWNvbnRhaW5zKGxlZnQsICctJykpIHtcclxuICAgICAgICAgICAgICAgIGxlZnQgPSAnLScgKyBsZWZ0O1xyXG4gICAgICAgICAgICAgICAgcmlnaHQgPSAocmlnaHQgPT09ICctJykgPyAnJyA6IHJpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUudHJhaWxpbmdOZWdhdGl2ZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIFtsZWZ0LCByaWdodF07XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogc3RyaXAgcGFydHMgZnJvbSBleGNlc3MgY2hhcmFjdGVycyBhbmQgbGVhZGluZyB6ZXJvZXNcclxuICAgICAgICAgKi9cclxuICAgICAgICBub3JtYWxpemVQYXJ0cyhsZWZ0LCByaWdodCkge1xyXG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xyXG5cclxuICAgICAgICAgICAgLy8gcHJldmVudHMgbXVsdGlwbGUgbGVhZGluZyB6ZXJvcyBmcm9tIGJlaW5nIGVudGVyZWRcclxuICAgICAgICAgICAgbGVmdCA9IGF1dG9TdHJpcChsZWZ0LCBzZXR0aW5nc0Nsb25lKTtcclxuXHJcbiAgICAgICAgICAgIC8vIGlmIHJpZ2h0IGlzIG5vdCBlbXB0eSBhbmQgZmlyc3QgY2hhcmFjdGVyIGlzIG5vdCBhRGVjLFxyXG4gICAgICAgICAgICByaWdodCA9IGF1dG9TdHJpcChyaWdodCwgc2V0dGluZ3NDbG9uZSk7XHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLnRyYWlsaW5nTmVnYXRpdmUgJiYgIWNvbnRhaW5zKGxlZnQsICctJykpIHtcclxuICAgICAgICAgICAgICAgIGxlZnQgPSAnLScgKyBsZWZ0O1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS50cmFpbGluZ05lZ2F0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKChsZWZ0ID09PSAnJyB8fCBsZWZ0ID09PSBzZXR0aW5nc0Nsb25lLmFOZWcpICYmIHNldHRpbmdzQ2xvbmUubFplcm8gPT09ICdkZW55Jykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0ID4gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnJlcGxhY2UoL14wKihcXGQpLywgJyQxJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGluc2VydCB6ZXJvIGlmIGhhcyBsZWFkaW5nIGRvdFxyXG4gICAgICAgICAgICB0aGlzLm5ld1ZhbHVlID0gbGVmdCArIHJpZ2h0O1xyXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5hRGVjKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtID0gdGhpcy5uZXdWYWx1ZS5tYXRjaChuZXcgUmVnRXhwKGBeJHtzZXR0aW5nc0Nsb25lLmFOZWdSZWdBdXRvU3RyaXB9XFxcXCR7c2V0dGluZ3NDbG9uZS5hRGVjfWApKTtcclxuICAgICAgICAgICAgICAgIGlmIChtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQucmVwbGFjZShtWzFdLCBtWzFdICsgJzAnKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5ld1ZhbHVlID0gbGVmdCArIHJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gW2xlZnQsIHJpZ2h0XTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBzZXQgcGFydCBvZiBudW1iZXIgdG8gdmFsdWUga2VlcGluZyBwb3NpdGlvbiBvZiBjdXJzb3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBzZXRWYWx1ZVBhcnRzKGxlZnQsIHJpZ2h0LCBhZHZlbnQpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcclxuICAgICAgICAgICAgY29uc3QgcGFydHMgPSB0aGlzLm5vcm1hbGl6ZVBhcnRzKGxlZnQsIHJpZ2h0KTtcclxuICAgICAgICAgICAgY29uc3QgW21pblRlc3QsIG1heFRlc3RdID0gYXV0b0NoZWNrKHRoaXMubmV3VmFsdWUsIHNldHRpbmdzQ2xvbmUpO1xyXG4gICAgICAgICAgICBsZXQgcG9zaXRpb24gPSBwYXJ0c1swXS5sZW5ndGg7XHJcbiAgICAgICAgICAgIHRoaXMubmV3VmFsdWUgPSBwYXJ0cy5qb2luKCcnKTtcclxuICAgICAgICAgICAgaWYgKG1pblRlc3QgJiYgbWF4VGVzdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5uZXdWYWx1ZSA9IHRydW5jYXRlRGVjaW1hbCh0aGlzLm5ld1ZhbHVlLCBzZXR0aW5nc0Nsb25lLCBhZHZlbnQpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGVzdFZhbHVlID0gKGNvbnRhaW5zKHRoaXMubmV3VmFsdWUsICcsJykpID8gdGhpcy5uZXdWYWx1ZS5yZXBsYWNlKCcsJywgJy4nKSA6IHRoaXMubmV3VmFsdWU7XHJcbiAgICAgICAgICAgICAgICBpZiAodGVzdFZhbHVlID09PSAnJyB8fCB0ZXN0VmFsdWUgPT09IHNldHRpbmdzQ2xvbmUuYU5lZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUucmF3VmFsdWUgPSAnJztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5yYXdWYWx1ZSA9IHRlc3RWYWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA+IHRoaXMubmV3VmFsdWUubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSB0aGlzLm5ld1ZhbHVlLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLm5ld1ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQb3NpdGlvbihwb3NpdGlvbiwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFtaW5UZXN0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiR0aGF0LnRyaWdnZXIoJ2F1dG9OdW1lcmljOm1pbkV4Y2VlZGVkJyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIW1heFRlc3QpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJHRoYXQudHJpZ2dlcignYXV0b051bWVyaWM6bWF4RXhjZWVkZWQnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGhlbHBlciBmdW5jdGlvbiBmb3IgZXhwYW5kU2VsZWN0aW9uT25TaWduXHJcbiAgICAgICAgICogcmV0dXJucyBzaWduIHBvc2l0aW9uIG9mIGEgZm9ybWF0dGVkIHZhbHVlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2lnblBvc2l0aW9uKCkge1xyXG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xyXG4gICAgICAgICAgICBjb25zdCBhU2lnbiA9IHNldHRpbmdzQ2xvbmUuYVNpZ247XHJcbiAgICAgICAgICAgIGNvbnN0IHRoYXQgPSB0aGlzLnRoYXQ7XHJcbiAgICAgICAgICAgIGlmIChhU2lnbikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYVNpZ25MZW4gPSBhU2lnbi5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3AnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzTmVnID0gc2V0dGluZ3NDbG9uZS5hTmVnICYmIHRoYXQudmFsdWUgJiYgdGhhdC52YWx1ZS5jaGFyQXQoMCkgPT09IHNldHRpbmdzQ2xvbmUuYU5lZztcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFzTmVnID8gWzEsIGFTaWduTGVuICsgMV0gOiBbMCwgYVNpZ25MZW5dO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVMZW4gPSB0aGF0LnZhbHVlLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbdmFsdWVMZW4gLSBhU2lnbkxlbiwgdmFsdWVMZW5dO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gWzEwMDAsIC0xXTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBleHBhbmRzIHNlbGVjdGlvbiB0byBjb3ZlciB3aG9sZSBzaWduXHJcbiAgICAgICAgICogcHJldmVudHMgcGFydGlhbCBkZWxldGlvbi9jb3B5aW5nL292ZXJ3cml0aW5nIG9mIGEgc2lnblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGV4cGFuZFNlbGVjdGlvbk9uU2lnbihzZXRSZWFsKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNpZ25Qb3NpdGlvbiA9IHRoaXMuc2lnblBvc2l0aW9uKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0aW9uO1xyXG5cclxuICAgICAgICAgICAgLy8gaWYgc2VsZWN0aW9uIGNhdGNoZXMgc29tZXRoaW5nIGV4Y2VwdCBzaWduIGFuZCBjYXRjaGVzIG9ubHkgc3BhY2UgZnJvbSBzaWduXHJcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24uc3RhcnQgPCBzaWduUG9zaXRpb25bMV0gJiYgc2VsZWN0aW9uLmVuZCA+IHNpZ25Qb3NpdGlvblswXSkge1xyXG4gICAgICAgICAgICAgICAgLy8gdGhlbiBzZWxlY3Qgd2l0aG91dCBlbXB0eSBzcGFjZVxyXG4gICAgICAgICAgICAgICAgaWYgKChzZWxlY3Rpb24uc3RhcnQgPCBzaWduUG9zaXRpb25bMF0gfHwgc2VsZWN0aW9uLmVuZCA+IHNpZ25Qb3NpdGlvblsxXSkgJiYgdGhpcy52YWx1ZS5zdWJzdHJpbmcoTWF0aC5tYXgoc2VsZWN0aW9uLnN0YXJ0LCBzaWduUG9zaXRpb25bMF0pLCBNYXRoLm1pbihzZWxlY3Rpb24uZW5kLCBzaWduUG9zaXRpb25bMV0pKS5tYXRjaCgvXlxccyokLykpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uLnN0YXJ0IDwgc2lnblBvc2l0aW9uWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKHNlbGVjdGlvbi5zdGFydCwgc2lnblBvc2l0aW9uWzBdLCBzZXRSZWFsKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFNlbGVjdGlvbihzaWduUG9zaXRpb25bMV0sIHNlbGVjdGlvbi5lbmQsIHNldFJlYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBzZWxlY3Qgd2l0aCB3aG9sZSBzaWduXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24oTWF0aC5taW4oc2VsZWN0aW9uLnN0YXJ0LCBzaWduUG9zaXRpb25bMF0pLCBNYXRoLm1heChzZWxlY3Rpb24uZW5kLCBzaWduUG9zaXRpb25bMV0pLCBzZXRSZWFsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIHRyeSB0byBzdHJpcCBwYXN0ZWQgdmFsdWUgdG8gZGlnaXRzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2hlY2tQYXN0ZSgpIHtcclxuICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLnZhbHVlUGFydHNCZWZvcmVQYXN0ZSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9sZFBhcnRzID0gdGhpcy52YWx1ZVBhcnRzQmVmb3JlUGFzdGU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBbbGVmdCwgcmlnaHRdID0gdGhpcy5nZXRCZWZvcmVBZnRlcigpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHRyeSB0byBzdHJpcCBwYXN0ZWQgdmFsdWUgZmlyc3RcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnZhbHVlUGFydHNCZWZvcmVQYXN0ZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkTGVmdFBhcnQgPSBsZWZ0LnN1YnN0cigwLCBvbGRQYXJ0c1swXS5sZW5ndGgpICsgYXV0b1N0cmlwKGxlZnQuc3Vic3RyKG9sZFBhcnRzWzBdLmxlbmd0aCksIHRoaXMuc2V0dGluZ3NDbG9uZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2V0VmFsdWVQYXJ0cyhtb2RpZmllZExlZnRQYXJ0LCByaWdodCwgJ3Bhc3RlJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gb2xkUGFydHMuam9pbignJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRQb3NpdGlvbihvbGRQYXJ0c1swXS5sZW5ndGgsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIHByb2Nlc3MgcGFzdGluZywgY3Vyc29yIG1vdmluZyBhbmQgc2tpcHBpbmcgb2Ygbm90IGludGVyZXN0aW5nIGtleXNcclxuICAgICAgICAgKiBpZiByZXR1cm5zIHRydWUsIGZ1cnRoZXIgcHJvY2Vzc2luZyBpcyBub3QgcGVyZm9ybWVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2tpcEFsd2F5cyhlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGtkQ29kZSA9IHRoaXMua2RDb2RlO1xyXG4gICAgICAgICAgICBjb25zdCB3aGljaCA9IHRoaXMud2hpY2g7XHJcbiAgICAgICAgICAgIGNvbnN0IGN0cmxLZXkgPSB0aGlzLmN0cmxLZXk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNtZEtleSA9IHRoaXMuY21kS2V5O1xyXG5cclxuICAgICAgICAgICAgLy8gY2F0Y2ggdGhlIGN0cmwgdXAgb24gY3RybC12XHJcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0S2V5ID0gdGhpcy5zaGlmdEtleTtcclxuICAgICAgICAgICAgaWYgKCgoY3RybEtleSB8fCBjbWRLZXkpICYmIGUudHlwZSA9PT0gJ2tleXVwJyAmJiAhaXNVbmRlZmluZWQodGhpcy52YWx1ZVBhcnRzQmVmb3JlUGFzdGUpKSB8fCAoc2hpZnRLZXkgJiYga2RDb2RlID09PSBrZXlDb2RlLkluc2VydCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tQYXN0ZSgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBza2lwIEZ4IGtleXMsIHdpbmRvd3Mga2V5cywgb3RoZXIgc3BlY2lhbCBrZXlzXHJcbiAgICAgICAgICAgIGlmICgoa2RDb2RlID49IGtleUNvZGUuRjEgJiYga2RDb2RlIDw9IGtleUNvZGUuRjEyKSB8fFxyXG4gICAgICAgICAgICAgICAgKGtkQ29kZSA+PSBrZXlDb2RlLldpbmRvd3MgJiYga2RDb2RlIDw9IGtleUNvZGUuUmlnaHRDbGljaykgfHxcclxuICAgICAgICAgICAgICAgIChrZENvZGUgPj0ga2V5Q29kZS5UYWIgJiYga2RDb2RlIDwga2V5Q29kZS5TcGFjZSkgfHxcclxuICAgICAgICAgICAgICAgIChrZENvZGUgPCBrZXlDb2RlLkJhY2tzcGFjZSAmJlxyXG4gICAgICAgICAgICAgICAgKHdoaWNoID09PSAwIHx8IHdoaWNoID09PSBrZENvZGUpKSB8fFxyXG4gICAgICAgICAgICAgICAga2RDb2RlID09PSBrZXlDb2RlLk51bUxvY2sgfHxcclxuICAgICAgICAgICAgICAgIGtkQ29kZSA9PT0ga2V5Q29kZS5TY3JvbGxMb2NrIHx8XHJcbiAgICAgICAgICAgICAgICBrZENvZGUgPT09IGtleUNvZGUuSW5zZXJ0IHx8XHJcbiAgICAgICAgICAgICAgICBrZENvZGUgPT09IGtleUNvZGUuQ29tbWFuZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGlmIHNlbGVjdCBhbGwgKGEpXHJcbiAgICAgICAgICAgIGlmICgoY3RybEtleSB8fCBjbWRLZXkpICYmIGtkQ29kZSA9PT0ga2V5Q29kZS5hKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5zTnVtYmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlTGVuID0gdGhpcy50aGF0LnZhbHVlLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhU2lnbkxlbiA9IHRoaXMuc2V0dGluZ3MuYVNpZ24ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5lZ0xlbiA9ICghY29udGFpbnModGhpcy50aGF0LnZhbHVlLCAnLScpKT8wOjE7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYVN1ZmZpeExlbiA9IHRoaXMuc2V0dGluZ3MuYVN1ZmZpeC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcFNpZ24gPSB0aGlzLnNldHRpbmdzLnBTaWduO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBOZWcgPSB0aGlzLnNldHRpbmdzLnBOZWc7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzdGFydDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocFNpZ24gPT09ICdzJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSAocE5lZyA9PT0gJ2wnICYmIG5lZ0xlbiA9PT0gMSAmJiBhU2lnbkxlbiA+IDApP2FTaWduTGVuICsgMTphU2lnbkxlbjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBlbmQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBTaWduID09PSAncCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gdmFsdWVMZW4gLSBhU3VmZml4TGVuO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocE5lZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gdmFsdWVMZW4gLSAoYVN1ZmZpeExlbiArIGFTaWduTGVuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3InOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IChhU2lnbkxlbiA+IDApP3ZhbHVlTGVuIC0gKGFTaWduTGVuICsgbmVnTGVuICsgYVN1ZmZpeExlbik6dmFsdWVMZW4gLSAoYVNpZ25MZW4gKyBhU3VmZml4TGVuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IHZhbHVlTGVuIC0gKGFTaWduTGVuICsgYVN1ZmZpeExlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNldEVsZW1lbnRTZWxlY3Rpb24odGhpcy50aGF0LCBzdGFydCwgZW5kKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBpZiBjb3B5IChjKVxyXG4gICAgICAgICAgICBpZiAoKGN0cmxLZXkgfHwgY21kS2V5KSAmJiAoa2RDb2RlID09PSBrZXlDb2RlLmMgfHwga2RDb2RlID09PSBrZXlDb2RlLnYgfHwga2RDb2RlID09PSBrZXlDb2RlLngpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZS50eXBlID09PSAna2V5ZG93bicpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGFuZFNlbGVjdGlvbk9uU2lnbigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIHRyeSB0byBwcmV2ZW50IHdyb25nIHBhc3RlXHJcbiAgICAgICAgICAgICAgICBpZiAoa2RDb2RlID09PSBrZXlDb2RlLnYgfHwga2RDb2RlID09PSBrZXlDb2RlLkluc2VydCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlLnR5cGUgPT09ICdrZXlkb3duJyB8fCBlLnR5cGUgPT09ICdrZXlwcmVzcycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHRoaXMudmFsdWVQYXJ0c0JlZm9yZVBhc3RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZVBhcnRzQmVmb3JlUGFzdGUgPSB0aGlzLmdldEJlZm9yZUFmdGVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrUGFzdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZS50eXBlID09PSAna2V5ZG93bicgfHwgZS50eXBlID09PSAna2V5cHJlc3MnIHx8IGtkQ29kZSA9PT0ga2V5Q29kZS5jO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoY3RybEtleSB8fCBjbWRLZXkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBqdW1wIG92ZXIgdGhvdXNhbmQgc2VwYXJhdG9yXHJcbiAgICAgICAgICAgIGlmIChrZENvZGUgPT09IGtleUNvZGUuTGVmdEFycm93IHx8IGtkQ29kZSA9PT0ga2V5Q29kZS5SaWdodEFycm93KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhU2VwID0gdGhpcy5zZXR0aW5nc0Nsb25lLmFTZXA7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhRGVjID0gdGhpcy5zZXR0aW5nc0Nsb25lLmFEZWM7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydEp1bXAgPSB0aGlzLnNlbGVjdGlvbi5zdGFydDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy50aGF0LnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gJ2tleWRvd24nICYmICF0aGlzLnNoaWZ0S2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtkQ29kZSA9PT0ga2V5Q29kZS5MZWZ0QXJyb3cgJiYgKHZhbHVlLmNoYXJBdChzdGFydEp1bXAgLSAyKSA9PT0gYVNlcCB8fCB2YWx1ZS5jaGFyQXQoc3RhcnRKdW1wIC0gMikgPT09IGFEZWMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0UG9zaXRpb24oc3RhcnRKdW1wIC0gMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChrZENvZGUgPT09IGtleUNvZGUuUmlnaHRBcnJvdyAmJiAodmFsdWUuY2hhckF0KHN0YXJ0SnVtcCArIDEpID09PSBhU2VwIHx8IHZhbHVlLmNoYXJBdChzdGFydEp1bXAgKyAxKSA9PT0gYURlYykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRQb3NpdGlvbihzdGFydEp1bXAgKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGtkQ29kZSA+PSBrZXlDb2RlLlBhZ2VEb3duICYmIGtkQ29kZSA8PSBrZXlDb2RlLkRvd25BcnJvdztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBwcm9jZXNzIGRlbGV0aW9uIG9mIGNoYXJhY3RlcnMgd2hlbiB0aGUgbWludXMgc2lnbiBpcyB0byB0aGUgcmlnaHQgb2YgdGhlIG51bWVyaWMgY2hhcmFjdGVyc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHByb2Nlc3NUcmFpbGluZyhbbGVmdCwgcmlnaHRdKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzQ2xvbmUgPSB0aGlzLnNldHRpbmdzQ2xvbmU7XHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLnBTaWduID09PSAncCcgJiYgc2V0dGluZ3NDbG9uZS5wTmVnID09PSAncycpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmtkQ29kZSA9PT0gOCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSBCb29sZWFuKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID49IHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLmFTdWZmaXgpICYmIHNldHRpbmdzQ2xvbmUuYVN1ZmZpeCAhPT0gJycpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlLmNoYXJBdCh0aGlzLnNlbGVjdGlvbi5zdGFydCAtIDEpID09PSAnLScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPD0gdGhpcy52YWx1ZS5sZW5ndGggLSBzZXR0aW5nc0Nsb25lLmFTdWZmaXgubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygwLCBsZWZ0Lmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCA9IEJvb2xlYW4odGhpcy5zZWxlY3Rpb24uc3RhcnQgPj0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYVN1ZmZpeCkgJiYgc2V0dGluZ3NDbG9uZS5hU3VmZml4ICE9PSAnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID49IHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLmFTaWduKSArIHNldHRpbmdzQ2xvbmUuYVNpZ24ubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuc3Vic3RyaW5nKDEsIHJpZ2h0Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250YWlucyhsZWZ0LCAnLScpICYmIHRoaXMudmFsdWUuY2hhckF0KHRoaXMuc2VsZWN0aW9uLnN0YXJ0KSA9PT0gJy0nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLnBTaWduID09PSAncycgJiYgc2V0dGluZ3NDbG9uZS5wTmVnID09PSAnbCcpIHtcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSBCb29sZWFuKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID49IHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLmFOZWcpICsgc2V0dGluZ3NDbG9uZS5hTmVnLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5rZENvZGUgPT09IDgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPT09ICh0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5hTmVnKSArIHNldHRpbmdzQ2xvbmUuYU5lZy5sZW5ndGgpICYmIGNvbnRhaW5zKHRoaXMudmFsdWUsIHNldHRpbmdzQ2xvbmUuYU5lZykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGVmdCAhPT0gJy0nICYmICgodGhpcy5zZWxlY3Rpb24uc3RhcnQgPD0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYU5lZykpIHx8ICFjb250YWlucyh0aGlzLnZhbHVlLCBzZXR0aW5nc0Nsb25lLmFOZWcpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMCwgbGVmdC5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0WzBdID09PSAnLScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHJpbmcoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5zdGFydCA9PT0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYU5lZykgJiYgY29udGFpbnModGhpcy52YWx1ZSwgc2V0dGluZ3NDbG9uZS5hTmVnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3MnICYmIHNldHRpbmdzQ2xvbmUucE5lZyA9PT0gJ3InKSB7XHJcbiAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4ID0gQm9vbGVhbih0aGlzLnNlbGVjdGlvbi5zdGFydCA+PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5hTmVnKSArIHNldHRpbmdzQ2xvbmUuYU5lZy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMua2RDb2RlID09PSA4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID09PSAodGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYU5lZykgKyBzZXR0aW5nc0Nsb25lLmFOZWcubGVuZ3RoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsZWZ0ICE9PSAnLScgJiYgdGhpcy5zZWxlY3Rpb24uc3RhcnQgPD0gKHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLmFOZWcpIC0gc2V0dGluZ3NDbG9uZS5hU2lnbi5sZW5ndGgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygwLCBsZWZ0Lmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGVmdCAhPT0gJycgJiYgIWNvbnRhaW5zKHRoaXMudmFsdWUsIHNldHRpbmdzQ2xvbmUuYU5lZykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDAsIGxlZnQubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4ID0gQm9vbGVhbih0aGlzLnNlbGVjdGlvbi5zdGFydCA+PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5hU2lnbikgJiYgc2V0dGluZ3NDbG9uZS5hU2lnbiAhPT0gJycpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5zdGFydCA9PT0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYU5lZykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cmluZygxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIFtsZWZ0LCByaWdodF07XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogcHJvY2VzcyBkZWxldGlvbiBvZiBjaGFyYWN0ZXJzXHJcbiAgICAgICAgICogcmV0dXJucyB0cnVlIGlmIHByb2Nlc3NpbmcgcGVyZm9ybWVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHJvY2Vzc0Fsd2F5cygpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcclxuICAgICAgICAgICAgaWYgKHRoaXMua2RDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSB8fCB0aGlzLmtkQ29kZSA9PT0ga2V5Q29kZS5EZWxldGUpIHtcclxuICAgICAgICAgICAgICAgIGxldCBsZWZ0O1xyXG4gICAgICAgICAgICAgICAgbGV0IHJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNlbGVjdGlvbi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBbbGVmdCwgcmlnaHRdID0gdGhpcy5nZXRCZWZvcmVBZnRlclN0cmlwZWQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdCA9PT0gJycgJiYgcmlnaHQgPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUudGhyb3dJbnB1dCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoKChzZXR0aW5nc0Nsb25lLnBTaWduID09PSAncCcgJiYgc2V0dGluZ3NDbG9uZS5wTmVnID09PSAncycpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3MnICYmIChzZXR0aW5nc0Nsb25lLnBOZWcgPT09ICdsJyB8fCBzZXR0aW5nc0Nsb25lLnBOZWcgPT09ICdyJykpKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbnModGhpcy52YWx1ZSwgJy0nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBbbGVmdCwgcmlnaHRdID0gdGhpcy5wcm9jZXNzVHJhaWxpbmcoW2xlZnQsIHJpZ2h0XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMua2RDb2RlID09PSA4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMCwgbGVmdC5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuc3Vic3RyaW5nKDEsIHJpZ2h0Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZVBhcnRzKGxlZnQsIHJpZ2h0KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBhbmRTZWxlY3Rpb25PblNpZ24oZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIFtsZWZ0LCByaWdodF0gPSB0aGlzLmdldEJlZm9yZUFmdGVyU3RyaXBlZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0VmFsdWVQYXJ0cyhsZWZ0LCByaWdodCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIHByb2Nlc3MgaW5zZXJ0aW9uIG9mIGNoYXJhY3RlcnNcclxuICAgICAgICAgKiByZXR1cm5zIHRydWUgaWYgcHJvY2Vzc2luZyBwZXJmb3JtZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBwcm9jZXNzS2V5cHJlc3MoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzQ2xvbmUgPSB0aGlzLnNldHRpbmdzQ2xvbmU7XHJcbiAgICAgICAgICAgIGNvbnN0IGNDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLndoaWNoKTtcclxuICAgICAgICAgICAgbGV0IFtsZWZ0LCByaWdodF0gPSB0aGlzLmdldEJlZm9yZUFmdGVyU3RyaXBlZCgpO1xyXG4gICAgICAgICAgICBzZXR0aW5nc0Nsb25lLnRocm93SW5wdXQgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgLy8gc3RhcnQgcnVsZXMgd2hlbiB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIga2V5IGlzIHByZXNzZWQgYWx3YXlzIHVzZSBudW1lcmljIHBhZCBkb3QgdG8gaW5zZXJ0IGRlY2ltYWwgc2VwYXJhdG9yXHJcbiAgICAgICAgICAgIC8vIGRvIG5vdCBhbGxvdyBkZWNpbWFsIGNoYXJhY3RlciBpZiBubyBkZWNpbWFsIHBhcnQgYWxsb3dlZFxyXG4gICAgICAgICAgICBpZiAoY0NvZGUgPT09IHNldHRpbmdzQ2xvbmUuYURlYyB8fCAoc2V0dGluZ3NDbG9uZS5hbHREZWMgJiYgY0NvZGUgPT09IHNldHRpbmdzQ2xvbmUuYWx0RGVjKSB8fCAoKGNDb2RlID09PSAnLicgfHwgY0NvZGUgPT09ICcsJykgJiYgdGhpcy5rZENvZGUgPT09IGtleUNvZGUuRG90TnVtcGFkKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5nc0Nsb25lLm1EZWMgfHwgIXNldHRpbmdzQ2xvbmUuYURlYykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBhbGxvdyBkZWNpbWFsIGNoYXJhY3RlciBiZWZvcmUgYU5lZyBjaGFyYWN0ZXJcclxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLmFOZWcgJiYgY29udGFpbnMocmlnaHQsIHNldHRpbmdzQ2xvbmUuYU5lZykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBkbyBub3QgYWxsb3cgZGVjaW1hbCBjaGFyYWN0ZXIgaWYgb3RoZXIgZGVjaW1hbCBjaGFyYWN0ZXIgcHJlc2VudFxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5zKGxlZnQsIHNldHRpbmdzQ2xvbmUuYURlYykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChyaWdodC5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYURlYykgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocmlnaHQuaW5kZXhPZihzZXR0aW5nc0Nsb25lLmFEZWMpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHIoMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFZhbHVlUGFydHMobGVmdCArIHNldHRpbmdzQ2xvbmUuYURlYywgcmlnaHQsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIHByZXZlbnQgbWludXMgaWYgbm90IGFsbG93ZWRcclxuICAgICAgICAgICAgaWYgKChjQ29kZSA9PT0gJy0nIHx8IGNDb2RlID09PSAnKycpICYmIHNldHRpbmdzQ2xvbmUuYU5lZyA9PT0gJy0nKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXNldHRpbmdzQ2xvbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBjYXJldCBpcyBhbHdheXMgYWZ0ZXIgbWludXNcclxuICAgICAgICAgICAgICAgIGlmICgoc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3AnICYmIHNldHRpbmdzQ2xvbmUucE5lZyA9PT0gJ3MnKSB8fCAoc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3MnICYmIHNldHRpbmdzQ2xvbmUucE5lZyAhPT0gJ3AnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0ID09PSAnJyAmJiBjb250YWlucyhyaWdodCwgc2V0dGluZ3NDbG9uZS5hTmVnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gc2V0dGluZ3NDbG9uZS5hTmVnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cmluZygxLCByaWdodC5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hhbmdlIHNpZ24gb2YgbnVtYmVyLCByZW1vdmUgcGFydCBpZiBzaG91bGRcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdC5jaGFyQXQoMCkgPT09ICctJyB8fCBjb250YWlucyhsZWZ0LCBzZXR0aW5nc0Nsb25lLmFOZWcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygxLCBsZWZ0Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IChjQ29kZSA9PT0gJy0nKSA/IHNldHRpbmdzQ2xvbmUuYU5lZyArIGxlZnQgOiBsZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnQgPT09ICcnICYmIGNvbnRhaW5zKHJpZ2h0LCBzZXR0aW5nc0Nsb25lLmFOZWcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBzZXR0aW5nc0Nsb25lLmFOZWc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuc3Vic3RyaW5nKDEsIHJpZ2h0Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBjaGFuZ2Ugc2lnbiBvZiBudW1iZXIsIHJlbW92ZSBwYXJ0IGlmIHNob3VsZFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0LmNoYXJBdCgwKSA9PT0gc2V0dGluZ3NDbG9uZS5hTmVnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygxLCBsZWZ0Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IChjQ29kZSA9PT0gJy0nKSA/IHNldHRpbmdzQ2xvbmUuYU5lZyArIGxlZnQgOiBsZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0VmFsdWVQYXJ0cyhsZWZ0LCByaWdodCwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gaWYgdHJ5IHRvIGluc2VydCBkaWdpdCBiZWZvcmUgbWludXNcclxuICAgICAgICAgICAgaWYgKGNDb2RlID49ICcwJyAmJiBjQ29kZSA8PSAnOScpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLmFOZWcgJiYgbGVmdCA9PT0gJycgJiYgY29udGFpbnMocmlnaHQsIHNldHRpbmdzQ2xvbmUuYU5lZykpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gc2V0dGluZ3NDbG9uZS5hTmVnO1xyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuc3Vic3RyaW5nKDEsIHJpZ2h0Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS52TWF4IDw9IDAgJiYgc2V0dGluZ3NDbG9uZS52TWluIDwgc2V0dGluZ3NDbG9uZS52TWF4ICYmICFjb250YWlucyh0aGlzLnZhbHVlLCBzZXR0aW5nc0Nsb25lLmFOZWcpICYmIGNDb2RlICE9PSAnMCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gc2V0dGluZ3NDbG9uZS5hTmVnICsgbGVmdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0VmFsdWVQYXJ0cyhsZWZ0ICsgY0NvZGUsIHJpZ2h0LCBudWxsKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBwcmV2ZW50IGFueSBvdGhlciBjaGFyYWN0ZXJcclxuICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS50aHJvd0lucHV0ID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBmb3JtYXR0aW5nIG9mIGp1c3QgcHJvY2Vzc2VkIHZhbHVlIHdpdGgga2VlcGluZyBvZiBjdXJzb3IgcG9zaXRpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICBmb3JtYXRRdWljayhlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzQ2xvbmUgPSB0aGlzLnNldHRpbmdzQ2xvbmU7XHJcbiAgICAgICAgICAgIGNvbnN0IGxlZnRMZW5ndGggPSB0aGlzLnZhbHVlO1xyXG4gICAgICAgICAgICBjb25zdCBrdUNvZGUgPSBlLmtleUNvZGU7XHJcbiAgICAgICAgICAgIGxldCBbbGVmdF0gPSB0aGlzLmdldEJlZm9yZUFmdGVyU3RyaXBlZCgpO1xyXG5cclxuICAgICAgICAgICAgLy8gbm8gZ3JvdXBpbmcgc2VwYXJhdG9yIGFuZCBubyBjdXJyZW5jeSBzaWduXHJcbiAgICAgICAgICAgIGlmICgoc2V0dGluZ3NDbG9uZS5hU2VwICA9PT0gJycgfHwgKHNldHRpbmdzQ2xvbmUuYVNlcCAhPT0gJycgICYmICFjb250YWlucyhsZWZ0TGVuZ3RoLCBzZXR0aW5nc0Nsb25lLmFTZXApKSkgJiZcclxuICAgICAgICAgICAgICAgIChzZXR0aW5nc0Nsb25lLmFTaWduID09PSAnJyB8fCAoc2V0dGluZ3NDbG9uZS5hU2lnbiAhPT0gJycgJiYgIWNvbnRhaW5zKGxlZnRMZW5ndGgsIHNldHRpbmdzQ2xvbmUuYVNpZ24pKSkpIHtcclxuICAgICAgICAgICAgICAgIGxldCBbc3ViUGFydHNdID0gbGVmdExlbmd0aC5zcGxpdChzZXR0aW5nc0Nsb25lLmFEZWMpO1xyXG4gICAgICAgICAgICAgICAgbGV0IG5TaWduID0gJyc7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbnMoc3ViUGFydHMsICctJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBuU2lnbiA9ICctJztcclxuICAgICAgICAgICAgICAgICAgICBzdWJQYXJ0cyA9IHN1YlBhcnRzLnJlcGxhY2UoJy0nLCAnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQucmVwbGFjZSgnLScsICcnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBzdHJpcCBsZWFkaW5nIHplcm8gb24gcG9zaXRpdmUgdmFsdWUgaWYgbmVlZFxyXG4gICAgICAgICAgICAgICAgaWYgKG5TaWduID09PSAnJyAmJiBzdWJQYXJ0cy5sZW5ndGggPiBzZXR0aW5nc0Nsb25lLm1JbnRQb3MgJiYgbGVmdC5jaGFyQXQoMCkgPT09ICcwJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnNsaWNlKDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIHN0cmlwIGxlYWRpbmcgemVybyBvbiBuZWdhdGl2ZSB2YWx1ZSBpZiBuZWVkXHJcbiAgICAgICAgICAgICAgICBpZiAoblNpZ24gPT09ICctJyAmJiBzdWJQYXJ0cy5sZW5ndGggPiBzZXR0aW5nc0Nsb25lLm1JbnROZWcgJiYgbGVmdC5jaGFyQXQoMCkgPT09ICcwJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnNsaWNlKDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGVmdCA9IG5TaWduICsgbGVmdDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhdXRvR3JvdXAodGhpcy52YWx1ZSwgdGhpcy5zZXR0aW5nc0Nsb25lKTtcclxuICAgICAgICAgICAgbGV0IHBvc2l0aW9uID0gdmFsdWUubGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIC8vIHByZXBhcmUgcmVnZXhwIHdoaWNoIHNlYXJjaGVzIGZvciBjdXJzb3IgcG9zaXRpb24gZnJvbSB1bmZvcm1hdHRlZCBsZWZ0IHBhcnRcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxlZnRBciA9IGxlZnQuc3BsaXQoJycpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGZpeGVzIGNhcmV0IHBvc2l0aW9uIHdpdGggdHJhaWxpbmcgbWludXMgc2lnblxyXG4gICAgICAgICAgICAgICAgaWYgKChzZXR0aW5nc0Nsb25lLnBOZWcgPT09ICdzJyB8fCAoc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3MnICYmIHNldHRpbmdzQ2xvbmUucE5lZyAhPT0gJ3AnKSkgJiYgbGVmdEFyWzBdID09PSAnLScgJiYgc2V0dGluZ3NDbG9uZS5hTmVnICE9PSAnJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZnRBci5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLnBTaWduID09PSAncycgJiYgc2V0dGluZ3NDbG9uZS5wTmVnID09PSAnbCcgJiYgKGt1Q29kZSA9PT0ga2V5Q29kZS5CYWNrc3BhY2UgfHwgdGhpcy5rZENvZGUgPT09IGtleUNvZGUuQmFja3NwYWNlIHx8IGt1Q29kZSA9PT0ga2V5Q29kZS5EZWxldGUgfHwgdGhpcy5rZENvZGUgPT09IGtleUNvZGUuRGVsZXRlKSAmJiBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRBci5wdXNoKCctJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSBCb29sZWFuKGUudHlwZSA9PT0gJ2tleWRvd24nKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdwJyAmJiBzZXR0aW5nc0Nsb25lLnBOZWcgPT09ICdzJyAmJiAoa3VDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSB8fCB0aGlzLmtkQ29kZSA9PT0ga2V5Q29kZS5CYWNrc3BhY2UgfHwga3VDb2RlID09PSBrZXlDb2RlLkRlbGV0ZSB8fCB0aGlzLmtkQ29kZSA9PT0ga2V5Q29kZS5EZWxldGUpICYmIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdEFyLnB1c2goJy0nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCA9IEJvb2xlYW4oZS50eXBlID09PSAna2V5ZG93bicpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3MnICYmIHNldHRpbmdzQ2xvbmUucE5lZyA9PT0gJ3InICYmIChrdUNvZGUgPT09IGtleUNvZGUuQmFja3NwYWNlIHx8IHRoaXMua2RDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSB8fCBrdUNvZGUgPT09IGtleUNvZGUuRGVsZXRlIHx8IHRoaXMua2RDb2RlID09PSBrZXlDb2RlLkRlbGV0ZSkgJiYgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaWduUGFydHMgPSBzZXR0aW5nc0Nsb25lLmFTaWduLnNwbGl0KCcnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXNjYXBlQ2hyID0gWydcXFxcJywgJ14nLCAnJCcsICcuJywgJ3wnLCAnPycsICcqJywgJysnLCAnKCcsICcpJywgJ1snXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXNjYXBlZFBhcnRzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICQuZWFjaChzaWduUGFydHMsIChpLCBtaW5pUGFydHMpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbmlQYXJ0cyA9IHNpZ25QYXJ0c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0luQXJyYXkobWluaVBhcnRzLCBlc2NhcGVDaHIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlZFBhcnRzLnB1c2goJ1xcXFwnICsgbWluaVBhcnRzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlZFBhcnRzLnB1c2gobWluaVBhcnRzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrdUNvZGUgPT09IGtleUNvZGUuQmFja3NwYWNlIHx8IHRoaXMua2RDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlZFBhcnRzLnB1c2goJy0nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHVzaGluZyB0aGUgZXNjYXBlZCBzaWduXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRBci5wdXNoKGVzY2FwZWRQYXJ0cy5qb2luKCcnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSBCb29sZWFuKGUudHlwZSA9PT0gJ2tleWRvd24nKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZWZ0QXIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWxlZnRBcltpXS5tYXRjaCgnXFxcXGQnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0QXJbaV0gPSAnXFxcXCcgKyBsZWZ0QXJbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGxlZnRSZWcgPSBuZXcgUmVnRXhwKCdeLio/JyArIGxlZnRBci5qb2luKCcuKj8nKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gc2VhcmNoIGN1cnNvciBwb3NpdGlvbiBpbiBmb3JtYXR0ZWQgdmFsdWVcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0xlZnQgPSB2YWx1ZS5tYXRjaChsZWZ0UmVnKTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXdMZWZ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBuZXdMZWZ0WzBdLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgYXJlIGp1c3QgYmVmb3JlIHNpZ24gd2hpY2ggaXMgaW4gcHJlZml4IHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgocG9zaXRpb24gPT09IDAgJiYgdmFsdWUuY2hhckF0KDApICE9PSBzZXR0aW5nc0Nsb25lLmFOZWcpIHx8IChwb3NpdGlvbiA9PT0gMSAmJiB2YWx1ZS5jaGFyQXQoMCkgPT09IHNldHRpbmdzQ2xvbmUuYU5lZykpICYmIHNldHRpbmdzQ2xvbmUuYVNpZ24gJiYgc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3AnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBsYWNlIGNhcmV0IGFmdGVyIHByZWZpeCBzaWduXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy5zZXR0aW5nc0Nsb25lLmFTaWduLmxlbmd0aCArICh2YWx1ZS5jaGFyQXQoMCkgPT09ICctJyA/IDEgOiAwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLmFTaWduICYmIHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdzJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBjb3VsZCBub3QgZmluZCBhIHBsYWNlIGZvciBjdXJzb3IgYW5kIGhhdmUgYSBzaWduIGFzIGEgc3VmZml4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBsYWNlIGNhcmV0IGJlZm9yZSBzdWZmaXggY3VycmVuY3kgc2lnblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiAtPSBzZXR0aW5nc0Nsb25lLmFTaWduLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUuYVN1ZmZpeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBjb3VsZCBub3QgZmluZCBhIHBsYWNlIGZvciBjdXJzb3IgYW5kIGhhdmUgYSBzdWZmaXhcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGxhY2UgY2FyZXQgYmVmb3JlIHN1ZmZpeFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiAtPSBzZXR0aW5nc0Nsb25lLmFTdWZmaXgubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnRoYXQudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy5zZXRQb3NpdGlvbihwb3NpdGlvbik7XHJcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0dGVkID0gdHJ1ZTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZnVuY3Rpb24gZmFjdG9yaXNlIHRoZSBgZ2V0U3RyaW5nKClgIGFuZCBgZ2V0QXJyYXkoKWAgZnVuY3Rpb25zIHNpbmNlIHRoZXkgc2hhcmUgcXVpdGUgYSBsb3Qgb2YgY29kZS5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgXCJnZXRTdHJpbmdcIiBtZXRob2QgdXNlcyBqUXVlcnkncyAuc2VyaWFsaXplKCkgbWV0aG9kIHRoYXQgY3JlYXRlcyBhIHRleHQgc3RyaW5nIGluIHN0YW5kYXJkIFVSTC1lbmNvZGVkIG5vdGF0aW9uLlxyXG4gICAgICogVGhlIFwiZ2V0QXJyYXlcIiBtZXRob2Qgb24gdGhlIG90aGVyIGhhbmQgdXNlcyBqUXVlcnkncyAuc2VyaWFsaXplQXJyYXkoKSBtZXRob2QgdGhhdCBjcmVhdGVzIGFycmF5IG9yIG9iamVjdHMgdGhhdCBjYW4gYmUgZW5jb2RlZCBhcyBhIEpTT04gc3RyaW5nLlxyXG4gICAgICpcclxuICAgICAqIEl0IHRoZW4gbG9vcHMgdGhyb3VnaCB0aGUgc3RyaW5nIGFuZCB1bi1mb3JtYXRzIHRoZSBpbnB1dHMgd2l0aCBhdXRvTnVtZXJpYy5cclxuICAgICAqIEJ5IGRlZmF1bHRzIHZhbHVlcyByZXR1cm5lZCBhcyBJU08gbnVtZXJpYyBzdHJpbmcgXCIxMjM0LjU2XCIgb3IgXCItMTIzNC41NlwiIHdoZXJlIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBpcyBhIHBlcmlvZFxyXG4gICAgICogTG9jYWxlIGZvcm1hdHMgYXJlIHN1cHBvcnRlZCBcIjEyMzQuNTYtXCIgb3IgXCIxMjM0LDU2XCIgb3IgXCItMTIzNCw1NiBvciBcIjEyMzQsNTYtXCIgPT4gcGxlYXNlIHNlZSBvcHRpb24gXCJsb2NhbGVPdXRwdXRcIiBmb3IgZGV0YWlsc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZ2V0QXJyYXlCZWhhdmlvciAtIElmIHNldCB0byBUUlVFLCB0aGVuIHRoaXMgZnVuY3Rpb24gYmVoYXZlIGxpa2UgYGdldEFycmF5KClgLCBvdGhlcndpc2UgaWYgc2V0IHRvIEZBTFNFLCBpdCBiZWhhdmUgbGlrZSBgZ2V0U3RyaW5nKClgXHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9nZXRTdHJpbmdPckFycmF5KGdldEFycmF5QmVoYXZpb3IgPSB0cnVlLCB0aGF0KSB7XHJcbiAgICAgICAgY29uc3QgJHRoaXMgPSBhdXRvR2V0KCQodGhhdCkpO1xyXG4gICAgICAgIGNvbnN0IGZvcm1JbmRleCA9ICQoJ2Zvcm0nKS5pbmRleCgkdGhpcyk7XHJcbiAgICAgICAgY29uc3QgYWxsRm9ybUVsZW1lbnRzID0gJChgZm9ybTplcSgke2Zvcm1JbmRleH0pYClbMF07XHJcbiAgICAgICAgY29uc3QgYWlJbmRleCA9IFtdO1xyXG5cclxuICAgICAgICAvLyBhbGwgaW5wdXQgaW5kZXhcclxuICAgICAgICBjb25zdCBzY0luZGV4ID0gW107XHJcblxyXG4gICAgICAgIC8vIHN1Y2Nlc3NmdWwgY29udHJvbCBpbmRleFxyXG4gICAgICAgIGNvbnN0IHJTdWJtaXR0ZXJUeXBlcyA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaTtcclxuXHJcbiAgICAgICAgLy8gZnJvbSBqUXVlcnkgc2VyaWFsaXplIG1ldGhvZFxyXG4gICAgICAgIGNvbnN0IHJTdWJtaXR0YWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGtleWdlbikvaTtcclxuXHJcbiAgICAgICAgLy8gZnJvbSBqUXVlcnkgc2VyaWFsaXplIG1ldGhvZFxyXG4gICAgICAgIGNvbnN0IHJDaGVja2FibGVUeXBlID0gL14oPzpjaGVja2JveHxyYWRpbykkL2k7XHJcbiAgICAgICAgY29uc3Qgck5vbkF1dG9OdW1lcmljVHlwZXMgPSAvXig/OmJ1dHRvbnxjaGVja2JveHxjb2xvcnxkYXRlfGRhdGV0aW1lfGRhdGV0aW1lLWxvY2FsfGVtYWlsfGZpbGV8aW1hZ2V8bW9udGh8bnVtYmVyfHBhc3N3b3JkfHJhZGlvfHJhbmdlfHJlc2V0fHNlYXJjaHxzdWJtaXR8dGltZXx1cmx8d2VlaykvaTtcclxuXHJcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcclxuXHJcbiAgICAgICAgLy8gaW5kZXggb2Ygc3VjY2Vzc2Z1bCBlbGVtZW50c1xyXG4gICAgICAgICQuZWFjaChhbGxGb3JtRWxlbWVudHMsIChpLCBmaWVsZCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZmllbGQubmFtZSAhPT0gJycgJiYgclN1Ym1pdHRhYmxlLnRlc3QoZmllbGQubG9jYWxOYW1lKSAmJiAhclN1Ym1pdHRlclR5cGVzLnRlc3QoZmllbGQudHlwZSkgJiYgIWZpZWxkLmRpc2FibGVkICYmIChmaWVsZC5jaGVja2VkIHx8ICFyQ2hlY2thYmxlVHlwZS50ZXN0KGZpZWxkLnR5cGUpKSkge1xyXG4gICAgICAgICAgICAgICAgc2NJbmRleC5wdXNoKGNvdW50KTtcclxuICAgICAgICAgICAgICAgIGNvdW50Kys7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzY0luZGV4LnB1c2goLTEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIGluZGV4IG9mIGFsbCBpbnB1dHMgdGFncyBleGNlcHQgY2hlY2tib3hcclxuICAgICAgICBjb3VudCA9IDA7XHJcbiAgICAgICAgJC5lYWNoKGFsbEZvcm1FbGVtZW50cywgKGksIGZpZWxkKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChmaWVsZC5sb2NhbE5hbWUgPT09ICdpbnB1dCcgJiYgKGZpZWxkLnR5cGUgPT09ICcnIHx8IGZpZWxkLnR5cGUgPT09ICd0ZXh0JyB8fCBmaWVsZC50eXBlID09PSAnaGlkZGVuJyB8fCBmaWVsZC50eXBlID09PSAndGVsJykpIHtcclxuICAgICAgICAgICAgICAgIGFpSW5kZXgucHVzaChjb3VudCk7XHJcbiAgICAgICAgICAgICAgICBjb3VudCsrO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYWlJbmRleC5wdXNoKC0xKTtcclxuICAgICAgICAgICAgICAgIGlmIChmaWVsZC5sb2NhbE5hbWUgPT09ICdpbnB1dCcgJiYgck5vbkF1dG9OdW1lcmljVHlwZXMudGVzdChmaWVsZC50eXBlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKGdldEFycmF5QmVoYXZpb3IpIHtcclxuICAgICAgICAgICAgY29uc3QgZm9ybUZpZWxkcyA9ICR0aGlzLnNlcmlhbGl6ZUFycmF5KCk7XHJcblxyXG4gICAgICAgICAgICAkLmVhY2goZm9ybUZpZWxkcywgKGksIGZpZWxkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzY0VsZW1lbnQgPSAkLmluQXJyYXkoaSwgc2NJbmRleCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHNjRWxlbWVudCA+IC0xICYmIGFpSW5kZXhbc2NFbGVtZW50XSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVzdElucHV0ID0gJChgZm9ybTplcSgke2Zvcm1JbmRleH0pIGlucHV0OmVxKCR7YWlJbmRleFtzY0VsZW1lbnRdfSlgKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9IHRlc3RJbnB1dC5kYXRhKCdhdXRvTnVtZXJpYycpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZC52YWx1ZSA9IHRlc3RJbnB1dC5hdXRvTnVtZXJpYygnZ2V0Jywgc2V0dGluZ3MubG9jYWxlT3V0cHV0KS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZm9ybUZpZWxkcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGdldFN0cmluZygpIGJlaGF2aW9yXHJcbiAgICAgICAgICAgIGNvbnN0IGZvcm1GaWVsZHMgPSAkdGhpcy5zZXJpYWxpemUoKTtcclxuICAgICAgICAgICAgY29uc3QgZm9ybVBhcnRzID0gZm9ybUZpZWxkcy5zcGxpdCgnJicpO1xyXG5cclxuICAgICAgICAgICAgJC5lYWNoKGZvcm1QYXJ0cywgaSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBbaW5wdXROYW1lLCBpbnB1dFZhbHVlXSA9IGZvcm1QYXJ0c1tpXS5zcGxpdCgnPScpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2NFbGVtZW50ID0gJC5pbkFycmF5KGksIHNjSW5kZXgpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjdXJyZW50IGVsZW1lbnQgaXMgYSB2YWxpZCBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICBpZiAoc2NFbGVtZW50ID4gLTEgJiYgYWlJbmRleFtzY0VsZW1lbnRdID4gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXN0SW5wdXQgPSAkKGBmb3JtOmVxKCR7Zm9ybUluZGV4fSkgaW5wdXQ6ZXEoJHthaUluZGV4W3NjRWxlbWVudF19KWApO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gdGVzdElucHV0LmRhdGEoJ2F1dG9OdW1lcmljJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dFZhbHVlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtb2RpZmllZElucHV0VmFsdWUgPSB0ZXN0SW5wdXQuYXV0b051bWVyaWMoJ2dldCcsIHNldHRpbmdzLmxvY2FsZU91dHB1dCkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1QYXJ0c1tpXSA9IGAke2lucHV0TmFtZX09JHttb2RpZmllZElucHV0VmFsdWV9YDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZm9ybVBhcnRzLmpvaW4oJyYnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNZXRob2RzIHN1cHBvcnRlZCBieSBhdXRvTnVtZXJpY1xyXG4gICAgICovXHJcbiAgICBjb25zdCBtZXRob2RzID0ge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1ldGhvZCB0byBpbml0aWF0ZSBhdXRvTnVtZXJpYyBhbmQgYXR0YWNoIHRoZSBzZXR0aW5ncyAob3B0aW9ucyBjYW4gYmUgcGFzc2VkIGFzIGEgcGFyYW1ldGVyKVxyXG4gICAgICAgICAqIFRoZSBvcHRpb25zIHBhc3NlZCBhcyBhIHBhcmFtZXRlciBpcyBhbiBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgc2V0dGluZ3MgKGllLiB7YVNlcDogXCIuXCIsIGFEZWM6IFwiLFwiLCBhU2lnbjogJ+KCrCAnfSlcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCdpbml0Jyk7ICAgICAgICAgICAgLy8gaW5pdGlhdGUgYXV0b051bWVyaWMgd2l0aCBkZWZhdWx0c1xyXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygpOyAgICAgICAgICAgICAgICAgIC8vIGluaXRpYXRlIGF1dG9OdW1lcmljIHdpdGggZGVmYXVsdHNcclxuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ2luaXQnLCB7b3B0aW9uc30pOyAvLyBpbml0aWF0ZSBhdXRvTnVtZXJpYyB3aXRoIG9wdGlvbnNcclxuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoe29wdGlvbnN9KTsgICAgICAgICAvLyBpbml0aWF0ZSBhdXRvTnVtZXJpYyB3aXRoIG9wdGlvbnNcclxuICAgICAgICAgKi9cclxuICAgICAgICBpbml0KG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gJCh0aGlzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBhdHRlbXB0IHRvIGdyYWIgSFRNTDUgZGF0YSwgaWYgdGhleSBkb24ndCBleGlzdCB3ZSdsbCBnZXQgXCJ1bmRlZmluZWRcIlxyXG4gICAgICAgICAgICAgICAgY29uc3QgdGFnRGF0YSA9ICR0aGlzLmRhdGEoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBzdXBwb3J0ZWQgaW5wdXQgdHlwZVxyXG4gICAgICAgICAgICAgICAgY29uc3QgJGlucHV0ID0gJHRoaXMuaXMoJ2lucHV0W3R5cGU9dGV4dF0sIGlucHV0W3R5cGU9aGlkZGVuXSwgaW5wdXRbdHlwZT10ZWxdLCBpbnB1dDpub3QoW3R5cGVdKScpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGF0dGVtcHQgdG8gZ3JhYiBcImF1dG9OdW1lcmljXCIgc2V0dGluZ3MsIGlmIHRoZXkgZG9uJ3QgZXhpc3QgcmV0dXJucyBcInVuZGVmaW5lZFwiXHJcbiAgICAgICAgICAgICAgICBsZXQgc2V0dGluZ3MgPSAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIElmIHdlIGNvdWxkbid0IGdyYWIgc2V0dGluZ3MsIGNyZWF0ZSB0aGVtIGZyb20gZGVmYXVsdHMgYW5kIHBhc3NlZCBvcHRpb25zXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzID0gJC5leHRlbmQoe30sICQuZm4uYXV0b051bWVyaWMuZGVmYXVsdHMsIHRhZ0RhdGEsIG9wdGlvbnMsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25PZmYgICAgICAgICAgIDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bk9uY2UgICAgICAgICA6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByYXdWYWx1ZSAgICAgICAgOiAnJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhaWxpbmdOZWdhdGl2ZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0Rml4ICAgICAgICA6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0lucHV0ICAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpcCAgICAgICAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdMaXN0ICAgICAgICAgOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnY2FwdGlvbicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnY2l0ZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnY29kZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnY29uc3QnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RkJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkZWwnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RpdicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGZuJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkdCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZW0nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2gxJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdoMicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaDMnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2g0JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdoNScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaDYnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2lucycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAna2RiJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdsYWJlbCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbGknLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29wdGlvbicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb3V0cHV0JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdwJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdxJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzYW1wbGUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3NwYW4nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3N0cm9uZycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RoJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd1JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTWVyZ2UgZGVmYXVsdHMsIHRhZ0RhdGEgYW5kIG9wdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuYURlYyA9PT0gc2V0dGluZ3MuYVNlcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBhdXRvTnVtZXJpYyB3aWxsIG5vdCBmdW5jdGlvbiBwcm9wZXJseSB3aGVuIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBhRGVjIFske3NldHRpbmdzLmFEZWN9XSBhbmQgdGhlIHRob3VzYW5kIHNlcGFyYXRvciBhU2VwIFske3NldHRpbmdzLmFTZXB9XSBhcmUgdGhlIHNhbWUgY2hhcmFjdGVyYCwgc2V0dGluZ3MuZGVidWcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgJC5lYWNoKHNldHRpbmdzLCAoa2V5LCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09ICd0cnVlJyB8fCB2YWx1ZSA9PT0gJ2ZhbHNlJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Nba2V5XSA9IEJvb2xlYW4odmFsdWUgPT09ICd0cnVlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2F2ZSBvdXIgbmV3IHNldHRpbmdzXHJcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIG9yaWdpbmFsIHNldHRpbmdzIHNhdmVkIGZvciB1c2Ugd2hlbiBlRGVjLCBzY2FsZURpdmlzb3IgJiBuU2VwIG9wdGlvbnMgYXJlIGJlaW5nIHVzZWRcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzID0gb3JpZ2luYWxTZXR0aW5ncyhzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICBsZXQgaG9sZGVyID0gZ2V0SG9sZGVyKCR0aGlzLCBzZXR0aW5ncyk7XHJcblxyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MubURlYyA9IChzZXR0aW5ncy5zY2FsZURpdmlzb3IgJiYgc2V0dGluZ3Muc2NhbGVEZWNpbWFsKSA/IHNldHRpbmdzLnNjYWxlRGVjaW1hbCA6IHNldHRpbmdzLm1EZWM7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gY2hlY2tzIGZvciBub24tc3VwcG9ydGVkIGlucHV0IHR5cGVzXHJcbiAgICAgICAgICAgICAgICBpZiAoISRpbnB1dCAmJiAkdGhpcy5wcm9wKCd0YWdOYW1lJykudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBpbnB1dCB0eXBlIFwiJHskdGhpcy5wcm9wKCd0eXBlJyl9XCIgaXMgbm90IHN1cHBvcnRlZCBieSBhdXRvTnVtZXJpY2AsIHNldHRpbmdzLmRlYnVnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBjaGVja3MgZm9yIG5vbi1zdXBwb3J0ZWQgdGFnc1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0luQXJyYXkoJHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCksIHNldHRpbmdzLnRhZ0xpc3QpICYmICR0aGlzLnByb3AoJ3RhZ05hbWUnKS50b0xvd2VyQ2FzZSgpICE9PSAnaW5wdXQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIDwkeyR0aGlzLnByb3AoJ3RhZ05hbWUnKS50b0xvd2VyQ2FzZSgpfT4gdGFnIGlzIG5vdCBzdXBwb3J0ZWQgYnkgYXV0b051bWVyaWNgLCBzZXR0aW5ncy5kZWJ1Zyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy9UT0RPIFJlcGxhY2UgdGhlIHR3byBuZXh0IHRlc3RzIHdpdGggYSBgdmFsaWRhdGVPcHRpb25zKClgIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAvLyBjaGVja3MgaWYgdGhlIGRlY2ltYWwgYW5kIHRob3VzYW5kIGFyZSBjaGFyYWN0ZXJzIGFyZSB0aGUgc2FtZVxyXG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmFEZWMgPT09IHNldHRpbmdzLmFTZXApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBhdXRvTnVtZXJpYyB3aWxsIG5vdCBmdW5jdGlvbiBwcm9wZXJseSB3aGVuIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBhRGVjIFske3NldHRpbmdzLmFEZWN9XSBhbmQgdGhlIHRob3VzYW5kIHNlcGFyYXRvciBhU2VwIFske3NldHRpbmdzLmFTZXB9XSBhcmUgdGhlIHNhbWUgY2hhcmFjdGVyYCwgc2V0dGluZ3MuZGVidWcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIGNoZWNrcyB0aGUgZXh0ZW5kZWQgZGVjaW1hbCBwbGFjZXMgXCJlRGVjXCIgaXMgZ3JlYXRlciB0aGFuIHRoZSBub3JtYWwgZGVjaW1hbCBwbGFjZXMgXCJtRGVjXCJcclxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5lRGVjIDwgc2V0dGluZ3MubURlYyAmJiBzZXR0aW5ncy5lRGVjICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgYXV0b051bWVyaWMgd2lsbCBub3QgZnVuY3Rpb24gcHJvcGVybHkgd2hlbiB0aGUgZXh0ZW5kZWQgZGVjaW1hbCBwbGFjZXMgZURlYyBbJHtzZXR0aW5ncy5lRGVjfV0gaXMgZ3JlYXRlciB0aGFuIHRoZSBtRGVjIFske3NldHRpbmdzLm1EZWN9XSB2YWx1ZWAsIHNldHRpbmdzLmRlYnVnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyByb3V0aW5lIHRvIGZvcm1hdCBkZWZhdWx0IHZhbHVlIG9uIHBhZ2UgbG9hZFxyXG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLnJ1bk9uY2UgPT09IGZhbHNlICYmIHNldHRpbmdzLmFGb3JtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNldFZhbHVlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoJGlucHV0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9ICR0aGlzLnZhbCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAgICAgICAgICogSWYgdGhlIGlucHV0IHZhbHVlIGhhcyBiZWVuIHNldCBieSB0aGUgZGV2LCBidXQgbm90IGRpcmVjdGx5IGFzIGFuIGF0dHJpYnV0ZSBpbiB0aGUgaHRtbCwgdGhlbiBpdCB0YWtlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBwcmVjZWRlbmNlIGFuZCBzaG91bGQgZ2V0IGZvcm1hdHRlZCBvbiBpbml0IChpZiB0aGF0IHRoaXMgaW5wdXQgdmFsdWUgaXMgYSB2YWxpZCBudW1iZXIgYW5kIHRoYXQgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGRldmVsb3BlciB3YW50cyBpdCBmb3JtYXR0ZWQgb24gaW5pdCAoY2YuIGBzZXR0aW5ncy5hRm9ybWApKS4gTm90ZTsgdGhpcyBpcyB0cnVlIHdoYXRldmVyIHRoZSBkZXZlbG9wZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICogaGFzIHNldCBmb3IgYGRhdGEtYW4tZGVmYXVsdGAgaW4gdGhlIGh0bWwgKGFzcC5uZXQgdXNlcnMpLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBJbiBvdGhlciB3b3JkcyA6IGlmIGBhbkRlZmF1bHRgIGlzIG5vdCBudWxsLCBpdCBtZWFucyB0aGUgZGV2ZWxvcGVyIGlzIHRyeWluZyB0byBwcmV2ZW50IHBvc3RiYWNrIHByb2JsZW1zLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBCdXQgaWYgYGlucHV0LnZhbHVlYCBpcyBzZXQgdG8gYSBudW1iZXIsIGFuZCBgJHRoaXMuYXR0cigndmFsdWUnKWAgaXMgbm90IHNldCwgdGhlbiBpdCBtZWFucyB0aGUgZGV2IGhhc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBjaGFuZ2VkIHRoZSBpbnB1dCB2YWx1ZSwgYW5kIHRoZW4gaXQgbWVhbnMgd2Ugc2hvdWxkIG5vdCBvdmVyd3JpdGUgaGlzIG93biBkZWNpc2lvbiB0byBkbyBzby5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICogSGVuY2UsIGlmIGBhbkRlZmF1bHRgIGlzIG5vdCBudWxsLCBidXQgYGlucHV0LnZhbHVlYCBpcyBhIG51bWJlciBhbmQgYCR0aGlzLmF0dHIoJ3ZhbHVlJylgIGlzIG5vdCBzZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHdlIHNob3VsZCBpZ25vcmUgYGFuRGVmYXVsdGAgYWx0b2dldGhlci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5hRm9ybSAmJiBjdXJyZW50VmFsdWUgIT09ICcnICYmIGlzVW5kZWZpbmVkT3JOdWxsT3JFbXB0eSgkdGhpcy5hdHRyKCd2YWx1ZScpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGB2YWx1ZWAgaXMgdmFsaWQgb3Igbm90XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXN0ZWRDdXJyZW50VmFsdWUgPSBwYXJzZUZsb2F0KGN1cnJlbnRWYWx1ZS5yZXBsYWNlKCcsJywgJy4nKSk7IC8vVE9ETyBSZXBsYWNlIHdoYXRldmVyIGxvY2FsZSBjaGFyYWN0ZXIgaXMgdXNlZCBieSBhICcuJywgYW5kIG5vdCBvbmx5IHRoZSBjb21tYSAnLCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNOYU4odGVzdGVkQ3VycmVudFZhbHVlKSAmJiBJbmZpbml0eSAhPT0gdGVzdGVkQ3VycmVudFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsIHRlc3RlZEN1cnJlbnRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIG5vdCwgaW5mb3JtIHRoZSBkZXZlbG9wZXIgdGhhdCBub3RoaW5nIHVzYWJsZSBoYXMgYmVlbiBwcm92aWRlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSB2YWx1ZSBbJHtjdXJyZW50VmFsdWV9XSB1c2VkIGluIHRoZSBpbnB1dCBpcyBub3QgYSB2YWxpZCB2YWx1ZSBhdXRvTnVtZXJpYyBjYW4gd29yayB3aXRoLmAsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIENoZWNrcyBmb3IgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogLSBwYWdlIHJlbG9hZCBmcm9tIGJhY2sgYnV0dG9uLCBhbmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIC0gQVNQLm5ldCBmb3JtIHBvc3QgYmFja1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICBUaGUgZm9sbG93aW5nIEhUTUwgZGF0YSBhdHRyaWJ1dGUgaXMgUkVRVUlSRUQgKGRhdGEtYW4tZGVmYXVsdD1cInNhbWUgdmFsdWUgYXMgdGhlIHZhbHVlIGF0dHJpYnV0ZVwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICBleGFtcGxlOiA8YXNwOlRleHRCb3ggcnVuYXQ9XCJzZXJ2ZXJcIiBpZD1cInNvbWVJRFwiIHRleHQ9XCIxMjM0LjU2XCIgZGF0YS1hbi1kZWZhdWx0PVwiMTIzNC41NlwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gUmVwbGFjZSB3aGF0ZXZlciBsb2NhbGUgY2hhcmFjdGVyIGlzIHVzZWQgYnkgYSAnLicsIGFuZCBub3Qgb25seSB0aGUgY29tbWEgJywnLCBiYXNlZCBvbiB0aGUgbG9jYWxlIHVzZWQgYnkgdGhlIHVzZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoc2V0dGluZ3MuYW5EZWZhdWx0ICE9PSBudWxsICYmIHNldHRpbmdzLmFuRGVmYXVsdC50b1N0cmluZygpICE9PSBjdXJyZW50VmFsdWUpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzZXR0aW5ncy5hbkRlZmF1bHQgPT09IG51bGwgJiYgY3VycmVudFZhbHVlICE9PSAnJyAmJiBjdXJyZW50VmFsdWUgIT09ICR0aGlzLmF0dHIoJ3ZhbHVlJykpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjdXJyZW50VmFsdWUgIT09ICcnICYmICR0aGlzLmF0dHIoJ3R5cGUnKSA9PT0gJ2hpZGRlbicgJiYgISQuaXNOdW1lcmljKGN1cnJlbnRWYWx1ZS5yZXBsYWNlKCcsJywgJy4nKSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmVEZWMgIT09IG51bGwgJiYgc2V0dGluZ3MuYVN0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSBhdXRvU2F2ZSgkdGhpcywgc2V0dGluZ3MsICdnZXQnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLnNjYWxlRGl2aXNvciAmJiBzZXR0aW5ncy5hU3Rvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5yYXdWYWx1ZSA9IGF1dG9TYXZlKCR0aGlzLCBzZXR0aW5ncywgJ2dldCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNldHRpbmdzLmFTdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0b1N0cmlwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MubkJyYWNrZXQgIT09IG51bGwgJiYgc2V0dGluZ3MuYU5lZyAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm9uT2ZmID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvU3RyaXAgPSBuZWdhdGl2ZUJyYWNrZXQoY3VycmVudFZhbHVlLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b1N0cmlwID0gY3VycmVudFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gKChzZXR0aW5ncy5wTmVnID09PSAncycgfHwgKHNldHRpbmdzLnBTaWduID09PSAncycgJiYgc2V0dGluZ3MucE5lZyAhPT0gJ3AnKSkgJiYgc2V0dGluZ3MuYU5lZyAhPT0gJycgJiYgY29udGFpbnMoY3VycmVudFZhbHVlLCAnLScpKT8nLScgKyBhdXRvU3RyaXAodG9TdHJpcCwgc2V0dGluZ3MpOmF1dG9TdHJpcCh0b1N0cmlwLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFZhbHVlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUgPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLndFbXB0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ZvY3VzJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYWx3YXlzJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudmFsKHNldHRpbmdzLmFTaWduKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnemVybyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCAnMCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0IDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzZXRWYWx1ZSAmJiBjdXJyZW50VmFsdWUgPT09ICR0aGlzLmF0dHIoJ3ZhbHVlJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCBjdXJyZW50VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNJbkFycmF5KCR0aGlzLnByb3AoJ3RhZ05hbWUnKS50b0xvd2VyQ2FzZSgpLCBzZXR0aW5ncy50YWdMaXN0KSAmJiAkdGhpcy50ZXh0KCkgIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5hbkRlZmF1bHQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5hbkRlZmF1bHQgPT09ICR0aGlzLnRleHQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCAkdGhpcy50ZXh0KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsICR0aGlzLnRleHQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MucnVuT25jZSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9UT0RPIEV4dHJhY3QgdGhlIGV2ZW50IGxpc3RlbmVycyB0byBhbm90aGVyIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAvLyBpbnB1dCB0eXBlcyBzdXBwb3J0ZWQgXCJ0ZXh0XCIsIFwiaGlkZGVuXCIsIFwidGVsXCIgYW5kIG5vIHR5cGVcclxuICAgICAgICAgICAgICAgIGlmICgkaW5wdXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAkdGhpcy5vbignZm9jdXNpbi5hdXRvTnVtZXJpYycsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyID0gZ2V0SG9sZGVyKCR0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgJHNldHRpbmdzID0gaG9sZGVyLnNldHRpbmdzQ2xvbmU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICRzZXR0aW5ncy5vbk9mZiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkc2V0dGluZ3MubkJyYWNrZXQgIT09IG51bGwgJiYgJHNldHRpbmdzLmFOZWcgIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy52YWwobmVnYXRpdmVCcmFja2V0KCR0aGlzLnZhbCgpLCAkc2V0dGluZ3MpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHNldHRpbmdzLmVEZWMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzZXR0aW5ncy5tRGVjID0gJHNldHRpbmdzLmVEZWM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgJHNldHRpbmdzLnJhd1ZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgkc2V0dGluZ3Muc2NhbGVEaXZpc29yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2V0dGluZ3MubURlYyA9ICRzZXR0aW5ncy5vRGVjO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsICRzZXR0aW5ncy5yYXdWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoJHNldHRpbmdzLm5TZXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzZXR0aW5ncy5hU2VwID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2V0dGluZ3MuYVNpZ24gPSAnJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzZXR0aW5ncy5hU3VmZml4ID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgJHNldHRpbmdzLnJhd1ZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgocmVzdWx0ID0gYXV0b1N0cmlwKCR0aGlzLnZhbCgpLCAkc2V0dGluZ3MpKSAhPT0gJHNldHRpbmdzLnJhd1ZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgcmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIuaW5WYWwgPSAkdGhpcy52YWwoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLmxhc3RWYWwgPSBob2xkZXIuaW5WYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9uRW1wdHkgPSBjaGVja0VtcHR5KGhvbGRlci5pblZhbCwgJHNldHRpbmdzLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChvbkVtcHR5ICE9PSBudWxsICYmIG9uRW1wdHkgIT09ICcnKSAmJiAkc2V0dGluZ3Mud0VtcHR5ID09PSAnZm9jdXMnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy52YWwob25FbXB0eSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMub24oJ2tleWRvd24uYXV0b051bWVyaWMnLCBlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyID0gZ2V0SG9sZGVyKCR0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvbGRlci50aGF0LnJlYWRPbmx5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIucHJvY2Vzc2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiAvLyBUaGUgY29kZSBiZWxvdyBhbGxvd3MgdGhlIFwiZW50ZXJcIiBrZXlkb3duIHRvIHRocm93IGEgY2hhbmdlKCkgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0ga2V5Q29kZS5FbnRlciAmJiBob2xkZXIuaW5WYWwgIT09ICR0aGlzLnZhbCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5jaGFuZ2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlci5pblZhbCA9ICR0aGlzLnZhbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9ICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlci5pbml0KGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG9sZGVyLnNraXBBbHdheXMoZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlci5wcm9jZXNzZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvbGRlci5wcm9jZXNzQWx3YXlzKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlci5wcm9jZXNzZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLmZvcm1hdFF1aWNrKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gJHRoaXMudmFsKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGN1cnJlbnRWYWx1ZSAhPT0gaG9sZGVyLmxhc3RWYWwpICYmIGhvbGRlci5zZXR0aW5nc0Nsb25lLnRocm93SW5wdXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aHJvd3MgaW5wdXQgZXZlbnQgaW4gZGVsZXRpb24gY2hhcmFjdGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudHJpZ2dlcignaW5wdXQnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlci5sYXN0VmFsID0gY3VycmVudFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLnNldHRpbmdzQ2xvbmUudGhyb3dJbnB1dCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLmZvcm1hdHRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMub24oJ2tleXByZXNzLmF1dG9OdW1lcmljJywgZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggZml4IGZvciBTaGlmdCAmJiBpbnNlcnQgcGFzdGUgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuc2hpZnRLZXkgJiYgZS5rZXlDb2RlID09PSBrZXlDb2RlLkluc2VydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlciA9IGdldEhvbGRlcigkdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZCA9IGhvbGRlci5wcm9jZXNzZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlci5pbml0KGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG9sZGVyLnNraXBBbHdheXMoZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG9sZGVyLnByb2Nlc3NBbHdheXMoKSB8fCBob2xkZXIucHJvY2Vzc0tleXByZXNzKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlci5mb3JtYXRRdWljayhlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9ICR0aGlzLnZhbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChjdXJyZW50VmFsdWUgIT09IGhvbGRlci5sYXN0VmFsKSAmJiBob2xkZXIuc2V0dGluZ3NDbG9uZS50aHJvd0lucHV0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhyb3dzIGlucHV0IGV2ZW50IG9uIGFkZGluZyBjaGFyYWN0ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy50cmlnZ2VyKCdpbnB1dCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLmxhc3RWYWwgPSBjdXJyZW50VmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIuc2V0dGluZ3NDbG9uZS50aHJvd0lucHV0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIuZm9ybWF0dGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICR0aGlzLm9uKCdrZXl1cC5hdXRvTnVtZXJpYycsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyID0gZ2V0SG9sZGVyKCR0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLmluaXQoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNraXAgPSBob2xkZXIuc2tpcEFsd2F5cyhlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFiID0gaG9sZGVyLmtkQ29kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLmtkQ29kZSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBob2xkZXIudmFsdWVQYXJ0c0JlZm9yZVBhc3RlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkZWQgdG8gcHJvcGVybHkgcGxhY2UgdGhlIGNhcmV0IHdoZW4gb25seSB0aGUgY3VycmVuY3kgc2lnbiBpcyBwcmVzZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkdGhpc1swXS52YWx1ZSA9PT0gaG9sZGVyLnNldHRpbmdzQ2xvbmUuYVNpZ24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChob2xkZXIuc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3MnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbih0aGlzLCAwLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbih0aGlzLCBob2xkZXIuc2V0dGluZ3NDbG9uZS5hU2lnbi5sZW5ndGgsIGhvbGRlci5zZXR0aW5nc0Nsb25lLmFTaWduLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGFiID09PSBrZXlDb2RlLlRhYikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbih0aGlzLCAwLCAkdGhpcy52YWwoKS5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkdGhpc1swXS52YWx1ZSA9PT0gaG9sZGVyLnNldHRpbmdzQ2xvbmUuYVN1ZmZpeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbih0aGlzLCAwLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG9sZGVyLnNldHRpbmdzQ2xvbmUucmF3VmFsdWUgPT09ICcnICYmIGhvbGRlci5zZXR0aW5nc0Nsb25lLmFTaWduICE9PSAnJyAmJiBob2xkZXIuc2V0dGluZ3NDbG9uZS5hU3VmZml4ICE9PSAnJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbih0aGlzLCAwLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2F2ZXMgdGhlIGV4dGVuZGVkIGRlY2ltYWwgdG8gcHJlc2VydmUgdGhlIGRhdGEgd2hlbiBuYXZpZ2F0aW5nIGF3YXkgZnJvbSB0aGUgcGFnZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG9sZGVyLnNldHRpbmdzQ2xvbmUuZURlYyAhPT0gbnVsbCAmJiBob2xkZXIuc2V0dGluZ3NDbG9uZS5hU3Rvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0b1NhdmUoJHRoaXMsIHNldHRpbmdzLCAnc2V0Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNraXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlID09PSAnJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFob2xkZXIuZm9ybWF0dGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIuZm9ybWF0UXVpY2soZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMub24oJ2ZvY3Vzb3V0LmF1dG9OdW1lcmljJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIgPSBnZXRIb2xkZXIoJHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSAkdGhpcy52YWwoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpZ1ZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0ICRzZXR0aW5ncyA9IGhvbGRlci5zZXR0aW5nc0Nsb25lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkc2V0dGluZ3Mub25PZmYgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRzZXR0aW5ncy5hU3Rvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0b1NhdmUoJHRoaXMsICRzZXR0aW5ncywgJ3NldCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkc2V0dGluZ3MublNlcCA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNldHRpbmdzLmFTZXAgPSAkc2V0dGluZ3Mub1NlcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzZXR0aW5ncy5hU2lnbiA9ICRzZXR0aW5ncy5vU2lnbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzZXR0aW5ncy5hU3VmZml4ID0gJHNldHRpbmdzLm9TdWZmaXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRzZXR0aW5ncy5lRGVjICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2V0dGluZ3MubURlYyA9ICRzZXR0aW5ncy5vRGVjO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNldHRpbmdzLmFQYWQgPSAkc2V0dGluZ3Mub1BhZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzZXR0aW5ncy5uQnJhY2tldCA9ICRzZXR0aW5ncy5vQnJhY2tldDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGF1dG9TdHJpcCh2YWx1ZSwgJHNldHRpbmdzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRzZXR0aW5ncy50cmFpbGluZ05lZ2F0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnLScgKyB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2V0dGluZ3MudHJhaWxpbmdOZWdhdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW21pblRlc3QsIG1heFRlc3RdID0gYXV0b0NoZWNrKHZhbHVlLCAkc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrRW1wdHkodmFsdWUsICRzZXR0aW5ncykgPT09IG51bGwgJiYgbWluVGVzdCAmJiBtYXhUZXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBmaXhOdW1iZXIodmFsdWUsICRzZXR0aW5ncy5hRGVjLCAkc2V0dGluZ3MuYU5lZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNldHRpbmdzLnJhd1ZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRzZXR0aW5ncy5zY2FsZURpdmlzb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAvICRzZXR0aW5ncy5zY2FsZURpdmlzb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNldHRpbmdzLm1EZWMgPSAoJHNldHRpbmdzLnNjYWxlRGl2aXNvciAmJiAkc2V0dGluZ3Muc2NhbGVEZWNpbWFsKSA/ICskc2V0dGluZ3Muc2NhbGVEZWNpbWFsIDogJHNldHRpbmdzLm1EZWM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhdXRvUm91bmQodmFsdWUsICRzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwcmVzZW50TnVtYmVyKHZhbHVlLCAkc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1pblRlc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudHJpZ2dlcignYXV0b051bWVyaWM6bWluRXhjZWVkZWQnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXhUZXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLnRyaWdnZXIoJ2F1dG9OdW1lcmljOm1heEV4Y2VlZGVkJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJHNldHRpbmdzLnJhd1ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRzZXR0aW5ncy53RW1wdHkgPT09ICd6ZXJvJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzZXR0aW5ncy5yYXdWYWx1ZSA9ICcwJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGF1dG9Sb3VuZCgnMCcsICRzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzZXR0aW5ncy5yYXdWYWx1ZSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBncm91cGVkVmFsdWUgPSBjaGVja0VtcHR5KHZhbHVlLCAkc2V0dGluZ3MsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdyb3VwZWRWYWx1ZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBlZFZhbHVlID0gYXV0b0dyb3VwKHZhbHVlLCAkc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChncm91cGVkVmFsdWUgIT09IG9yaWdWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBlZFZhbHVlID0gKCRzZXR0aW5ncy5zY2FsZVN5bWJvbCkgPyBncm91cGVkVmFsdWUgKyAkc2V0dGluZ3Muc2NhbGVTeW1ib2wgOiBncm91cGVkVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy52YWwoZ3JvdXBlZFZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ3JvdXBlZFZhbHVlICE9PSBob2xkZXIuaW5WYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLmNoYW5nZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGhvbGRlci5pblZhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAkdGhpcy5vbigncGFzdGUnLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vRklYTUUgQWZ0ZXIgYSBwYXN0ZSwgdGhlIGNhcmV0IGlzIHB1dCBvbiB0aGUgZmFyIHJpZ2h0IG9mIHRoZSBpbnB1dCwgaXQgc2hvdWxkIGJlIHNldCB0byBzb21ldGhpbmcgbGlrZSBgbmV3Q2FyZXRQb3NpdGlvbiA9IG9sZENhcmV0UG9zaXRpb24gKyBwYXN0ZVRleHQubGVuZ3RoO2AsIHdoaWxlIHRha2luZyBpbnRvIGFjY291bnQgdGhlIHRob3VzYW5kIHNlcGFyYXRvcnMgYW5kIHRoZSBkZWNpbWFsIGNoYXJhY3RlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlciA9IGdldEhvbGRlcigkdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHByZXBhcmUodGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF1dG9TdHJpcCh0ZXh0LCBob2xkZXIuc2V0dGluZ3NDbG9uZSkucmVwbGFjZShob2xkZXIuc2V0dGluZ3NDbG9uZS5hRGVjLCAnLicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBpc1ZhbGlkKHRleHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0ICE9PSAnJyAmJiAhaXNOYU4odGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9sZFJhd1ZhbHVlID0gJHRoaXMuYXV0b051bWVyaWMoJ2dldCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0aGlzLnZhbHVlIHx8ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3Rpb25TdGFydCA9IHRoaXMuc2VsZWN0aW9uU3RhcnQgfHwgMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uRW5kID0gdGhpcy5zZWxlY3Rpb25FbmQgfHwgMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gY3VycmVudFZhbHVlLnN1YnN0cmluZygwLCBzZWxlY3Rpb25TdGFydCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1ZmZpeCA9IGN1cnJlbnRWYWx1ZS5zdWJzdHJpbmcoc2VsZWN0aW9uRW5kLCBjdXJyZW50VmFsdWUubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFzdGVkVGV4dCA9IHByZXBhcmUoZS5vcmlnaW5hbEV2ZW50LmNsaXBib2FyZERhdGEuZ2V0RGF0YSgndGV4dC9wbGFpbicpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsaWQocGFzdGVkVGV4dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gcHJlcGFyZShwcmVmaXggKyBOdW1iZXIocGFzdGVkVGV4dCkudmFsdWVPZigpICsgc3VmZml4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkKG5ld1ZhbHVlKSAmJiBOdW1iZXIob2xkUmF3VmFsdWUpLnZhbHVlT2YoKSAhPT0gTnVtYmVyKG5ld1ZhbHVlKS52YWx1ZU9mKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgbmV3VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLnRyaWdnZXIoJ2lucHV0Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gc2VsZWN0aW9uRW5kO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICR0aGlzLmNsb3Nlc3QoJ2Zvcm0nKS5vbignc3VibWl0LmF1dG9OdW1lcmljJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIgPSBnZXRIb2xkZXIoJHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG9sZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCAkc2V0dGluZ3MgPSBob2xkZXIuc2V0dGluZ3NDbG9uZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkc2V0dGluZ3MudW5TZXRPblN1Ym1pdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLnZhbCgkc2V0dGluZ3MucmF3VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIG1ldGhvZCB0byByZW1vdmUgc2V0dGluZ3MgYW5kIHN0b3AgYXV0b051bWVyaWMoKSAtIGRvZXMgbm90IHJlbW92ZSB0aGUgZm9ybWF0dGluZ1xyXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYyhcImRlc3Ryb3lcIik7IC8vIGRlc3Ryb3lzIGF1dG9OdW1lcmljXHJcbiAgICAgICAgICogbm8gcGFyYW1ldGVycyBhY2NlcHRlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAkKHRoaXMpLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCAkdGhpcyA9IGF1dG9HZXQoJCh0aGlzKSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICR0aGlzLnZhbCgnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXV0b1NhdmUoJHRoaXMsIHNldHRpbmdzLCAnd2lwZScpO1xyXG4gICAgICAgICAgICAgICAgICAgICR0aGlzLnJlbW92ZURhdGEoJ2F1dG9OdW1lcmljJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMub2ZmKCcuYXV0b051bWVyaWMnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogbWV0aG9kIHRvIGNsZWFyIHRoZSB2YWx1ZSBhbmQgc2Vzc2lvblN0b3JhZ2Ugb3IgY29va2llIGRlcGVuZGluZyBvbiBicm93c2VyIHN1cHBvcnRzXHJcbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKFwid2lwZVwiKTsgLy8gcmVtb3ZlcyBzZXNzaW9uIHN0b3JhZ2UgYW5kIGNvb2tpZXMgZnJvbSBtZW1vcnlcclxuICAgICAgICAgKiBubyBwYXJhbWV0ZXJzIGFjY2VwdGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgd2lwZSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICQodGhpcykuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gYXV0b0dldCgkKHRoaXMpKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMudmFsKCcnKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5yYXdWYWx1ZSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIGF1dG9TYXZlKCR0aGlzLCBzZXR0aW5ncywgJ3dpcGUnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTWV0aG9kIHRoYXQgdXBkYXRlcyB0aGUgYXV0b051bWVyaWMgc2V0dGluZ3NcclxuICAgICAgICAgKiBJdCBjYW4gYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIGlmIG5lZWRlZFxyXG4gICAgICAgICAqIFRoZSBvcHRpb25zIHBhc3NlZCBhcyBhIHBhcmFtZXRlciBpcyBhbiBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgc2V0dGluZ3MgKGllLiB7YVNlcDogXCIuXCIsIGFEZWM6IFwiLFwiLCBhU2lnbjogJ+KCrCAnfSlcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB1c2FnZSAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoXCJ1cGRhdGVcIiwge29wdGlvbnN9KTsgLy8gdXBkYXRlcyB0aGUgc2V0dGluZ3NcclxuICAgICAgICAgKi9cclxuICAgICAgICB1cGRhdGUob3B0aW9ucykge1xyXG4gICAgICAgICAgICByZXR1cm4gJCh0aGlzKS5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgJHRoaXMgPSBhdXRvR2V0KCQodGhpcykpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHNldHRpbmdzID0gJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYEluaXRpYWxpemluZyBhdXRvTnVtZXJpYyBpcyByZXF1aXJlZCBwcmlvciB0byBjYWxsaW5nIHRoZSBcInVwZGF0ZVwiIG1ldGhvZGAsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyaXAgPSAkdGhpcy5hdXRvTnVtZXJpYygnZ2V0Jyk7XHJcbiAgICAgICAgICAgICAgICBzZXR0aW5ncyA9ICQuZXh0ZW5kKHNldHRpbmdzLCBvcHRpb25zKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3Muc2NhbGVEaXZpc29yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MubURlYyA9IChzZXR0aW5ncy5zY2FsZURlY2ltYWwpID8gc2V0dGluZ3Muc2NhbGVEZWNpbWFsIDogc2V0dGluZ3MubURlYztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNldHRpbmdzID0gb3JpZ2luYWxTZXR0aW5ncyhzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICBnZXRIb2xkZXIoJHRoaXMsIHNldHRpbmdzLCB0cnVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuYURlYyA9PT0gc2V0dGluZ3MuYVNlcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYGF1dG9OdW1lcmljIHdpbGwgbm90IGZ1bmN0aW9uIHByb3Blcmx5IHdoZW4gdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGFEZWM6IFwiJHtzZXR0aW5ncy5hRGVjfVwiIGFuZCB0aG91c2FuZCBzZXBhcmF0b3IgYVNlcDogXCIke3NldHRpbmdzLmFTZXB9XCIgYXJlIHRoZSBzYW1lIGNoYXJhY3RlcmAsIHNldHRpbmdzLmRlYnVnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJywgc2V0dGluZ3MpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICgkdGhpcy52YWwoKSAhPT0gJycgfHwgJHRoaXMudGV4dCgpICE9PSAnJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkdGhpcy5hdXRvTnVtZXJpYygnc2V0Jywgc3RyaXApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNZXRob2QgdG8gZm9ybWF0IHRoZSB2YWx1ZSBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIuXHJcbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCdzZXQnLCAndmFsdWUnKTsgLy8gZm9ybWF0cyB0aGUgdmFsdWUgYmVpbmcgcGFzc2VkIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyXHJcbiAgICAgICAgICogSWYgdGhlIHZhbHVlIGlzIHBhc3NlZCBhcyBhIHN0cmluZywgaXQgY2FuIGJlIGFuIGludGVnZXIgJzEyMzQnIG9yIGEgZG91YmxlICcxMjM0LjU2Nzg5J1xyXG4gICAgICAgICAqIGFuZCBtdXN0IGNvbnRhaW4gb25seSBudW1iZXJzIGFuZCBvbmUgZGVjaW1hbCAocGVyaW9kKSBjaGFyYWN0ZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBzZXQodmFsdWVJbikge1xyXG4gICAgICAgICAgICByZXR1cm4gJCh0aGlzKS5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlSW4gPT09IG51bGwgfHwgaXNVbmRlZmluZWQodmFsdWVJbikpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCAkdGhpcyA9IGF1dG9HZXQoJCh0aGlzKSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCAkaW5wdXQgPSAkdGhpcy5pcygnaW5wdXRbdHlwZT10ZXh0XSwgaW5wdXRbdHlwZT1oaWRkZW5dLCBpbnB1dFt0eXBlPXRlbF0sIGlucHV0Om5vdChbdHlwZV0pJyk7XHJcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSB2YWx1ZUluLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYEluaXRpYWxpemluZyBhdXRvTnVtZXJpYyBpcyByZXF1aXJlZCBwcmlvciB0byBjYWxsaW5nIHRoZSBcInNldFwiIG1ldGhvZGAsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIGFsbG93cyBsb2NhbGUgZGVjaW1hbCBzZXBhcmF0b3IgdG8gYmUgYSBjb21tYSAtIG5vIHRob3VzYW5kIHNlcGFyYXRvciBhbGxvd2VkXHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGZyb21Mb2NhbGUodmFsdWUpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRocm93cyBhbiBlcnJvciBpZiB0aGUgdmFsdWUgYmVpbmcgc2V0IGlzIG5vdCBudW1lcmljXHJcbiAgICAgICAgICAgICAgICBpZiAoISQuaXNOdW1lcmljKE51bWJlcih2YWx1ZSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHZhbHVlIFwiJHt2YWx1ZX1cIiBiZWluZyBcInNldFwiIGlzIG5vdCBudW1lcmljIGFuZCBoYXMgY2F1c2VkIGEgZXJyb3IgdG8gYmUgdGhyb3duYCwgc2V0dGluZ3MuZGVidWcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkdGhpcy52YWwoJycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBbbWluVGVzdCwgbWF4VGVzdF0gPSBhdXRvQ2hlY2sodmFsdWUsIHNldHRpbmdzKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWluVGVzdCAmJiBtYXhUZXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkaW5wdXQgJiYgKHNldHRpbmdzLmVEZWMgfHwgc2V0dGluZ3Muc2NhbGVEaXZpc29yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2tzIGlmIHRoZSB2YWx1ZSBmYWxscyB3aXRoaW4gdGhlIG1pbiBtYXggcmFuZ2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRpbnB1dCB8fCBpc0luQXJyYXkoJHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCksIHNldHRpbmdzLnRhZ0xpc3QpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3Muc2NhbGVEaXZpc29yICYmICFzZXR0aW5ncy5vbk9mZikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgLyBzZXR0aW5ncy5zY2FsZURpdmlzb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm1EZWMgPSAoc2V0dGluZ3Muc2NhbGVEZWNpbWFsKSA/IHNldHRpbmdzLnNjYWxlRGVjaW1hbCA6IHNldHRpbmdzLm1EZWM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGF1dG9Sb3VuZCh2YWx1ZSwgc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmVEZWMgPT09IG51bGwgJiYgc2V0dGluZ3Muc2NhbGVEaXZpc29yID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcHJlc2VudE51bWJlcih2YWx1ZSwgc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhdXRvR3JvdXAodmFsdWUsIHNldHRpbmdzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuYVN0b3IgJiYgKHNldHRpbmdzLmVEZWMgfHwgc2V0dGluZ3Muc2NhbGVEaXZpc29yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0b1NhdmUoJHRoaXMsIHNldHRpbmdzLCAnc2V0Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5yYXdWYWx1ZSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRvU2F2ZSgkdGhpcywgc2V0dGluZ3MsICd3aXBlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dGVtcHRlZFZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWluVGVzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudHJpZ2dlcignYXV0b051bWVyaWM6bWluRXhjZWVkZWQnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1heFRlc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLnRyaWdnZXIoJ2F1dG9OdW1lcmljOm1heEV4Y2VlZGVkJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHZhbHVlIFske2F0dGVtcHRlZFZhbHVlfV0gYmVpbmcgc2V0IGZhbGxzIG91dHNpZGUgdGhlIHZNaW4gWyR7c2V0dGluZ3Mudk1pbn1dIGFuZCB2TWF4IFske3NldHRpbmdzLnZNYXh9XSBzZXR0aW5ncyBmb3IgdGhpcyBlbGVtZW50YCwgc2V0dGluZ3MuZGVidWcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHRoaXMudmFsKCcnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkdGhpcy52YWwoJycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICghc2V0dGluZ3Mub25PZmYgJiYgc2V0dGluZ3Muc2NhbGVTeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlICsgc2V0dGluZ3Muc2NhbGVTeW1ib2w7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoJGlucHV0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR0aGlzLnZhbCh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNJbkFycmF5KCR0aGlzLnByb3AoJ3RhZ05hbWUnKS50b0xvd2VyQ2FzZSgpLCBzZXR0aW5ncy50YWdMaXN0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkdGhpcy50ZXh0KHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIG1ldGhvZCB0byB1bi1mb3JtYXQgaW5wdXRzIC0gaGFuZHkgdG8gdXNlIHJpZ2h0IGJlZm9yZSBmb3JtIHN1Ym1pc3Npb25cclxuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ3VuU2V0Jyk7IC8vIG5vIHBhcmFtZXRlciBhY2NlcHRlZFxyXG4gICAgICAgICAqIGJ5IGRlZmF1bHRzIHZhbHVlcyByZXR1cm5lZCBhcyBJU08gbnVtZXJpYyBzdHJpbmcgXCIxMjM0LjU2XCIgb3IgXCItMTIzNC41NlwiIHdoZXJlIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBpcyBhIHBlcmlvZFxyXG4gICAgICAgICAqIGxvY2FsZSBmb3JtYXRzIGFyZSBzdXBwb3J0ZWQgXCIxMjM0LjU2LVwiIG9yIFwiMTIzNCw1NlwiIG9yIFwiLTEyMzQsNTYgb3IgXCIxMjM0LDU2LVwiID0+IHBsZWFzZSBzZWUgb3B0aW9uIFwibG9jYWxlT3V0cHV0XCIgZm9yIGRldGFpbHNcclxuICAgICAgICAgKi9cclxuICAgICAgICB1blNldCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICQodGhpcykuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gYXV0b0dldCgkKHRoaXMpKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Mub25PZmYgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICR0aGlzLnZhbCgkdGhpcy5hdXRvTnVtZXJpYygnZ2V0JykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBtZXRob2QgdG8gcmUtZm9ybWF0IGlucHV0cyAtIGhhbmR5IHRvIHVzZSByaWdodCBhZnRlciBmb3JtIHN1Ym1pc3Npb25cclxuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ3JlU2V0Jyk7IC8vIG5vIHBhcmFtZXRlcnMgYWNjZXB0ZWRcclxuICAgICAgICAgKiB0aGlzIGlzIGNhbGxlZCBhZnRlciB0aGUgJ3VuU2V0JyBtZXRob2QgdG8gcmVmb3JtYXQgdGhlIGlucHV0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmVTZXQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAkKHRoaXMpLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCAkdGhpcyA9IGF1dG9HZXQoJCh0aGlzKSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCAkdGhpcy52YWwoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIG1ldGhvZCB0byBnZXQgdGhlIHVuZm9ybWF0dGVkIHRoYXQgYWNjZXB0cyB1cCB0byBvbmUgcGFyYW1ldGVyXHJcbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCdnZXQnKTsgbm8gcGFyYW1ldGVyIHN1cHBvcnRlZFxyXG4gICAgICAgICAqIGJ5IGRlZmF1bHRzIHZhbHVlcyByZXR1cm5lZCBhcyBJU08gbnVtZXJpYyBzdHJpbmcgXCIxMjM0LjU2XCIgb3IgXCItMTIzNC41NlwiIHdoZXJlIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBpcyBhIHBlcmlvZFxyXG4gICAgICAgICAqIGxvY2FsZSBmb3JtYXRzIGFyZSBzdXBwb3J0ZWQgXCIxMjM0LjU2LVwiIG9yIFwiMTIzNCw1NlwiIG9yIFwiLTEyMzQsNTYgb3IgXCIxMjM0LDU2LVwiID0+IHBsZWFzZSBzZWUgb3B0aW9uIFwibG9jYWxlT3V0cHV0XCIgZm9yIGRldGFpbHNcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gYXV0b0dldCgkKHRoaXMpKTtcclxuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xyXG4gICAgICAgICAgICBjb25zdCAkaW5wdXQgPSAkdGhpcy5pcygnaW5wdXRbdHlwZT10ZXh0XSwgaW5wdXRbdHlwZT1oaWRkZW5dLCBpbnB1dFt0eXBlPXRlbF0sIGlucHV0Om5vdChbdHlwZV0pJyk7XHJcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9ICcnO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgSW5pdGlhbGl6aW5nIGF1dG9OdW1lcmljIGlzIHJlcXVpcmVkIHByaW9yIHRvIGNhbGxpbmcgdGhlIFwiZ2V0XCIgbWV0aG9kYCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGRldGVybWluZSB0aGUgZWxlbWVudCB0eXBlIHRoZW4gdXNlIC5lcSgwKSBzZWxlY3RvciB0byBncmFiIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiBzZWxlY3RvclxyXG4gICAgICAgICAgICBpZiAoJGlucHV0KSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICR0aGlzLmVxKDApLnZhbCgpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzSW5BcnJheSgkdGhpcy5wcm9wKCd0YWdOYW1lJykudG9Mb3dlckNhc2UoKSwgc2V0dGluZ3MudGFnTGlzdCkpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gJHRoaXMuZXEoMCkudGV4dCgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIFwiPCR7JHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCl9PlwiIHRhZyBpcyBub3Qgc3VwcG9ydGVkIGJ5IGF1dG9OdW1lcmljYCwgc2V0dGluZ3MuZGVidWcpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuZURlYyB8fCBzZXR0aW5ncy5zY2FsZURpdmlzb3IpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gc2V0dGluZ3MucmF3VmFsdWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoISgoL1xcZC8pLnRlc3QodmFsdWUpIHx8IE51bWJlcih2YWx1ZSkgPT09IDApICYmIHNldHRpbmdzLndFbXB0eSA9PT0gJ2ZvY3VzJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycgJiYgc2V0dGluZ3MubkJyYWNrZXQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5vbk9mZiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBuZWdhdGl2ZUJyYWNrZXQodmFsdWUsIHNldHRpbmdzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5ydW5PbmNlIHx8IHNldHRpbmdzLmFGb3JtID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYXV0b1N0cmlwKHZhbHVlLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGZpeE51bWJlcih2YWx1ZSwgc2V0dGluZ3MuYURlYywgc2V0dGluZ3MuYU5lZyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChOdW1iZXIodmFsdWUpID09PSAwICYmIHNldHRpbmdzLmxaZXJvICE9PSAna2VlcCcpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gJzAnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5sb2NhbGVPdXRwdXQpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gdG9Mb2NhbGUodmFsdWUsIHNldHRpbmdzLmxvY2FsZU91dHB1dCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIHJldHVybmVkIE51bWVyaWMgU3RyaW5nXHJcbiAgICAgICAgICAgIC8vIFRPRE8gU2hvdWxkbid0IHdlIHJldHVybiBgTnVtYmVyKHZhbHVlKWAgc2luY2UgdGhlIGdvYWwgb2YgYGdldGAgaXMgdG8gZ2V0IHRoZSByYXcgamF2YXNjcmlwdCB2YWx1ZT9cclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybiB0aGUgY3VycmVudCBmb3JtYXR0ZWQgdmFsdWUgb2YgdGhlIGF1dG9OdW1lcmljIGVsZW1lbnQuXHJcbiAgICAgICAgICogQHVzYWdlIGFOSW5wdXQuYXV0b051bWVyaWMoJ2dldEZvcm1hdHRlZCcpKVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ31cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRGb3JtYXR0ZWQoKSB7XHJcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBgdGhpc1swXWAgZXhpc3RzIGFzIHdlbGwgYXMgYC52YWx1ZWAgYmVmb3JlIHRyeWluZyB0byBhY2Nlc3MgdGhhdCBwcm9wZXJ0eVxyXG4gICAgICAgICAgICBpZiAoIWlzQXJyYXkodGhpcykgfHwgdGhpcy5sZW5ndGggIT09IDEgfHwgIXRoaXNbMF0uaGFzT3duUHJvcGVydHkoJ3ZhbHVlJykpIHtcclxuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoJ1VuYWJsZSB0byBnZXQgdGhlIGZvcm1hdHRlZCBzdHJpbmcgZnJvbSB0aGUgZWxlbWVudC4nKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNbMF0udmFsdWU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIFwiZ2V0U3RyaW5nXCIgbWV0aG9kIHVzZXMgalF1ZXJ5J3MgLnNlcmlhbGl6ZSgpIG1ldGhvZCB0aGF0IGNyZWF0ZXMgYSB0ZXh0IHN0cmluZyBpbiBzdGFuZGFyZCBVUkwtZW5jb2RlZCBub3RhdGlvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEl0IHRoZW4gbG9vcHMgdGhyb3VnaCB0aGUgc3RyaW5nIGFuZCB1bi1mb3JtYXRzIHRoZSBpbnB1dHMgd2l0aCBhdXRvTnVtZXJpYy5cclxuICAgICAgICAgKiBCeSBkZWZhdWx0cyB2YWx1ZXMgcmV0dXJuZWQgYXMgSVNPIG51bWVyaWMgc3RyaW5nIFwiMTIzNC41NlwiIG9yIFwiLTEyMzQuNTZcIiB3aGVyZSB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgaXMgYSBwZXJpb2RcclxuICAgICAgICAgKiBMb2NhbGUgZm9ybWF0cyBhcmUgc3VwcG9ydGVkIFwiMTIzNC41Ni1cIiBvciBcIjEyMzQsNTZcIiBvciBcIi0xMjM0LDU2IG9yIFwiMTIzNCw1Ni1cIiA9PiBwbGVhc2Ugc2VlIG9wdGlvbiBcImxvY2FsZU91dHB1dFwiIGZvciBkZXRhaWxzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0U3RyaW5nKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2dldFN0cmluZ09yQXJyYXkoZmFsc2UsIHRoaXMpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBcImdldEFycmF5XCIgbWV0aG9kIG9uIHRoZSBvdGhlciBoYW5kIHVzZXMgalF1ZXJ5J3MgLnNlcmlhbGl6ZUFycmF5KCkgbWV0aG9kIHRoYXQgY3JlYXRlcyBhcnJheSBvciBvYmplY3RzIHRoYXQgY2FuIGJlIGVuY29kZWQgYXMgYSBKU09OIHN0cmluZy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEl0IHRoZW4gbG9vcHMgdGhyb3VnaCB0aGUgc3RyaW5nIGFuZCB1bi1mb3JtYXRzIHRoZSBpbnB1dHMgd2l0aCBhdXRvTnVtZXJpYy5cclxuICAgICAgICAgKiBCeSBkZWZhdWx0cyB2YWx1ZXMgcmV0dXJuZWQgYXMgSVNPIG51bWVyaWMgc3RyaW5nIFwiMTIzNC41NlwiIG9yIFwiLTEyMzQuNTZcIiB3aGVyZSB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgaXMgYSBwZXJpb2RcclxuICAgICAgICAgKiBMb2NhbGUgZm9ybWF0cyBhcmUgc3VwcG9ydGVkIFwiMTIzNC41Ni1cIiBvciBcIjEyMzQsNTZcIiBvciBcIi0xMjM0LDU2IG9yIFwiMTIzNCw1Ni1cIiA9PiBwbGVhc2Ugc2VlIG9wdGlvbiBcImxvY2FsZU91dHB1dFwiIGZvciBkZXRhaWxzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0QXJyYXkoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfZ2V0U3RyaW5nT3JBcnJheSh0cnVlLCB0aGlzKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgJ2dldFNldHRpbmdzJyBmdW5jdGlvbiByZXR1cm5zIHRoZSBvYmplY3Qgd2l0aCBhdXRvTnVtZXJpYyBzZXR0aW5ncyBmb3IgdGhvc2Ugd2hvIG5lZWQgdG8gbG9vayB1bmRlciB0aGUgaG9vZFxyXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygnZ2V0U2V0dGluZ3MnKTsgLy8gbm8gcGFyYW1ldGVycyBhY2NlcHRlZFxyXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygnZ2V0U2V0dGluZ3MnKS5hRGVjOyAvLyByZXR1cm4gdGhlIGFEZWMgc2V0dGluZyBhcyBhIHN0cmluZyAtIGFudCB2YWxpZCBzZXR0aW5nIGNhbiBiZSB1c2VkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0U2V0dGluZ3MoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gYXV0b0dldCgkKHRoaXMpKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiAkdGhpcy5lcSgwKS5kYXRhKCdhdXRvTnVtZXJpYycpO1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogYXV0b051bWVyaWMgZnVuY3Rpb25cclxuICAgICAqL1xyXG4gICAgJC5mbi5hdXRvTnVtZXJpYyA9IGZ1bmN0aW9uKG1ldGhvZCwgLi4uYXJncykge1xyXG4gICAgICAgIGlmIChtZXRob2RzW21ldGhvZF0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZHNbbWV0aG9kXS5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kID09PSAnb2JqZWN0JyB8fCAhbWV0aG9kKSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSBvcHRpb25zIGhhdmUgYmVlbiBwYXNzZWQgZGlyZWN0bHksIHdpdGhvdXQgdXNpbmcgYSBuYW1lZCBtZXRob2RcclxuICAgICAgICAgICAgLy9UT0RPIEZpcnN0IHZhbGlkYXRlIHRoZSBvcHRpb25zIHBhc3NlZCBhcyBhbiBhcmd1bWVudCwgYmVmb3JlIHVzaW5nIGBpbml0YFxyXG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kcy5pbml0LmFwcGx5KHRoaXMsIFttZXRob2RdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRocm93RXJyb3IoYE1ldGhvZCBcIiR7bWV0aG9kfVwiIGlzIG5vdCBzdXBwb3J0ZWQgYnkgYXV0b051bWVyaWNgLCB0cnVlKTtcclxuICAgIH07XHJcblxyXG4gICAgLypcclxuICAgICAqIERlZmF1bHRzIGFyZSBwdWJsaWMgLSB0aGVzZSBjYW4gYmUgb3ZlcnJpZGRlbiBieSB0aGUgZm9sbG93aW5nOlxyXG4gICAgICogSFRNTDUgZGF0YSBhdHRyaWJ1dGVzXHJcbiAgICAgKiBPcHRpb25zIHBhc3NlZCBieSB0aGUgJ2luaXQnIG9yICd1cGRhdGUnIG1ldGhvZHNcclxuICAgICAqIFVzZSBqUXVlcnkncyBgJC5leHRlbmRgIG1ldGhvZCBmb3IgZ2xvYmFsIGNoYW5nZXMgLSBhbHNvIGEgZ3JlYXQgd2F5IHRvIHBhc3MgQVNQLk5FVCBjdXJyZW50IGN1bHR1cmUgc2V0dGluZ3NcclxuICAgICAqL1xyXG4gICAgJC5mbi5hdXRvTnVtZXJpYy5kZWZhdWx0cyA9IHtcclxuICAgICAgICAvKiBhbGxvd2VkIHRob3VzYW5kIHNlcGFyYXRvciBjaGFyYWN0ZXJzXHJcbiAgICAgICAgICogY29tbWEgPSBcIixcIlxyXG4gICAgICAgICAqIHBlcmlvZCBcImZ1bGwgc3RvcFwiID0gXCIuXCJcclxuICAgICAgICAgKiBhcG9zdHJvcGhlIGlzIGVzY2FwZWQgPSBcIlxcXCJcIlxyXG4gICAgICAgICAqIHNwYWNlID0gXCIgXCJcclxuICAgICAgICAgKiBub25lID0gXCJcIlxyXG4gICAgICAgICAqIE5PVEU6IGRvIG5vdCB1c2UgbnVtZXJpYyBjaGFyYWN0ZXJzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgYVNlcDogJywnLFxyXG5cclxuICAgICAgICAvKiBXaGVuIHRydWUgPT4gcmVtb3ZlcyB0aGUgdGhvdXNhbmQgc2VwZXJhdG9yLCBjdXJyZW5jeSBzeW1ib2wgJiBzdWZmaXggXCJmb2N1c2luXCJcclxuICAgICAgICAgKiBleGFtcGxlIGlmIHRoZSBpbnB1dCB2YWx1ZSBcIiQgMSw5OTkuODggc3VmZml4XCJcclxuICAgICAgICAgKiBvbiBcImZvY3VzaW5cIiBpdCBiZWNvbWVzIFwiMTk5OS44OFwiIGFuZCBiYWNrIHRvIFwiJCAxLDk5OS44OCBzdWZmaXhcIiBvbiBmb2N1cyBvdXQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgblNlcDogZmFsc2UsXHJcblxyXG4gICAgICAgIC8qIGRpZ2l0YWwgZ3JvdXBpbmcgZm9yIHRoZSB0aG91c2FuZCBzZXBhcmF0b3IgdXNlZCBpbiBGb3JtYXRcclxuICAgICAgICAgKiBkR3JvdXA6IFwiMlwiLCByZXN1bHRzIGluIDk5LDk5LDk5LDk5OSBJbmRpYSdzIGxha2hzXHJcbiAgICAgICAgICogZEdyb3VwOiBcIjJzXCIsIHJlc3VsdHMgaW4gOTksOTk5LDk5LDk5LDk5OSBJbmRpYSdzIGxha2hzIHNjYWxlZFxyXG4gICAgICAgICAqIGRHcm91cDogXCIzXCIsIHJlc3VsdHMgaW4gOTk5LDk5OSw5OTkgZGVmYXVsdFxyXG4gICAgICAgICAqIGRHcm91cDogXCI0XCIsIHJlc3VsdHMgaW4gOTk5OSw5OTk5LDk5OTkgdXNlZCBpbiBzb21lIEFzaWFuIGNvdW50cmllc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGRHcm91cDogJzMnLFxyXG5cclxuICAgICAgICAvKiBhbGxvd2VkIGRlY2ltYWwgc2VwYXJhdG9yIGNoYXJhY3RlcnNcclxuICAgICAgICAgKiBwZXJpb2QgXCJmdWxsIHN0b3BcIiA9IFwiLlwiXHJcbiAgICAgICAgICogY29tbWEgPSBcIixcIlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGFEZWM6ICcuJyxcclxuXHJcbiAgICAgICAgLyogYWxsb3cgdG8gZGVjbGFyZSBhbHRlcm5hdGl2ZSBkZWNpbWFsIHNlcGFyYXRvciB3aGljaCBpcyBhdXRvbWF0aWNhbGx5IHJlcGxhY2VkIGJ5IGFEZWNcclxuICAgICAgICAgKiBkZXZlbG9wZWQgZm9yIGNvdW50cmllcyB0aGUgdXNlIGEgY29tbWEgXCIsXCIgYXMgdGhlIGRlY2ltYWwgY2hhcmFjdGVyXHJcbiAgICAgICAgICogYW5kIGhhdmUga2V5Ym9hcmRzXFxudW1lcmljIHBhZHMgdGhhdCBoYXZlIGEgcGVyaW9kICdmdWxsIHN0b3AnIGFzIHRoZSBkZWNpbWFsIGNoYXJhY3RlcnMgKFNwYWluIGlzIGFuIGV4YW1wbGUpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgYWx0RGVjOiBudWxsLFxyXG5cclxuICAgICAgICAvKiBhU2lnbiA9IGFsbG93ZWQgY3VycmVuY3kgc3ltYm9sXHJcbiAgICAgICAgICogTXVzdCBiZSBpbiBxdW90ZXMgYVNpZ246IFwiJFwiXHJcbiAgICAgICAgICogc3BhY2UgdG8gdGhlIHJpZ2h0IG9mIHRoZSBjdXJyZW5jeSBzeW1ib2wgYVNpZ246ICckICdcclxuICAgICAgICAgKiBzcGFjZSB0byB0aGUgbGVmdCBvZiB0aGUgY3VycmVuY3kgc3ltYm9sIGFTaWduOiAnICQnXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgYVNpZ246ICcnLFxyXG5cclxuICAgICAgICAvKiBwU2lnbiA9IHBsYWNlbWVudCBvZiBjdXJyZW5jeSBzaWduIGFzIGEgcD1wcmVmaXggb3Igcz1zdWZmaXhcclxuICAgICAgICAgKiBmb3IgcHJlZml4IHBTaWduOiBcInBcIiAoZGVmYXVsdClcclxuICAgICAgICAgKiBmb3Igc3VmZml4IHBTaWduOiBcInNcIlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHBTaWduOiAncCcsXHJcblxyXG4gICAgICAgIC8qIHBsYWNlbWVudCBvZiBuZWdhdGl2ZSBzaWduIHJlbGF0aXZlIHRvIHRoZSBhU2lnbiBvcHRpb24gbD1sZWZ0LCByPXJpZ2h0LCBwPXByZWZpeCAmIHM9c3VmZml4XHJcbiAgICAgICAgICogLTEsMjM0LjU2ICA9PiBkZWZhdWx0IG5vIG9wdGlvbnMgcmVxdWlyZWRcclxuICAgICAgICAgKiAtJDEsMjM0LjU2ID0+IHthU2lnbjogXCIkXCJ9XHJcbiAgICAgICAgICogJC0xLDIzNC41NiA9PiB7YVNpZ246IFwiJFwiLCBwTmVnOiBcInJcIn1cclxuICAgICAgICAgKiAtMSwyMzQuNTYkID0+IHthU2lnbjogXCIkXCIsIHBTaWduOiBcInNcIiwgcE5lZzogXCJwXCJ9XHJcbiAgICAgICAgICogMSwyMzQuNTYtICA9PiB7cE5lZzogXCJzXCJ9XHJcbiAgICAgICAgICogJDEsMjM0LjU2LSA9PiB7YVNpZ246IFwiJFwiLCBwTmVnOiBcInNcIn1cclxuICAgICAgICAgKiAxLDIzNC41Ni0kID0+IHthU2lnbjogXCIkXCIsIHBTaWduOiBcInNcIn1cclxuICAgICAgICAgKiAxLDIzNC41NiQtID0+IHthU2lnbjogXCIkXCIsIHBTaWduOiBcInNcIiwgcE5lZzogXCJyXCJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcE5lZzogJ2wnLFxyXG5cclxuICAgICAgICAvKiBBZGRpdGlvbmFsIHN1ZmZpeFxyXG4gICAgICAgICAqIE11c3QgYmUgaW4gcXVvdGVzIGFTdWZmaXg6ICdncm9zcycsIGEgc3BhY2UgaXMgYWxsb3dlZCBhU3VmZml4OiAnIGRvbGxhcnMnXHJcbiAgICAgICAgICogTnVtZXJpYyBjaGFyYWN0ZXJzIGFuZCBuZWdhdGl2ZSBzaWduIG5vdCBhbGxvd2VkJ1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGFTdWZmaXg6ICcnLFxyXG5cclxuICAgICAgICAvKiBvdmVycmlkZSBtaW4gbWF4IGxpbWl0cydcclxuICAgICAgICAgKiBvTGltaXRzOiBcImNlaWxpbmdcIiBhZGhlcmVzIHRvIHZNYXggYW5kIGlnbm9yZXMgdk1pbiBzZXR0aW5nc1xyXG4gICAgICAgICAqIG9MaW1pdHM6IFwiZmxvb3JcIiBhZGhlcmVzIHRvIHZNaW4gYW5kIGlnbm9yZXMgdk1heCBzZXR0aW5nc1xyXG4gICAgICAgICAqIG9MaW1pdHM6IFwiaWdub3JlXCIgaWdub3JlcyBib3RoIHZNaW4gJiB2TWF4XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgb0xpbWl0czogbnVsbCxcclxuXHJcbiAgICAgICAgLyogbWF4aW11bSBwb3NzaWJsZSB2YWx1ZVxyXG4gICAgICAgICAqIHZhbHVlIG11c3QgYmUgZW5jbG9zZWQgaW4gcXVvdGVzIGFuZCB1c2UgdGhlIHBlcmlvZCBmb3IgdGhlIGRlY2ltYWwgcG9pbnRcclxuICAgICAgICAgKiB2YWx1ZSBtdXN0IGJlIGxhcmdlciB0aGFuIHZNaW5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2TWF4OiAnOTk5OTk5OTk5OTk5OS45OScsXHJcblxyXG4gICAgICAgIC8qIG1pbmltdW0gcG9zc2libGUgdmFsdWVcclxuICAgICAgICAgKiB2YWx1ZSBtdXN0IGJlIGVuY2xvc2VkIGluIHF1b3RlcyBhbmQgdXNlIHRoZSBwZXJpb2QgZm9yIHRoZSBkZWNpbWFsIHBvaW50XHJcbiAgICAgICAgICogdmFsdWUgbXVzdCBiZSBzbWFsbGVyIHRoYW4gdk1heFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZNaW46ICctOTk5OTk5OTk5OTk5OS45OScsXHJcblxyXG4gICAgICAgIC8qIE1heGltdW0gbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzID0gdXNlZCB0byBvdmVycmlkZSBkZWNpbWFsIHBsYWNlcyBzZXQgYnkgdGhlIHZNaW4gJiB2TWF4IHZhbHVlc1xyXG4gICAgICAgICAqIHZhbHVlIG11c3QgYmUgZW5jbG9zZWQgaW4gcXVvdGVzIGV4YW1wbGUgbURlYzogXCIzXCIsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbURlYzogbnVsbCxcclxuXHJcbiAgICAgICAgLyogRXhwYW5kZWQgZGVjaW1hbCBwbGFjZXMgdmlzaWJsZSB3aGVuIGlucHV0IGhhcyBmb2N1cyAtIGV4YW1wbGU6XHJcbiAgICAgICAgICoge2VEZWM6IFwiNVwifSBhbmQgdGhlIGRlZmF1bHQgMiBkZWNpbWFsIHBsYWNlcyB3aXRoIGZvY3VzIFwiMSwwMDAuMTIzNDVcIiB3aXRob3V0IGZvY3VzIFwiMSwwMDAuMTJcIiB0aGUgcmVzdWx0cyBkZXBlbmRzIG9uIHRoZSByb3VuZGluZyBtZXRob2QgdXNlZFxyXG4gICAgICAgICAqIHRoZSBcImdldFwiIG1ldGhvZCByZXR1cm5zIHRoZSBleHRlbmRlZCBkZWNpbWFsIHBsYWNlc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGVEZWM6IG51bGwsXHJcblxyXG4gICAgICAgIC8qIFRoZSBuZXh0IHRocmVlIG9wdGlvbnMgKHNjYWxlRGl2aXNvciwgc2NhbGVEZWNpbWFsICYgc2NhbGVTeW1ib2wpIGhhbmRsZSBzY2FsaW5nIG9mIHRoZSBpbnB1dCB3aGVuIHRoZSBpbnB1dCBkb2VzIG5vdCBoYXZlIGZvY3VzXHJcbiAgICAgICAgICogUGxlYXNlIG5vdGUgdGhhdCB0aGUgbm9uLXNjYWxlZCB2YWx1ZSBpcyBoZWxkIGluIGRhdGEgYW5kIGl0IGlzIGFkdmlzZWQgdGhhdCB5b3UgdXNlIHRoZSBcImFTdG9yZVwiIG9wdGlvbiB0byBlbnN1cmUgcmV0YWluaW5nIHRoZSB2YWx1ZSAgICAgICAgICogW1wiZGl2aXNvclwiLCBcImRlY2ltYWwgcGxhY2VzXCIsIFwic3ltYm9sXCJdXHJcbiAgICAgICAgICogRXhhbXBsZTogd2l0aCB0aGUgZm9sbG93aW5nIG9wdGlvbnMgc2V0IHtzY2FsZURpdmlzb3I6ICcxMDAwJywgc2NhbGVEZWNpbWFsOiAnMScsIHNjYWxlU3ltYm9sOiAnIEsnfVxyXG4gICAgICAgICAqIEV4YW1wbGU6IGZvY3VzaW4gdmFsdWUgXCIxLDExMS4xMVwiIGZvY3Vzb3V0IHZhbHVlIFwiMS4xIEtcIlxyXG4gICAgICAgICAqL1xyXG5cclxuICAgICAgICAvKiBzY2FsZURpdmlzb3IgZGV2aWRlcyB0aGUgb24gZm9jdXMgdmFsdWUgYW5kIHBsYWNlcyB0aGUgcmVzdWx0IGluIHRoZSBpbnB1dCBvbiBmb2N1c291dFxyXG4gICAgICAgICAqIGV4YW1wbGUge3NjYWxlRGl2aXNvcjogJzEwMDAnfSBvciA8aW5wdXQgZGF0YS1zY2FsZS1kaXZpc29yPVwiMTAwMFwiPlxyXG4gICAgICAgICAqIHRoZSBkaXZpc29yIHZhbHVlIC0gZG9lcyBub3QgbmVlZCB0byBiZSB3aG9sZSBudW1iZXIgYnV0IHBsZWFzZSB1bmRlcnN0YW5kIHRoYXQgSmF2YXNjcmlwdCBoYXMgbGltaXRlZCBhY2N1cmFjeSBpbiBtYXRoXHJcbiAgICAgICAgICogdGhlIFwiZ2V0XCIgbWV0aG9kIHJldHVybnMgdGhlIGZ1bGwgdmFsdWUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2NhbGVEaXZpc29yOiBudWxsLFxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIHNjYWxlZERlY2ltYWwgb3B0aW9uIGlzIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZSB3aGVuIG5vdCBpbiBmb2N1cyAtIGZvciB0aGlzIHRvIGZ1bmN0aW9uIHNjYWxlZERpdmlzb3IgbXVzdCBub3QgYmUgbnVsbFxyXG4gICAgICAgICAqIHRoaXMgaXMgXCJvcHRpb25hbFwiIGlmIG9taXR0ZWQgdGhlIGRlY2ltYWwgcGxhY2VzIHdpbGwgYmUgdGhlIHNhbWUgd2hlbiB0aGUgaW5wdXQgaGFzIGZvY3VzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2NhbGVEZWNpbWFsOiBudWxsLFxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIHNjYWxlZFN5bWJvbCBvcHRpb24gaXMgYSBzeW1ib2wgcGxhY2VkIGFzIGEgc3VmZml4IHdoZW4gbm90IGluIGZvY3VzLlxyXG4gICAgICAgICAqIHRoaXMgaXMgXCJvcHRpb25hbFwiXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2NhbGVTeW1ib2w6IG51bGwsXHJcblxyXG4gICAgICAgIC8qIFNldCB0byB0cnVlIHRvIGFsbG93IHRoZSBlRGVjIHZhbHVlIHRvIGJlIHNhdmVkIHdpdGggc2Vzc2lvblN0b3JhZ2VcclxuICAgICAgICAgKiBpZiBpZSA2IG9yIDcgdGhlIHZhbHVlIHdpbGwgYmUgc2F2ZWQgYXMgYSBzZXNzaW9uIGNvb2tpZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGFTdG9yOiBmYWxzZSxcclxuXHJcbiAgICAgICAgLyogbWV0aG9kIHVzZWQgZm9yIHJvdW5kaW5nXHJcbiAgICAgICAgICogbVJvdW5kOiBcIlNcIiwgUm91bmQtSGFsZi1VcCBTeW1tZXRyaWMgKGRlZmF1bHQpXHJcbiAgICAgICAgICogbVJvdW5kOiBcIkFcIiwgUm91bmQtSGFsZi1VcCBBc3ltbWV0cmljXHJcbiAgICAgICAgICogbVJvdW5kOiBcInNcIiwgUm91bmQtSGFsZi1Eb3duIFN5bW1ldHJpYyAobG93ZXIgY2FzZSBzKVxyXG4gICAgICAgICAqIG1Sb3VuZDogXCJhXCIsIFJvdW5kLUhhbGYtRG93biBBc3ltbWV0cmljIChsb3dlciBjYXNlIGEpXHJcbiAgICAgICAgICogbVJvdW5kOiBcIkJcIiwgUm91bmQtSGFsZi1FdmVuIFwiQmFua2VycyBSb3VuZGluZ1wiXHJcbiAgICAgICAgICogbVJvdW5kOiBcIlVcIiwgUm91bmQgVXAgXCJSb3VuZC1Bd2F5LUZyb20tWmVyb1wiXHJcbiAgICAgICAgICogbVJvdW5kOiBcIkRcIiwgUm91bmQgRG93biBcIlJvdW5kLVRvd2FyZC1aZXJvXCIgLSBzYW1lIGFzIHRydW5jYXRlXHJcbiAgICAgICAgICogbVJvdW5kOiBcIkNcIiwgUm91bmQgdG8gQ2VpbGluZyBcIlRvd2FyZCBQb3NpdGl2ZSBJbmZpbml0eVwiXHJcbiAgICAgICAgICogbVJvdW5kOiBcIkZcIiwgUm91bmQgdG8gRmxvb3IgXCJUb3dhcmQgTmVnYXRpdmUgSW5maW5pdHlcIlxyXG4gICAgICAgICAqIG1Sb3VuZDogXCJOMDVcIiBSb3VuZHMgdG8gdGhlIG5lYXJlc3QgLjA1ID0+IHNhbWUgYXMgXCJDSEZcIiB1c2VkIGluIDEuOVggYW5kIHN0aWxsIHZhbGlkXHJcbiAgICAgICAgICogbVJvdW5kOiBcIlUwNVwiIFJvdW5kcyB1cCB0byBuZXh0IC4wNVxyXG4gICAgICAgICAqIG1Sb3VuZDogXCJEMDVcIiBSb3VuZHMgZG93biB0byBuZXh0IC4wNVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG1Sb3VuZDogJ1MnLFxyXG5cclxuICAgICAgICAvKiBjb250cm9scyBkZWNpbWFsIHBhZGRpbmdcclxuICAgICAgICAgKiBhUGFkOiB0cnVlIC0gYWx3YXlzIFBhZCBkZWNpbWFscyB3aXRoIHplcm9zXHJcbiAgICAgICAgICogYVBhZDogZmFsc2UgLSBkb2VzIG5vdCBwYWQgd2l0aCB6ZXJvcy5cclxuICAgICAgICAgKiB0aGFua3MgdG8gSm9uYXMgSm9oYW5zc29uIGZvciB0aGUgc3VnZ2VzdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGFQYWQ6IHRydWUsXHJcblxyXG4gICAgICAgIC8qIHBsYWNlcyBicmFja2V0cyBvbiBuZWdhdGl2ZSB2YWx1ZSAtJCA5OTkuOTkgdG8gKDk5OS45OSlcclxuICAgICAgICAgKiB2aXNpYmxlIG9ubHkgd2hlbiB0aGUgZmllbGQgZG9lcyBOT1QgaGF2ZSBmb2N1cyB0aGUgbGVmdCBhbmQgcmlnaHQgc3ltYm9scyBzaG91bGQgYmUgZW5jbG9zZWQgaW4gcXVvdGVzIGFuZCBzZXBhcmF0ZWQgYnkgYSBjb21tYVxyXG4gICAgICAgICAqIG5CcmFja2V0OiBudWxsIC0gKGRlZmF1bHQpXHJcbiAgICAgICAgICogbkJyYWNrZXQ6ICcoLCknLCBuQnJhY2tldDogJ1ssXScsIG5CcmFja2V0OiAnPCw+JyBvciBuQnJhY2tldDogJ3ssfSdcclxuICAgICAgICAgKi9cclxuICAgICAgICBuQnJhY2tldDogbnVsbCxcclxuXHJcbiAgICAgICAgLyogRGlzcGxheWVkIG9uIGVtcHR5IHN0cmluZyBcIlwiXHJcbiAgICAgICAgICogd0VtcHR5OiBcImZvY3VzXCIgLSAoZGVmYXVsdCkgY3VycmVuY3kgc2lnbiBkaXNwbGF5ZWQgYW5kIHRoZSBpbnB1dCByZWNlaXZlcyBmb2N1c1xyXG4gICAgICAgICAqIHdFbXB0eTogXCJwcmVzc1wiIC0gY3VycmVuY3kgc2lnbiBkaXNwbGF5cyBvbiBhbnkga2V5IGJlaW5nIHByZXNzZWRcclxuICAgICAgICAgKiB3RW1wdHk6IFwiYWx3YXlzXCIgLSBhbHdheXMgZGlzcGxheXMgdGhlIGN1cnJlbmN5IHNpZ24gb25seVxyXG4gICAgICAgICAqIHdFbXB0eTogXCJ6ZXJvXCIgLSBpZiB0aGUgaW5wdXQgaGFzIG5vIHZhbHVlIG9uIGZvY3VzIG91dCBkaXNwbGF5cyBhIHplcm8gXCJyb3VuZGVkXCIgd2l0aCBvciB3aXRoIGEgY3VycmVuY3kgc2lnblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8vVE9ETyBBZGQgYW4gb3B0aW9uIHRvIGRpc3BsYXkgdGhlIGN1cnJlbmN5IHNpZ24gb25seSBvbiBob3ZlciAoaWYgdGhlIGlucHV0IGlzIGVtcHR5KVxyXG4gICAgICAgIHdFbXB0eTogJ2ZvY3VzJyxcclxuXHJcbiAgICAgICAgLyogY29udHJvbHMgbGVhZGluZyB6ZXJvIGJlaGF2aW9yXHJcbiAgICAgICAgICogbFplcm86IFwiYWxsb3dcIiwgLSBhbGxvd3MgbGVhZGluZyB6ZXJvcyB0byBiZSBlbnRlcmVkLiBaZXJvcyB3aWxsIGJlIHRydW5jYXRlZCB3aGVuIGVudGVyaW5nIGFkZGl0aW9uYWwgZGlnaXRzLiBPbiBmb2N1c291dCB6ZXJvcyB3aWxsIGJlIGRlbGV0ZWQuXHJcbiAgICAgICAgICogbFplcm86IFwiZGVueVwiLCAtIGFsbG93cyBvbmx5IG9uZSBsZWFkaW5nIHplcm8gb24gdmFsdWVzIGxlc3MgdGhhbiBvbmVcclxuICAgICAgICAgKiBsWmVybzogXCJrZWVwXCIsIC0gYWxsb3dzIGxlYWRpbmcgemVyb3MgdG8gYmUgZW50ZXJlZC4gb24gZm9jdXNvdXQgemVyb3Mgd2lsbCBiZSByZXRhaW5lZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBsWmVybzogJ2FsbG93JyxcclxuXHJcbiAgICAgICAgLyogZGV0ZXJtaW5lIGlmIHRoZSBkZWZhdWx0IHZhbHVlIHdpbGwgYmUgZm9ybWF0dGVkIG9uIGluaXRpYWxpemF0aW9uLlxyXG4gICAgICAgICAqIHRydWUgPSBhdXRvbWF0aWNhbGx5IGZvcm1hdHMgdGhlIGRlZmF1bHQgdmFsdWUgb24gaW5pdGlhbGl6YXRpb25cclxuICAgICAgICAgKiBmYWxzZSA9IHdpbGwgbm90IGZvcm1hdCB0aGUgZGVmYXVsdCB2YWx1ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGFGb3JtOiB0cnVlLFxyXG5cclxuICAgICAgICAvKiBkZXRlcm1pbmUgaWYgdGhlIHNlbGVjdCBhbGwga2V5Ym9hcmQgY29tbWFuZCB3aWxsIHNlbGVjdFxyXG4gICAgICAgICAqIHRoZSBjb21wbGV0ZSBpbnB1dCB0ZXh0IG9yIG9ubHkgdGhlIGlucHV0IG51bWVyaWMgdmFsdWVcclxuICAgICAgICAgKiBpZiB0aGUgY3VycmVuY3kgc3ltYm9sIGlzIGJldHdlZW4gdGhlIG51bWVyaWMgdmFsdWUgYW5kIHRoZSBuZWdhdGl2ZSBzaWduIG9ubHkgdGhlIG51bWVyaWMgdmFsdWUgd2lsbCBzZWxlY3RlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNOdW1iZXI6IGZhbHNlLFxyXG5cclxuICAgICAgICAvKiBoZWxwZXIgb3B0aW9uIGZvciBBU1AuTkVUIHBvc3RiYWNrXHJcbiAgICAgICAgICogc2hvdWxkIGJlIHRoZSB2YWx1ZSBvZiB0aGUgdW5mb3JtYXR0ZWQgZGVmYXVsdCB2YWx1ZVxyXG4gICAgICAgICAqIGV4YW1wbGVzOlxyXG4gICAgICAgICAqIG5vIGRlZmF1bHQgdmFsdWU9XCJcIiB7YW5EZWZhdWx0OiBcIlwifVxyXG4gICAgICAgICAqIHZhbHVlPTEyMzQuNTYge2FuRGVmYXVsdDogJzEyMzQuNTYnfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGFuRGVmYXVsdDogbnVsbCxcclxuXHJcbiAgICAgICAgLyogcmVtb3ZlcyBmb3JtYXR0aW5nIG9uIHN1Ym1pdCBldmVudFxyXG4gICAgICAgICAqIHRoaXMgb3V0cHV0IGZvcm1hdDogcG9zaXRpdmUgbm5ubi5ubiwgbmVnYXRpdmUgLW5ubm4ubm5cclxuICAgICAgICAgKiByZXZpZXcgdGhlICd1blNldCcgbWV0aG9kIGZvciBvdGhlciBmb3JtYXRzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdW5TZXRPblN1Ym1pdDogZmFsc2UsXHJcblxyXG4gICAgICAgIC8qIGFsbG93cyB0aGUgb3V0cHV0IHRvIGJlIGluIHRoZSBsb2NhbGUgZm9ybWF0IHZpYSB0aGUgXCJnZXRcIiwgXCJnZXRTdHJpbmdcIiAmIFwiZ2V0QXJyYXlcIiBtZXRob2RzXHJcbiAgICAgICAgICogbnVsbCA9PiBubm5uLm5uIG9yIC1ubm5uLm5uIGRlZmF1bHRcclxuICAgICAgICAgKiBcIixcIiAgPT4gbm5ubixubiBvciAtbm5ubixubiBjYW4gYWxzIGJlIFwiLSxcIlxyXG4gICAgICAgICAqIFwiLi1cIiA9PiBubm5uLm5uIG9yIG5ubm4ubm4tXHJcbiAgICAgICAgICogXCIsLVwiID0+IG5ubm4sbm4gb3Igbm5ubixubi1cclxuICAgICAgICAgKi9cclxuICAgICAgICBsb2NhbGVPdXRwdXQ6IG51bGwsXHJcblxyXG4gICAgICAgIC8qIGVycm9yIGhhbmRsaW5nIGZ1bmN0aW9uXHJcbiAgICAgICAgICogdHJ1ZSA9PiBhbGwgZXJyb3JzIGFyZSB0aHJvd24gLSBoZWxwZnVsIGluIHNpdGUgZGV2ZWxvcG1lbnRcclxuICAgICAgICAgKiBmYWxzZSA9PiB0aHJvd3MgZXJyb3JzIHdoZW4gY2FsbGluZyBtZXRob2RzIHByaW9yIHRvIHRoZSBzdXBwb3J0ZWQgZWxlbWVudCBoYXMgYmVlbiBpbml0aWFsaXplZCBiZSBhdXRvTnVtZXJpY1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGRlYnVnOiBmYWxzZSxcclxuICAgIH07XHJcblxyXG4gICAgZ2V0RGVmYXVsdENvbmZpZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiAkLmZuLmF1dG9OdW1lcmljLmRlZmF1bHRzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIHB1YmxpYyBmdW5jdGlvbiB0aGF0IGFsbG93cyBmb3JtYXR0aW5nIHdpdGhvdXQgYW4gZWxlbWVudCB0cmlnZ2VyXHJcbiAgICAgKi9cclxuICAgIGF1dG9Gb3JtYXQgPSBmdW5jdGlvbih2YWx1ZSwgb3B0aW9ucykge1xyXG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkgfHwgdmFsdWUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICQuZXh0ZW5kKHt9LCAkLmZuLmF1dG9OdW1lcmljLmRlZmF1bHRzLCB7IHN0cmlwOiBmYWxzZSB9LCBvcHRpb25zKTtcclxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgdmFsdWUgPSBmcm9tTG9jYWxlKHZhbHVlKTtcclxuICAgICAgICBpZiAoTnVtYmVyKHZhbHVlKSA8IDApIHtcclxuICAgICAgICAgICAgc2V0dGluZ3MuYU5lZyA9ICctJztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNldHRpbmdzLm1EZWMgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgY29uc3Qgdk1heCA9IHNldHRpbmdzLnZNYXgudG9TdHJpbmcoKS5zcGxpdCgnLicpO1xyXG4gICAgICAgICAgICBjb25zdCB2TWluID0gKCFzZXR0aW5ncy52TWluICYmIHNldHRpbmdzLnZNaW4gIT09IDApID8gW10gOiBzZXR0aW5ncy52TWluLnRvU3RyaW5nKCkuc3BsaXQoJy4nKTtcclxuICAgICAgICAgICAgc2V0dGluZ3MubURlYyA9IGRlY0xlbmd0aCh2TWluLCB2TWF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgW21pblRlc3QsIG1heFRlc3RdID0gYXV0b0NoZWNrKHZhbHVlLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgaWYgKCFtaW5UZXN0IHx8ICFtYXhUZXN0KSB7XHJcbiAgICAgICAgICAgIC8vIFRocm93IGEgY3VzdG9tIGV2ZW50XHJcbiAgICAgICAgICAgIHNlbmRDdXN0b21FdmVudCgnYXV0b0Zvcm1hdC5hdXRvTnVtZXJpYycsIGBSYW5nZSB0ZXN0IGZhaWxlZGApO1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgdmFsdWUgWyR7dmFsdWV9XSBiZWluZyBzZXQgZmFsbHMgb3V0c2lkZSB0aGUgdk1pbiBbJHtzZXR0aW5ncy52TWlufV0gYW5kIHZNYXggWyR7c2V0dGluZ3Mudk1heH1dIHNldHRpbmdzYCwgc2V0dGluZ3MuZGVidWcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YWx1ZSA9IGF1dG9Sb3VuZCh2YWx1ZSwgc2V0dGluZ3MpO1xyXG4gICAgICAgIHZhbHVlID0gcHJlc2VudE51bWJlcih2YWx1ZSwgc2V0dGluZ3MpO1xyXG4gICAgICAgIHZhbHVlID0gYXV0b0dyb3VwKHZhbHVlLCBzZXR0aW5ncyk7XHJcblxyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH07XHJcblxyXG4gICAgJC5mbi5hdXRvRm9ybWF0ID0gYXV0b0Zvcm1hdDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIHB1YmxpYyBmdW5jdGlvbiB0aGF0IGFsbG93cyB1bmZvcm1hdHRpbmcgd2l0aG91dCBhbiBlbGVtZW50XHJcbiAgICAgKi9cclxuICAgIGF1dG9VbkZvcm1hdCA9IGZ1bmN0aW9uKHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSB8fCB2YWx1ZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gJC5leHRlbmQoe30sICQuZm4uYXV0b051bWVyaWMuZGVmYXVsdHMsIHsgc3RyaXA6IGZhbHNlIH0sIG9wdGlvbnMpO1xyXG4gICAgICAgIGNvbnN0IGFsbG93ZWQgPSBgLTAxMjM0NTY3ODlcXFxcJHtzZXR0aW5ncy5hRGVjfWA7XHJcbiAgICAgICAgY29uc3QgYXV0b1N0cmlwID0gbmV3IFJlZ0V4cChgW14ke2FsbG93ZWR9XWAsICdnaScpO1xyXG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcclxuICAgICAgICBpZiAodmFsdWUuY2hhckF0KDApID09PSAnLScpIHtcclxuICAgICAgICAgICAgc2V0dGluZ3MuYU5lZyA9ICctJztcclxuICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLm5CcmFja2V0ICYmIHNldHRpbmdzLm5CcmFja2V0LnNwbGl0KCcsJylbMF0gPT09IHZhbHVlLmNoYXJBdCgwKSkge1xyXG4gICAgICAgICAgICBzZXR0aW5ncy5hTmVnID0gJy0nO1xyXG4gICAgICAgICAgICBzZXR0aW5ncy5vbk9mZiA9IHRydWU7XHJcbiAgICAgICAgICAgIHZhbHVlID0gbmVnYXRpdmVCcmFja2V0KHZhbHVlLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShhdXRvU3RyaXAsICcnKTtcclxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoJywnLCAnLicpO1xyXG4gICAgICAgIGlmIChzZXR0aW5ncy5sb2NhbGVPdXRwdXQpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSB0b0xvY2FsZSh2YWx1ZSwgc2V0dGluZ3MubG9jYWxlT3V0cHV0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAkLmZuLmF1dG9VbmZvcm1hdCA9IGF1dG9VbkZvcm1hdDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIGN1c3RvbSBldmVudC5cclxuICAgICAqIGNmLiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3VzdG9tRXZlbnQvQ3VzdG9tRXZlbnRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lIHN0cmluZ1xyXG4gICAgICogQHBhcmFtIGRldGFpbFxyXG4gICAgICogQHJldHVybnMge0N1c3RvbUV2ZW50fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVDdXN0b21FdmVudChldmVudE5hbWUsIGRldGFpbCkge1xyXG4gICAgICAgIC8qIGxldCBldmVudEluZm8gPSBuZXcgQ3VzdG9tRXZlbnRJbml0KCk7IC8vVGhpcyBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLCBidXQgSUUgZG9lcyBub3Qgc3VwcG9ydCAnQ3VzdG9tRXZlbnRJbml0JyB5ZXRcclxuICAgICAgICBldmVudEluZm8uZGV0YWlsID0gZGV0YWlsO1xyXG4gICAgICAgIHJldHVybiBuZXcgQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCBldmVudEluZm8pOyAqL1xyXG4gICAgICAgIHJldHVybiBuZXcgQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCB7IGRldGFpbCwgYnViYmxlczogZmFsc2UsIGNhbmNlbGFibGU6IGZhbHNlIH0pOyAvLyBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQgYnkgZGVmYXVsdCBieSBJRSA7IFdlIHVzZSB0aGUgcG9seWZpbGwgZm9yIElFOSBhbmQgbGF0ZXIuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBjdXN0b20gZXZlbnQgYW5kIGltbWVkaWF0ZWx5IGJyb2FkY2FzdCBpdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lIHN0cmluZ1xyXG4gICAgICogQHBhcmFtIGRldGFpbFxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHNlbmRDdXN0b21FdmVudChldmVudE5hbWUsIGRldGFpbCA9IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChjcmVhdGVDdXN0b21FdmVudChldmVudE5hbWUsIGRldGFpbCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUG9seWZpbGwgZnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3VzdG9tRXZlbnQvQ3VzdG9tRXZlbnQgZm9yIG9ic29sZXRlIGJyb3dzZXJzIChJRSlcclxuICAgICAqL1xyXG4gICAgKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93LkN1c3RvbUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIEN1c3RvbUV2ZW50KGV2ZW50LCBwYXJhbXMpIHtcclxuICAgICAgICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHsgYnViYmxlczogZmFsc2UsIGNhbmNlbGFibGU6IGZhbHNlLCBkZXRhaWw6IHZvaWQoMCkgfTtcclxuICAgICAgICAgICAgY29uc3QgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XHJcbiAgICAgICAgICAgIGV2dC5pbml0Q3VzdG9tRXZlbnQoZXZlbnQsIHBhcmFtcy5idWJibGVzLCBwYXJhbXMuY2FuY2VsYWJsZSwgcGFyYW1zLmRldGFpbCk7XHJcbiAgICAgICAgICAgIHJldHVybiBldnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBDdXN0b21FdmVudC5wcm90b3R5cGUgPSB3aW5kb3cuRXZlbnQucHJvdG90eXBlO1xyXG4gICAgICAgIHdpbmRvdy5DdXN0b21FdmVudCA9IEN1c3RvbUV2ZW50O1xyXG4gICAgfSkoKTtcclxufSkpO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgZXhwb3J0cyB0aGUgaW50ZXJmYWNlIGZvciB0aGUgYXV0b051bWVyaWMgb2JqZWN0XHJcbiAqL1xyXG4vKiBleHBvcnQgZGVmYXVsdCB7XHJcbiAgICBmb3JtYXQgIDogYXV0b0Zvcm1hdCxcclxuICAgIHVuRm9ybWF0OiBhdXRvVW5Gb3JtYXQsXHJcbiAgICBnZXREZWZhdWx0Q29uZmlnLFxyXG5cclxuICAgIC8vVE9ETyBDb21wbGV0ZSB0aGUgaW50ZXJmYWNlIHdpdGggZnVuY3Rpb25zIGhhdmluZyB0aGUgZm9sbG93aW5nIHNpZ25hdHVyZXMgOlxyXG4gICAgLy9pbml0ICAgICAgICAgOiBhbi5pbml0KG9wdGlvbnMsIGlucHV0KVxyXG4gICAgLy9nZXQgICAgICAgICAgOiBhbi5nZXQoaW5wdXQpXHJcbiAgICAvL3NldCAgICAgICAgICA6IGFuLnNldCh2YWx1ZSwgaW5wdXQpXHJcbiAgICAvL2Zvcm1TdHJpbmcgICA6IGFuLmZvcm1TdHJpbmcoZm9ybSlcclxuICAgIC8vZm9ybUFycmF5ICAgIDogYW4uZm9ybUFycmF5KGZvcm0pXHJcbiAgICAvL2dldEZvcm1hdHRlZCA6IGFuLmdldEZvcm1hdHRlZChpbnB1dClcclxuICAgIC8vdW5zZXQgICAgICAgIDogYW4udW5zZXQoaW5wdXQpIC8vdG8gcmVuYW1lIHRvICd1bmZvcm1hdCc/IChhbmQgbWVyZ2Ugd2l0aCBhdXRvVW5Gb3JtYXQvdW5Gb3JtYXQ/KVxyXG4gICAgLy9yZWZvcm1hdCAgICAgOiBhbi5yZWZvcm1hdChpbnB1dCkgLy8gJ3JlU2V0JyBpcyB2ZXJ5IHRvIGNsb3NlIHRvICdyZXNldCcgYW5kIHRoZXJlZm9yZSBzaG91bGQgYmUgcmVuYW1lZC4gV2UgY291bGQgc3RpbGwgZXhwb3NlICdyZVNldCcsIGJ1dCBhZGQgYSBAZGVwcmVjYXRlZCB0YWcgb24gaXRzIGRlY2xhcmF0aW9uLlxyXG4gICAgLy9zZXR0aW5ncyAgICAgOiBhbi5zZXR0aW5ncyhpbnB1dClcclxuICAgIC8vdXBkYXRlICAgICAgIDogYW4udXBkYXRlKG9wdGlvbnMsIGlucHV0KVxyXG4gICAgLy93aXBlICAgICAgICAgOiBhbi53aXBlKGlucHV0KVxyXG4gICAgLy9kZXN0cm95ICAgICAgOiBhbi5kZXN0cm95KGlucHV0KVxyXG4gICAgLy92YWxpZGF0ZSAgICAgOiBhbi52YWxpZGF0ZShvcHRpb25zKVxyXG59OyAqL1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL2JvYmtuL0RvY3VtZW50cy9HaXRIdWIvYXV0b051bWVyaWMvc3JjL2F1dG9OdW1lcmljLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 1 */
/***/ function(module, exports) {

	eval("module.exports = __WEBPACK_EXTERNAL_MODULE_1__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wicm9vdFwiOlwialF1ZXJ5XCIsXCJjb21tb25qc1wiOlwianF1ZXJ5XCIsXCJjb21tb25qczJcIjpcImpxdWVyeVwiLFwiYW1kXCI6XCJqcXVlcnlcIn0/NWNiYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzFfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCB7XCJyb290XCI6XCJqUXVlcnlcIixcImNvbW1vbmpzXCI6XCJqcXVlcnlcIixcImNvbW1vbmpzMlwiOlwianF1ZXJ5XCIsXCJhbWRcIjpcImpxdWVyeVwifVxuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }
/******/ ])
});
;